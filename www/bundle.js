"bundle";
System.registerDynamic("app/features/StepDefinitionEditor/StepDefinitionEditor.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<tractor-file-tree model=\"stepDefinitionEditor\" type=\"step-definitions\"></tractor-file-tree>\n<tractor-panel-handle panel-name=\"step-definition-file-tree\"></tractor-panel-handle>\n<form class=\"file\" name=\"stepDefinitionEditor.fileEditor\" novalidate\n    ng-submit=\"stepDefinitionEditor.showErrors() && stepDefinitionEditor.saveFile()\">\n    <section class=\"file-options\" ng-if=\"stepDefinitionEditor.fileModel\">\n        <h1 class=\"file-options__name\">{{ stepDefinitionEditor.fileModel.name }}</h1>\n        <div class=\"file-options__file-actions\">\n            <tractor-confirm-dialog trigger=\"stepDefinitionEditor.confirmOverWrite\">\n                <p>This will overwrite \"{{ stepDefinitionEditor.fileModel.name }}\". Continue?</p>\n            </tractor-confirm-dialog>\n            <tractor-submit class=\"file-options__save-file\"\n                action=\"Save step definition file\">\n            </tractor-submit>\n        </div>\n    </section>\n\n    <section class=\"file-editor\" ng-if=\"stepDefinitionEditor.fileModel\">\n        <section ng-if=\"stepDefinitionEditor.canAddComponents\">\n            <section class=\"file-editor__container\">\n                <h2>Available components:</h2>\n                <ul>\n                    <li ng-repeat=\"component in stepDefinitionEditor.fileModel.availableComponents\"\n                        ng-if=\"stepDefinitionEditor.fileModel.components.indexOf(component) === -1\">\n                        <span> {{ component.name }} </spam>\n                        <tractor-action\n                            model=\"stepDefinitionEditor.fileModel\"\n                            action=\"Add component\"\n                            argument=\"component.name\">\n                        </tractor-action>\n                    </li>\n                </ul>\n            </section>\n\n            <section class=\"file-editor__container\"\n                ng-if=\"stepDefinitionEditor.hasComponents\">\n                <h2>Active components:</h2>\n                <ul>\n                    <li ng-repeat=\"component in stepDefinitionEditor.fileModel.componentInstances\">\n                        <span> {{ component.component.name }} </span>\n                        <tractor-action\n                            model=\"stepDefinitionEditor.fileModel\"\n                            action=\"Remove component\"\n                            argument=\"component\"\n                            icon=\"remove\">\n                        </tractor-action>\n                    </li>\n                </ul>\n            </section>\n        </section>\n\n        <section ng-if=\"stepDefinitionEditor.canAddMockData\">\n            <section class=\"file-editor__container\">\n                <h2>Available mock data:</h2>\n                <ul>\n                    <li ng-repeat=\"mockData in stepDefinitionEditor.fileModel.availableMockData\"\n                        ng-if=\"stepDefinitionEditor.fileModel.mockData.indexOf(mockData) === -1\">\n                        <span> {{ mockData.name }} </spam>\n                        <tractor-action\n                            model=\"stepDefinitionEditor.fileModel\"\n                            action=\"Add mock\"\n                            argument=\"mockData.name\">\n                        </tractor-action>\n                    </li>\n                </ul>\n            </section>\n\n            <section class=\"file-editor__container\"\n                ng-if=\"stepDefinitionEditor.hasMockData\">\n                <h2>Active mock data:</h2>\n                <ul>\n                    <li ng-repeat=\"mockData in stepDefinitionEditor.fileModel.mockDataInstances\">\n                        <span> {{ mockData.mockData.name }} </span>\n                        <tractor-action\n                            model=\"stepDefinitionEditor.fileModel\"\n                            action=\"Remove mock\"\n                            argument=\"mock\"\n                            icon=\"remove\">\n                        </tractor-action>\n                    </li>\n                </ul>\n            </section>\n        </section>\n\n        <section class=\"file-editor__container\" ng-if=\"stepDefinitionEditor.showMockDataSection\">\n            <h2>Mock Data:</h2>\n\n            <ul>\n                <li class=\"file-editor__list-item\" ng-repeat=\"mock in stepDefinitionEditor.fileModel.step.mocks\">\n                    <tractor-action\n                        model=\"stepDefinitionEditor.fileModel.step\"\n                        action=\"Remove mock\"\n                        argument=\"mock\"\n                        icon=\"remove\">\n                    </tractor-action>\n\n                    <tractor-text-input\n                        form=\"stepDefinitionEditor.fileEditor\"\n                        label=\"URL\"\n                        model=\"mock\"\n                        example=\"http://example.com\">\n                    </tractor-text-input>\n                    <tractor-select\n                        label=\"Action\"\n                        model=\"mock\">\n                    </tractor-select>\n                    <tractor-checkbox\n                        label=\"Pass through\"\n                        model=\"mock\">\n                    </tractor-checkbox>\n                    <tractor-select\n                        ng-if=\"!mock.passThrough && stepDefinitionEditor.hasMockData\"\n                        label=\"Data\"\n                        model=\"mock\"\n                        options=\"stepDefinitionEditor.fileModel.mockDataInstances\"\n                        as=\"name\">\n                    </tractor-select>\n                </li>\n            </ul>\n\n            <tractor-action\n                model=\"stepDefinitionEditor.fileModel.step\"\n                action=\"Add mock\">\n            </tractor-action>\n        </section>\n\n        <section class=\"file-editor__container\" ng-if=\"stepDefinitionEditor.showTasksSection\">\n            <h2>Tasks:</h2>\n\n            <ol ng-if=\"stepDefinitionEditor.fileModel.step.tasks.length\" as-sortable ng-model=\"stepDefinitionEditor.fileModel.step.tasks\" is-disabled=\"stepDefinitionEditor.fileModel.step.tasks.length < 2\">\n                <li class=\"file-editor__list-item\" ng-repeat=\"task in stepDefinitionEditor.fileModel.step.tasks\" as-sortable-item>\n                    <tractor-action\n                        model=\"stepDefinitionEditor.fileModel.step\"\n                        action=\"Remove task\"\n                        argument=\"task\"\n                        icon=\"remove\">\n                    </tractor-action>\n                    <div ng-if=\"stepDefinitionEditor.fileModel.step.tasks.length > 1\" class=\"file-editor__list-item-sort-handle\" as-sortable-item-handle title=\"Drag to sort\"></div>\n\n                    <tractor-select\n                        label=\"Component\"\n                        model=\"task\"\n                        options=\"stepDefinitionEditor.fileModel.componentInstances\"\n                        as=\"name\">\n                    </tractor-select>\n                    <tractor-select\n                        label=\"Action\"\n                        model=\"task\"\n                        options=\"task.component.component.actions\"\n                        as=\"name\">\n                    </tractor-select>\n                    <div ng-repeat=\"argument in task.arguments\">\n                        <tractor-literal-input\n                            form=\"stepDefinitionEditor.fileEditor\"\n                            name=\"argument.name\"\n                            model=\"argument\"\n                            required>\n                        </tractor-literal-input>\n                    </div>\n                </li>\n            </ol>\n\n            <tractor-action\n                model=\"stepDefinitionEditor.fileModel.step\"\n                action=\"Add task\">\n            </tractor-action>\n        </section>\n\n        <section  class=\"file-editor__container\" ng-if=\"stepDefinitionEditor.showExpectationsSection\">\n            <h2>Expectations:</h2>\n\n            <ul>\n                <li class=\"file-editor__list-item\" ng-repeat=\"expectation in stepDefinitionEditor.fileModel.step.expectations\">\n                    <tractor-action\n                        model=\"stepDefinitionEditor.fileModel.step\"\n                        action=\"Remove expectation\"\n                        argument=\"expectation\"\n                        icon=\"remove\">\n                    </tractor-action>\n\n                    <tractor-select\n                        label=\"Component\"\n                        model=\"expectation\"\n                        options=\"stepDefinitionEditor.fileModel.componentInstances\"\n                        as=\"name\">\n                    </tractor-select>\n                    <tractor-select\n                        label=\"Action\"\n                        model=\"expectation\"\n                        options=\"expectation.component.component.actions\"\n                        as=\"name\">\n                    </tractor-select>\n                    <tractor-select\n                        label=\"condition\"\n                        model=\"expectation\"\n                        options=\"expectation.conditions\">\n                    </tractor-select>\n                    <div ng-repeat=\"argument in expectation.arguments\">\n                        <tractor-literal-input\n                            form=\"stepDefinitionEditor.fileEditor\"\n                            name=\"argument.name\"\n                            model=\"argument\"\n                            type=\"argument.type\">\n                        </tractor-literal-input>\n                    </div>\n                    <tractor-literal-input\n                        form=\"file-editor\"\n                        name=\"'Expected result'\"\n                        model=\"expectation\">\n                    </tractor-literal-input>\n                </li>\n            </ul>\n\n            <tractor-action\n                model=\"stepDefinitionEditor.fileModel.step\"\n                action=\"Add expectation\">\n            </tractor-action>\n        </section>\n    </section>\n</form>\n";
  global.define = __define;
  return module.exports;
});

System.register('app/features/StepDefinitionEditor/Models/MockDataInstanceModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:change-case@2.3.0', 'github:jspm/nodelibs-path@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, changecase, path, angular, ASTCreatorService;

    function createMockDataInstanceModelConstructor(astCreatorService) {
        var mockData = _Symbol();
        var stepDefinition = _Symbol();

        return (function () {
            function MockDataInstanceModel(_mockData, _stepDefinition) {
                _classCallCheck(this, MockDataInstanceModel);

                this[mockData] = _mockData;
                this[stepDefinition] = _stepDefinition;
            }

            _createClass(MockDataInstanceModel, [{
                key: 'mockData',
                get: function get() {
                    return this[mockData];
                }
            }, {
                key: 'stepDefinition',
                get: function get() {
                    return this[stepDefinition];
                }
            }, {
                key: 'name',
                get: function get() {
                    return this.mockData.name;
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return changecase.camel(this.mockData.name);
                }
            }, {
                key: 'meta',
                get: function get() {
                    return {
                        name: this.name
                    };
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return MockDataInstanceModel;
        })();

        function toAST() {
            // Sw33t hax()rz to get around the node "path" shim not working on Windows.
            var stepDefinitionPath = this.stepDefinition.path.replace(/\\/g, '/');
            var mockDataPath = this.mockData.path.replace(/\\/g, '/');
            var relativePath = path.relative(path.dirname(stepDefinitionPath), mockDataPath);
            relativePath = astCreatorService.literal(relativePath);
            var name = astCreatorService.identifier(this.variableName);

            var template = 'var <%= name %> = require(<%= relativePath %>); ';

            return astCreatorService.template(template, { name: name, relativePath: relativePath });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubJspmNodelibsPath010) {
            path = _githubJspmNodelibsPath010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:

            // Utilities:
            'use strict';
            _export('default', angular.module('tractor.mockDataInstanceModel', [ASTCreatorService.name]).factory('MockDataInstanceModel', createMockDataInstanceModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Models/ComponentInstanceModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:change-case@2.3.0', 'github:jspm/nodelibs-path@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, changecase, path, angular, ASTCreatorService;

    function createComponentInstanceModelConstructor(astCreatorService) {
        var component = _Symbol();
        var stepDefinition = _Symbol();

        return (function () {
            function ComponentInstanceModel(_component, _stepDefinition) {
                _classCallCheck(this, ComponentInstanceModel);

                this[component] = _component;
                this[stepDefinition] = _stepDefinition;
            }

            _createClass(ComponentInstanceModel, [{
                key: 'component',
                get: function get() {
                    return this[component];
                }
            }, {
                key: 'stepDefinition',
                get: function get() {
                    return this[stepDefinition];
                }
            }, {
                key: 'name',
                get: function get() {
                    return this.component.name;
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return changecase.camel(this.component.name);
                }
            }, {
                key: 'meta',
                get: function get() {
                    return {
                        name: this.name
                    };
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return ComponentInstanceModel;
        })();

        function toAST() {
            var template = 'var <%= constructor %> = require(<%= relativePath %>), ';
            template += '<%= name %> = new <%= constructor %>(); ';

            // Sw33t hax()rz to get around the node "path" shim not working on Windows.
            var stepDefinitionPath = this.stepDefinition.path.replace(/^[A-Z]:\\/, '').replace(/\\/g, '/');
            var componentPath = this.component.path.replace(/^[A-Z]:\\/, '').replace(/\\/g, '/');
            var relativePath = path.relative(path.dirname(stepDefinitionPath), componentPath);
            relativePath = astCreatorService.literal(relativePath);

            var constructor = astCreatorService.identifier(this.component.variableName);
            var name = astCreatorService.identifier(this.variableName);

            return astCreatorService.template(template, { constructor: constructor, relativePath: relativePath, name: name });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubJspmNodelibsPath010) {
            path = _githubJspmNodelibsPath010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:

            // Utilities:
            'use strict';
            _export('default', angular.module('tractor.componentInstanceModel', [ASTCreatorService.name]).factory('ComponentInstanceModel', createComponentInstanceModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Models/StepDefinitionModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/features/StepDefinitionEditor/Models/ComponentInstanceModel.js', 'app/features/StepDefinitionEditor/Models/MockDataInstanceModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, ASTCreatorService, ComponentInstanceModel, MockDataInstanceModel;

    function createStepDefinitionModelConstructor(astCreatorService, componentFileService, ComponentInstanceModel, mockDataFileService, MockDataInstanceModel) {
        var components = _Symbol();
        var componentInstances = _Symbol();
        var mockData = _Symbol();
        var mockDataInstances = _Symbol();
        var options = _Symbol();

        return (function () {
            function StepDefinitionModel() {
                var _options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                _classCallCheck(this, StepDefinitionModel);

                this[options] = _options;

                this[components] = [];
                this[componentInstances] = [];

                this[mockData] = [];
                this[mockDataInstances] = [];
            }

            _createClass(StepDefinitionModel, [{
                key: 'addComponent',
                value: function addComponent(name) {
                    var component = this.availableComponents.find(function (component) {
                        return component.name === name;
                    });
                    if (component && !this.components.includes(component)) {
                        this.components.push(component);
                        this.componentInstances.push(new ComponentInstanceModel(component, this));
                    }
                }
            }, {
                key: 'removeComponent',
                value: function removeComponent(toRemove) {
                    var index = this.componentInstances.indexOf(toRemove);
                    this.componentInstances.splice(index, 1);
                    this.components.splice(index, 1);
                }
            }, {
                key: 'addMock',
                value: function addMock(name) {
                    var mockData = this.availableMockData.find(function (mockData) {
                        return mockData.name === name;
                    });
                    if (mockData && !this.mockData.includes(mockData)) {
                        this.mockData.push(mockData);
                        this.mockDataInstances.push(new MockDataInstanceModel(mockData, this));
                    }
                }
            }, {
                key: 'removeMock',
                value: function removeMock(toRemove) {
                    var index = this.mockDataInstances.indexOf(toRemove);
                    this.mockDataInstances.splice(index, 1);
                    this.mockData.splice(index, 1);
                }
            }, {
                key: 'availableComponents',
                get: function get() {
                    return this[options].availableComponents || [];
                }
            }, {
                key: 'availableMockData',
                get: function get() {
                    return this[options].availableMockData || [];
                }
            }, {
                key: 'path',
                get: function get() {
                    return this[options].path;
                }
            }, {
                key: 'components',
                get: function get() {
                    return this[components];
                }
            }, {
                key: 'componentInstances',
                get: function get() {
                    return this[componentInstances];
                }
            }, {
                key: 'mockData',
                get: function get() {
                    return this[mockData];
                }
            }, {
                key: 'mockDataInstances',
                get: function get() {
                    return this[mockDataInstances];
                }
            }, {
                key: 'meta',
                get: function get() {
                    return JSON.stringify({
                        name: this.name,
                        components: this.componentInstances.map(function (component) {
                            return component.meta;
                        }),
                        mockData: this.mockDataInstances.map(function (mockData) {
                            return mockData.meta;
                        })
                    });
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }, {
                key: 'data',
                get: function get() {
                    return this.ast;
                }
            }]);

            return StepDefinitionModel;
        })();

        function toAST() {
            var components = this.componentInstances.map(function (component) {
                return component.ast;
            });
            var mockData = this.mockDataInstances.map(function (mockData) {
                return mockData.ast;
            });

            var template = 'module.exports = function () { ';
            if (components.length) {
                template += '%= components %; ';
            }
            if (mockData.length) {
                template += '%= mockData %; ';
            }
            template += '%= step %; ';
            template += '};';

            var step = this.step.ast;
            return astCreatorService.file(astCreatorService.expression(template, { components: components, mockData: mockData, step: step }), this.meta);
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsComponentInstanceModelJs) {
            ComponentInstanceModel = _appFeaturesStepDefinitionEditorModelsComponentInstanceModelJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsMockDataInstanceModelJs) {
            MockDataInstanceModel = _appFeaturesStepDefinitionEditorModelsMockDataInstanceModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            _export('default', angular.module('tractor.stepDefinitionModel', [ASTCreatorService.name, ComponentInstanceModel.name, MockDataInstanceModel.name]).factory('StepDefinitionModel', createStepDefinitionModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Services/TaskParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/StepDefinitionEditor/Models/TaskModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, TaskModel, TaskParserService;

    function parseTaskCallExpression(ast, parsers) {
        var _this = this;

        var taskCallExpression = null;
        parsers.filter(function (parser) {
            try {
                taskCallExpression = parser.call(_this, ast);
            } catch (e) {}
        });
        if (!taskCallExpression) {
            throw new Error();
        }
        return taskCallExpression;
    }

    function parseFirstTask(ast) {
        assert(ast.callee.object.name && ast.callee.property.name);
        return ast;
    }

    function parseSubsequentTask(ast) {
        var _ast$arguments = _slicedToArray(ast.arguments, 1);

        var thenFunctionExpression = _ast$arguments[0];

        var _thenFunctionExpression$body$body = _slicedToArray(thenFunctionExpression.body.body, 1);

        var taskReturnStatement = _thenFunctionExpression$body$body[0];
        var argument = taskReturnStatement.argument;

        assert(argument.callee.object.name && argument.callee.property.name);
        return argument;
    }

    function parseTask(step, taskCallExpression) {
        var task = new this.TaskModel(step);
        task.component = task.step.stepDefinition.componentInstances.find(function (componentInstance) {
            return taskCallExpression.callee.object.name === componentInstance.variableName;
        });
        assert(task.component);
        task.action = task.component.component.actions.find(function (action) {
            return taskCallExpression.callee.property.name === action.variableName;
        });
        assert(task.action);
        taskCallExpression.arguments.forEach(function (argument, index) {
            task.arguments[index].value = argument.value;
        });
        task.step.tasks.push(task);
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsTaskModelJs) {
            TaskModel = _appFeaturesStepDefinitionEditorModelsTaskModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            TaskParserService = (function () {
                function TaskParserService(TaskModel) {
                    _classCallCheck(this, TaskParserService);

                    this.TaskModel = TaskModel;
                }

                _createClass(TaskParserService, [{
                    key: 'parse',
                    value: function parse(step, ast) {
                        try {
                            this.parseNextTask(step, ast);

                            var parsers = [parseFirstTask, parseSubsequentTask];
                            var taskCallExpression = parseTaskCallExpression.call(this, ast, parsers);

                            try {
                                return parseTask.call(this, step, taskCallExpression);
                            } catch (e) {}

                            throw new Error();
                        } catch (e) {
                            console.warn('Invalid task:', ast);
                            return null;
                        }
                    }
                }, {
                    key: 'parseNextTask',
                    value: function parseNextTask(step, ast) {
                        try {
                            assert(ast.callee.object.callee);
                            this.parse(step, ast.callee.object);
                        } catch (e) {}
                    }
                }]);

                return TaskParserService;
            })();

            _export('default', angular.module('tractor.taskParserService', [TaskModel.name]).service('taskParserService', TaskParserService));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Models/TaskModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ArgumentModel.js', 'app/Core/Services/ASTCreatorService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, angular, ArgumentModel, ASTCreatorService;

    function createTaskModelConstructor(astCreatorService, ArgumentModel) {
        var action = _Symbol();
        var args = _Symbol();
        var component = _Symbol();
        var step = _Symbol();

        return (function () {
            function TaskModel(_step) {
                _classCallCheck(this, TaskModel);

                this[step] = _step;

                var _step$stepDefinition$componentInstances = _slicedToArray(this.step.stepDefinition.componentInstances, 1);

                var firstComponent = _step$stepDefinition$componentInstances[0];

                this.component = firstComponent;
            }

            _createClass(TaskModel, [{
                key: 'step',
                get: function get() {
                    return this[step];
                }
            }, {
                key: 'component',
                get: function get() {
                    return this[component];
                },
                set: function set(newComponent) {
                    this[component] = newComponent;

                    var _component$component$actions = _slicedToArray(this.component.component.actions, 1);

                    var firstAction = _component$component$actions[0];

                    this.action = firstAction;
                }
            }, {
                key: 'action',
                get: function get() {
                    return this[action];
                },
                set: function set(newAction) {
                    this[action] = newAction;
                    this[args] = parseArguments.call(this);
                }
            }, {
                key: 'arguments',
                get: function get() {
                    return this[args];
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return TaskModel;
        })();

        function toAST() {
            var template = '<%= component %>.<%= action %>(%= taskArguments %)';

            var action = astCreatorService.identifier(this.action.variableName);
            var component = astCreatorService.identifier(this.component.variableName);
            var taskArguments = this.arguments.map(function (argument) {
                return argument.ast;
            });

            return astCreatorService.template(template, { action: action, component: component, taskArguments: taskArguments }).expression;
        }

        function parseArguments() {
            return this.action.parameters.map(function (parameter) {
                var name = parameter.name;
                name = name.replace(/([A-Z])/g, ' $1');
                name = '' + name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                return new ArgumentModel(null, { name: name });
            });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsArgumentModelJs) {
            ArgumentModel = _appFeaturesComponentEditorModelsArgumentModelJs['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            _export('default', angular.module('tractor.taskModel', [ArgumentModel.name, ASTCreatorService.name]).factory('TaskModel', createTaskModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Models/StepModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/features/StepDefinitionEditor/Models/ExpectationModel.js', 'app/features/StepDefinitionEditor/Models/MockModel.js', 'app/features/StepDefinitionEditor/Models/TaskModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, ASTCreatorService, ExpectationModel, MockModel, TaskModel;

    function createStepModelConstructor(astCreatorService, ExpectationModel, TaskModel, MockModel) {
        var expectations = _Symbol();
        var mocks = _Symbol();
        var stepDefinition = _Symbol();
        var tasks = _Symbol();

        return (function () {
            function StepModel(_stepDefinition) {
                _classCallCheck(this, StepModel);

                this[expectations] = [];
                this[mocks] = [];
                this[stepDefinition] = _stepDefinition;
                this[tasks] = [];

                this.stepTypes = ['Given', 'When', 'Then', 'And', 'But'];
            }

            _createClass(StepModel, [{
                key: 'addExpectation',
                value: function addExpectation() {
                    this.expectations.push(new ExpectationModel(this));
                }
            }, {
                key: 'removeExpectation',
                value: function removeExpectation(toRemove) {
                    this.expectations.splice(this.expectations.findIndex(function (expectation) {
                        return expectation === toRemove;
                    }), 1);
                }
            }, {
                key: 'addTask',
                value: function addTask() {
                    this.tasks.push(new TaskModel(this));
                }
            }, {
                key: 'removeTask',
                value: function removeTask(toRemove) {
                    this.tasks.splice(this.tasks.findIndex(function (task) {
                        return task === toRemove;
                    }), 1);
                }
            }, {
                key: 'addMock',
                value: function addMock() {
                    this.mocks.push(new MockModel(this));
                }
            }, {
                key: 'removeMock',
                value: function removeMock(toRemove) {
                    this.mocks.splice(this.mocks.findIndex(function (mock) {
                        return mock === toRemove;
                    }), 1);
                }
            }, {
                key: 'expectations',
                get: function get() {
                    return this[expectations];
                }
            }, {
                key: 'mocks',
                get: function get() {
                    return this[mocks];
                }
            }, {
                key: 'stepDefinition',
                get: function get() {
                    return this[stepDefinition];
                }
            }, {
                key: 'tasks',
                get: function get() {
                    return this[tasks];
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return StepModel;
        })();

        function toAST() {
            var expectations = this.expectations.map(function (expectation) {
                return expectation.ast;
            });
            var mocks = this.mocks.map(function (mock) {
                return mock.ast;
            });
            var tasks = this.tasks.map(function (task) {
                return task.ast;
            });

            var template = 'this.<%= type %>(<%= regex %>, function (done) { ';
            if (mocks.length) {
                template += '%= mocks %; ';
                template += 'done();';
            } else if (tasks.length) {
                template += 'var tasks = <%= tasks[0] %>';
                tasks.slice(1).forEach(function (taskAST, index) {
                    template += '.then(function () { return <%= tasks[' + (index + 1) + '] %>; })';
                });
                template += ';';
                template += 'Promise.resolve(tasks).then(done).catch(done.fail);';
            } else if (expectations.length) {
                template += 'Promise.all([%= expectations %]).spread(function () { done(); }).catch(done.fail);';
            } else {
                template += 'done.pending();';
            }
            template += '});';

            var type = astCreatorService.identifier(this.type);
            var regex = astCreatorService.literal(this.regex);
            return astCreatorService.template(template, { type: type, regex: regex, mocks: mocks, tasks: tasks, expectations: expectations });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsExpectationModelJs) {
            ExpectationModel = _appFeaturesStepDefinitionEditorModelsExpectationModelJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsMockModelJs) {
            MockModel = _appFeaturesStepDefinitionEditorModelsMockModelJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsTaskModelJs) {
            TaskModel = _appFeaturesStepDefinitionEditorModelsTaskModelJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            _export('default', angular.module('tractor.stepModel', [ASTCreatorService.name, ExpectationModel.name, MockModel.name, TaskModel.name]).factory('StepModel', createStepModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Models/MockModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, angular, ASTCreatorService;

    function createMockModelConstructor(astCreatorService) {
        var step = _Symbol();

        return (function () {
            function MockModel(_step) {
                _classCallCheck(this, MockModel);

                this[step] = _step;

                this.actions = ['GET', 'POST', 'DELETE', 'PUT', 'HEAD', 'PATCH'];

                var _actions = _slicedToArray(this.actions, 1);

                var action = _actions[0];

                this.action = action;

                var _step$stepDefinition$mockDataInstances = _slicedToArray(this.step.stepDefinition.mockDataInstances, 1);

                var mockDataInstance = _step$stepDefinition$mockDataInstances[0];

                this.data = mockDataInstance;

                this.passThrough = false;
                this.url = '';
            }

            _createClass(MockModel, [{
                key: 'step',
                get: function get() {
                    return this[step];
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return MockModel;
        })();

        function toAST() {
            var data = {
                url: astCreatorService.literal(new RegExp(this.url))
            };
            var template = 'httpBackend.when' + this.action + '(%= url %)';
            if (this.passThrough) {
                template += '.passThrough(); ';
            } else {
                template += '.respond(%= dataName %); ';
                data.dataName = astCreatorService.identifier(this.data.variableName);
            }

            return astCreatorService.template(template, data);
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            _export('default', angular.module('tractor.mockModel', [ASTCreatorService.name]).factory('MockModel', createMockModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Services/MockParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/StepDefinitionEditor/Models/MockModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, MockModel, MockParserService;

    function tryParse(mock, mockCallExpression, parsers) {
        var _this = this;

        var parsed = parsers.some(function (parser) {
            try {
                return parser.call(_this, mock, mockCallExpression);
            } catch (e) {}
        });
        if (!parsed) {
            throw new Error();
        }
    }

    function parseAction(mock, mockCallExpression) {
        var action = mockCallExpression.callee.object.callee.property.name.replace(/^when/, '');
        assert(action);
        assert(mock.actions.includes(action));
        mock.action = action;
        return true;
    }

    function parseUrl(mock, mockCallExpression) {
        var _mockCallExpression$callee$object$arguments$slice$reverse = mockCallExpression.callee.object.arguments.slice().reverse();

        var _mockCallExpression$callee$object$arguments$slice$reverse2 = _slicedToArray(_mockCallExpression$callee$object$arguments$slice$reverse, 1);

        var argument = _mockCallExpression$callee$object$arguments$slice$reverse2[0];

        var url = argument.raw;
        var urlRegex = new RegExp(url.replace(/^\//, '').replace(/\/$/, ''));
        assert(urlRegex);
        mock.url = urlRegex.source;
        return true;
    }

    function parseData(mock, mockCallExpression) {
        var _mockCallExpression$arguments = _slicedToArray(mockCallExpression.arguments, 1);

        var argument = _mockCallExpression$arguments[0];

        var instanceName = argument.name;
        mock.data = mock.step.stepDefinition.mockDataInstances.find(function (mockDataInstance) {
            return mockDataInstance.variableName === instanceName;
        });
        return true;
    }

    function parsePassThrough(mock, mockCallExpression) {
        assert(mockCallExpression.callee.property.name === 'passThrough');
        mock.passThrough = true;
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsMockModelJs) {
            MockModel = _appFeaturesStepDefinitionEditorModelsMockModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            MockParserService = (function () {
                function MockParserService(MockModel) {
                    _classCallCheck(this, MockParserService);

                    this.MockModel = MockModel;
                }

                _createClass(MockParserService, [{
                    key: 'parse',
                    value: function parse(step, ast) {
                        try {
                            var mock = new this.MockModel(step);

                            var mockCallExpression = ast.expression;

                            parseAction(mock, mockCallExpression);
                            parseUrl(mock, mockCallExpression);

                            var parsers = [parseData, parsePassThrough];
                            tryParse.call(this, mock, mockCallExpression, parsers);

                            return mock;
                        } catch (e) {
                            console.warn('Invalid mock:', ast);
                            return null;
                        }
                    }
                }]);

                return MockParserService;
            })();

            _export('default', angular.module('tractor.mockParserService', [MockModel.name]).service('mockParserService', MockParserService));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Models/ExpectationModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ArgumentModel.js', 'app/Core/Services/ASTCreatorService.js', 'app/Core/Services/StringToLiteralService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, angular, ArgumentModel, ASTCreatorService, StringToLiteralService;

    function createExpectationModelConstructor(ArgumentModel, astCreatorService, stringToLiteralService) {
        var action = _Symbol();
        var args = _Symbol();
        var component = _Symbol();
        var step = _Symbol();

        return (function () {
            function ExpectationModel(_step) {
                _classCallCheck(this, ExpectationModel);

                this[step] = _step;

                var _step$stepDefinition$componentInstances = _slicedToArray(this.step.stepDefinition.componentInstances, 1);

                var componentInstance = _step$stepDefinition$componentInstances[0];

                this.component = componentInstance;

                this.conditions = ['equal', 'contain'];

                var _conditions = _slicedToArray(this.conditions, 1);

                var condition = _conditions[0];

                this.condition = condition;

                this.value = '';
            }

            _createClass(ExpectationModel, [{
                key: 'step',
                get: function get() {
                    return this[step];
                }
            }, {
                key: 'component',
                get: function get() {
                    return this[component];
                },
                set: function set(newComponent) {
                    this[component] = newComponent;

                    var _component$component$actions = _slicedToArray(this.component.component.actions, 1);

                    var action = _component$component$actions[0];

                    this.action = action;
                }
            }, {
                key: 'action',
                get: function get() {
                    return this[action];
                },
                set: function set(newAction) {
                    this[action] = newAction;
                    this[args] = parseArguments.call(this);
                }
            }, {
                key: 'arguments',
                get: function get() {
                    return this[args];
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return ExpectationModel;
        })();

        function toAST() {
            var expectationArguments = this.arguments.map(function (argument) {
                return argument.ast;
            });
            var expectedResult = astCreatorService.literal(stringToLiteralService.toLiteral(this.value));

            var action = astCreatorService.identifier(this.action.variableName);
            var component = astCreatorService.identifier(this.component.variableName);
            var condition = astCreatorService.identifier(this.condition);

            var template = 'expect(<%= component %>.<%= action %>(%= expectationArguments %)).to.eventually.<%= condition %>(<%= expectedResult %>); ';

            return astCreatorService.template(template, { action: action, component: component, condition: condition, expectationArguments: expectationArguments, expectedResult: expectedResult }).expression;
        }

        function parseArguments() {
            return this.action.parameters.map(function (parameter) {
                return new ArgumentModel(null, {
                    name: parameter.name
                });
            });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsArgumentModelJs) {
            ArgumentModel = _appFeaturesComponentEditorModelsArgumentModelJs['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appCoreServicesStringToLiteralServiceJs) {
            StringToLiteralService = _appCoreServicesStringToLiteralServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            _export('default', angular.module('tractor.expectationModel', [ArgumentModel.name, ASTCreatorService.name, StringToLiteralService.name]).factory('ExpectationModel', createExpectationModelConstructor));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Services/ExpectationParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:angular/bower-angular@1.4.7', 'app/features/StepDefinitionEditor/Models/ExpectationModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, angular, ExpectationModel, ExpectationParserService;

    function parseComponent(expectation, expectationCallExpression) {
        return expectation.step.stepDefinition.componentInstances.find(function (componentInstance) {
            return expectationCallExpression.callee.object.name === componentInstance.variableName;
        });
    }

    function parseAction(expectation, expectationCallExpression) {
        return expectation.component.component.actions.find(function (action) {
            return expectationCallExpression.callee.property.name === action.variableName;
        });
    }

    function parseArguments(expectation, expectationCallExpression) {
        expectationCallExpression.arguments.forEach(function (argument, index) {
            expectation.arguments[index].value = argument.value;
        });
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsExpectationModelJs) {
            ExpectationModel = _appFeaturesStepDefinitionEditorModelsExpectationModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            ExpectationParserService = (function () {
                function ExpectationParserService(ExpectationModel) {
                    _classCallCheck(this, ExpectationParserService);

                    this.ExpectationModel = ExpectationModel;
                }

                _createClass(ExpectationParserService, [{
                    key: 'parse',
                    value: function parse(step, ast) {
                        try {
                            var expectation = new this.ExpectationModel(step);

                            var _ast$arguments = _slicedToArray(ast.arguments, 1);

                            var firstArgument = _ast$arguments[0];

                            expectation.value = firstArgument.value;

                            var _ast$callee$object$object$object$arguments = _slicedToArray(ast.callee.object.object.object.arguments, 1);

                            var expectationCallExpression = _ast$callee$object$object$object$arguments[0];

                            expectation.component = parseComponent(expectation, expectationCallExpression);
                            expectation.action = parseAction(expectation, expectationCallExpression);
                            expectation.condition = ast.callee.property.name;
                            parseArguments(expectation, expectationCallExpression);

                            return expectation;
                        } catch (e) {
                            console.warn('Invalid expectation:', ast);
                            return null;
                        }
                    }
                }]);

                return ExpectationParserService;
            })();

            _export('default', angular.module('tractor.expectationParserService', [ExpectationModel.name]).service('expectationParserService', ExpectationParserService));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Services/StepParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/StepDefinitionEditor/Services/ExpectationParserService.js', 'app/features/StepDefinitionEditor/Services/MockParserService.js', 'app/features/StepDefinitionEditor/Models/StepModel.js', 'app/features/StepDefinitionEditor/Services/TaskParserService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, ExpectationParserService, MockParserService, StepModel, TaskParserService, StepParserService;

    function parseType(step, stepCallExpression) {
        var type = stepCallExpression.callee.property.name;
        assert(step.stepTypes.includes(type));
        return type;
    }

    function parseRegex(step, stepCallExpression) {
        var _stepCallExpression$arguments = _slicedToArray(stepCallExpression.arguments, 1);

        var stepRegexArgument = _stepCallExpression$arguments[0];

        var regex = stepRegexArgument.raw.replace(/^\//, '').replace(/\/$/, '');
        assert(regex);
        return new RegExp(regex);
    }

    function tryParse(step, statements, parsers) {
        var _this = this;

        statements.map(function (statement) {
            var parsed = parsers.some(function (parser) {
                try {
                    return parser.call(_this, step, statement);
                } catch (e) {}
            });
            if (!parsed) {
                throw new Error();
            }
        });
    }

    function parseMock(step, statement) {
        var httpBackendOnloadMemberExpression = statement.expression.callee.object.callee;
        assert(httpBackendOnloadMemberExpression.object.name === 'httpBackend');
        assert(httpBackendOnloadMemberExpression.property.name.indexOf('when') === 0);
        var mock = this.mockParserService.parse(step, statement);
        assert(mock);
        step.mocks.push(mock);
        return true;
    }

    function parseTask(step, statement) {
        var _statement$declarations = _slicedToArray(statement.declarations, 1);

        var tasksDeclaration = _statement$declarations[0];

        assert(tasksDeclaration.id.name === 'tasks');
        this.taskParserService.parse(step, tasksDeclaration.init);
        return true;
    }

    function parseExpectation(step, statement) {
        var _this2 = this;

        var _statement$expression$callee$object$callee$object$arguments = _slicedToArray(statement.expression.callee.object.callee.object.arguments, 1);

        var argument = _statement$expression$callee$object$callee$object$arguments[0];

        argument.elements.forEach(function (element) {
            assert(!(element.name && element.name === 'tasks'));
            var expectation = _this2.expectationParserService.parse(step, element);
            assert(expectation);
            step.expectations.push(expectation);
        });
        return true;
    }

    function parsePending(step, statement) {
        var callee = statement.expression.callee;
        assert(callee.object.name === 'callback' || callee.object.name === 'done');
        assert(callee.property.name === 'pending');
        return true;
    }

    function parseMockDone(step, statement) {
        assert(statement.expression.callee.name === 'done');
        return true;
    }

    function parseTaskDone(step, statement) {
        var _statement$expression$callee$object$arguments = _slicedToArray(statement.expression.callee.object.arguments, 1);

        var argument = _statement$expression$callee$object$arguments[0];

        assert(argument.name === 'done');
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesExpectationParserServiceJs) {
            ExpectationParserService = _appFeaturesStepDefinitionEditorServicesExpectationParserServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesMockParserServiceJs) {
            MockParserService = _appFeaturesStepDefinitionEditorServicesMockParserServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsStepModelJs) {
            StepModel = _appFeaturesStepDefinitionEditorModelsStepModelJs['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesTaskParserServiceJs) {
            TaskParserService = _appFeaturesStepDefinitionEditorServicesTaskParserServiceJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            StepParserService = (function () {
                function StepParserService(expectationParserService, mockParserService, StepModel, taskParserService) {
                    _classCallCheck(this, StepParserService);

                    this.expectationParserService = expectationParserService;
                    this.mockParserService = mockParserService;
                    this.StepModel = StepModel;
                    this.taskParserService = taskParserService;
                }

                _createClass(StepParserService, [{
                    key: 'parse',
                    value: function parse(stepDefinition, ast) {
                        try {
                            var step = new this.StepModel(stepDefinition);

                            var stepCallExpression = ast.expression;
                            step.type = parseType(step, stepCallExpression);
                            step.regex = parseRegex(step, stepCallExpression);

                            var _ast$expression$arguments$slice$reverse = ast.expression.arguments.slice().reverse();

                            var _ast$expression$arguments$slice$reverse2 = _slicedToArray(_ast$expression$arguments$slice$reverse, 1);

                            var stepFunction = _ast$expression$arguments$slice$reverse2[0];

                            var statements = stepFunction.body.body;
                            var parsers = [parseMock, parseTask, parseExpectation, parsePending, parseMockDone, parseTaskDone];
                            tryParse.call(this, step, statements, parsers);

                            return step;
                        } catch (e) {
                            console.warn('Invalid step:', ast);
                            return null;
                        }
                    }
                }]);

                return StepParserService;
            })();

            _export('default', angular.module('tractor.stepParserService', [ExpectationParserService.name, MockParserService.name, StepModel.name, TaskParserService.name]).service('stepParserService', StepParserService));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Services/StepDefinitionParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/StepDefinitionEditor/Services/StepParserService.js', 'app/features/StepDefinitionEditor/Models/StepDefinitionModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, StepParserService, StepDefinitionModel, StepDefinitionParserService;

    function tryParse(stepDefinition, statements, meta, parsers) {
        var _this = this;

        statements.map(function (statement) {
            var parsed = parsers.some(function (parser) {
                try {
                    return parser.call(_this, stepDefinition, statement, meta);
                } catch (e) {}
            });
            if (!parsed) {
                throw new Error();
            }
        });
    }

    function parseComponent(stepDefinition, statement, meta) {
        var _statement$declarations$slice$reverse = statement.declarations.slice().reverse();

        var _statement$declarations$slice$reverse2 = _slicedToArray(_statement$declarations$slice$reverse, 1);

        var declarator = _statement$declarations$slice$reverse2[0];

        var name = declarator.init.callee.name;
        assert(name !== 'require');
        stepDefinition.addComponent(meta.components[stepDefinition.components.length].name);
        return true;
    }

    function parseMock(stepDefinition, statement, meta) {
        var _statement$declarations = _slicedToArray(statement.declarations, 1);

        var declarator = _statement$declarations[0];

        var name = declarator.init.callee.name;
        assert(name === 'require');

        var _declarator$init$arguments = _slicedToArray(declarator.init.arguments, 1);

        var path = _declarator$init$arguments[0];

        assert(path.value.match(/\.mock.json$/));
        stepDefinition.addMock(meta.mockData[stepDefinition.mockData.length].name);
        return true;
    }

    function parseStep(stepDefinition, statement) {
        var step = this.stepParserService.parse(stepDefinition, statement);
        assert(step);
        stepDefinition.step = step;
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesStepParserServiceJs) {
            StepParserService = _appFeaturesStepDefinitionEditorServicesStepParserServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorModelsStepDefinitionModelJs) {
            StepDefinitionModel = _appFeaturesStepDefinitionEditorModelsStepDefinitionModelJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            StepDefinitionParserService = (function () {
                function StepDefinitionParserService(stepParserService, StepDefinitionModel) {
                    _classCallCheck(this, StepDefinitionParserService);

                    this.stepParserService = stepParserService;
                    this.StepDefinitionModel = StepDefinitionModel;
                }

                _createClass(StepDefinitionParserService, [{
                    key: 'parse',
                    value: function parse(stepDefinitionFile, availableComponents, availableMockData) {
                        try {
                            var ast = stepDefinitionFile.ast;

                            var _ast$comments = _slicedToArray(ast.comments, 1);

                            var metaComment = _ast$comments[0];

                            var meta = JSON.parse(metaComment.value);

                            var stepDefinition = new this.StepDefinitionModel({
                                availableComponents: availableComponents,
                                availableMockData: availableMockData,
                                path: stepDefinitionFile.path
                            });
                            stepDefinition.name = meta.name;

                            var _ast$body = _slicedToArray(ast.body, 1);

                            var _module2 = _ast$body[0];

                            var statements = _module2.expression.right.body.body;

                            var parsers = [parseComponent, parseMock, parseStep];
                            tryParse.call(this, stepDefinition, statements, meta, parsers);

                            return stepDefinition;
                        } catch (e) {
                            console.warn('Invalid step definition:', stepDefinitionFile.ast);
                            return null;
                        }
                    }
                }]);

                return StepDefinitionParserService;
            })();

            _export('default', angular.module('tractor.stepDefinitionParserService', [StepParserService.name, StepDefinitionModel.name]).service('stepDefinitionParserService', StepDefinitionParserService));
        }
    };
});
System.register('app/features/StepDefinitionEditor/Services/StepDefinitionFileService.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/FileService.js', 'app/Core/Services/FileStructureService.js', 'app/features/StepDefinitionEditor/Services/StepDefinitionParserService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, angular, FileService, FileStructureService, StepDefinitionParserService, StepDefinitionFileService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesFileServiceJs) {
            FileService = _appCoreServicesFileServiceJs['default'];
        }, function (_appCoreServicesFileStructureServiceJs) {
            FileStructureService = _appCoreServicesFileStructureServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesStepDefinitionParserServiceJs) {
            StepDefinitionParserService = _appFeaturesStepDefinitionEditorServicesStepDefinitionParserServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            StepDefinitionFileService = (function (_FileService) {
                _inherits(StepDefinitionFileService, _FileService);

                function StepDefinitionFileService($http, fileStructureService, stepDefinitionParserService) {
                    _classCallCheck(this, StepDefinitionFileService);

                    _get(Object.getPrototypeOf(StepDefinitionFileService.prototype), 'constructor', this).call(this, $http, stepDefinitionParserService, fileStructureService, 'step-definitions');
                }

                return StepDefinitionFileService;
            })(FileService);

            _export('default', angular.module('tractor.stepDefinitionFileService', [FileStructureService.name, StepDefinitionParserService.name]).service('stepDefinitionFileService', StepDefinitionFileService));
        }
    };
});
System.register('app/features/StepDefinitionEditor/StepDefinitionEditorController.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ConfirmDialogService.js', 'app/features/FileEditor/FileEditorController.js', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Services/PersistentStateService.js', 'app/features/StepDefinitionEditor/Services/StepDefinitionFileService.js'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, angular, ConfirmDialogService, FileEditorController, NotifierService, PersistentStateService, StepDefinitionFileService, StepDefinitionEditorController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesConfirmDialogServiceJs) {
            ConfirmDialogService = _appCoreServicesConfirmDialogServiceJs['default'];
        }, function (_appFeaturesFileEditorFileEditorControllerJs) {
            FileEditorController = _appFeaturesFileEditorFileEditorControllerJs['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesStepDefinitionFileServiceJs) {
            StepDefinitionFileService = _appFeaturesStepDefinitionEditorServicesStepDefinitionFileServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            StepDefinitionEditorController = (function (_FileEditorController) {
                _inherits(StepDefinitionEditorController, _FileEditorController);

                function StepDefinitionEditorController($state, confirmDialogService, persistentStateService, notifierService, stepDefinitionFileService, stepDefinitionFileStructure, stepDefinitionPath) {
                    _classCallCheck(this, StepDefinitionEditorController);

                    _get(Object.getPrototypeOf(StepDefinitionEditorController.prototype), 'constructor', this).call(this, $state, confirmDialogService, persistentStateService, notifierService, stepDefinitionFileService, null, stepDefinitionFileStructure, stepDefinitionPath);
                }

                _createClass(StepDefinitionEditorController, [{
                    key: 'canAddComponents',
                    get: function get() {
                        return this.availableComponents.length > 0 && this.fileModel.step.type !== 'Given';
                    }
                }, {
                    key: 'canAddMockData',
                    get: function get() {
                        return this.availableMockData.length > 0 && this.fileModel.step.type === 'Given';
                    }
                }, {
                    key: 'hasComponents',
                    get: function get() {
                        return this.fileModel && this.fileModel.componentInstances && this.fileModel.componentInstances.length > 0;
                    }
                }, {
                    key: 'hasMockData',
                    get: function get() {
                        return this.fileModel && this.fileModel.mockDataInstances && this.fileModel.mockDataInstances.length > 0;
                    }
                }, {
                    key: 'showTasksSection',
                    get: function get() {
                        return this.hasComponents && this.fileModel.step.type === 'When';
                    }
                }, {
                    key: 'showExpectationsSection',
                    get: function get() {
                        return this.hasComponents && this.fileModel.step.type === 'Then';
                    }
                }, {
                    key: 'showMockDataSection',
                    get: function get() {
                        return this.fileModel.step.type === 'Given';
                    }
                }]);

                return StepDefinitionEditorController;
            })(FileEditorController);

            _export('default', angular.module('stepDefinitionEditorController', [ConfirmDialogService.name, NotifierService.name, PersistentStateService.name, StepDefinitionFileService.name]).controller('StepDefinitionEditorController', StepDefinitionEditorController));
        }
    };
});
System.registerDynamic("app/features/MockDataEditor/MockDataEditor.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div ng-if=\"mockDataEditor.fileModel\">\n    <tractor-file-tree model=\"mockDataEditor\" type=\"mock-data\"></tractor-file-tree>\n    <tractor-panel-handle panel-name=\"mock-data-file-tree\"></tractor-panel-handle>\n    <form class=\"file\" name=\"mockDataEditor.fileEditor\" novalidate\n        ng-submit=\"mockDataEditor.showErrors() && mockDataEditor.saveFile()\">\n        <section class=\"file-options\">\n            <h1 class=\"file-options__name\">{{ mockDataEditor.fileModel.name }}</h1>\n            <div>\n                <tractor-text-input class=\"file-options__name-input\"\n                    ng-if=\"!mockDataEditor.fileModel.isSaved\"\n                    form=\"mockDataEditor.fileEditor\"\n                    label=\"Name\"\n                    model=\"mockDataEditor.fileModel\"\n                    example=\"Data\"\n                    validate-file-name>\n                </tractor-text-input>\n            </div>\n            <div class=\"file-options__file-actions\">\n                <tractor-confirm-dialog trigger=\"mockDataEditor.confirmOverWrite\">\n                    <p>This will overwrite \"{{ mockDataEditor.fileModel.name }}\". Continue?</p>\n                </tractor-confirm-dialog>\n                <tractor-submit class=\"file-options__save-file\"\n                    action=\"Save mock data file\">\n                </tractor-submit>\n                <tractor-action class=\"file-options__save-file\"\n                    model=\"mockDataEditor\"\n                    action=\"New file\">\n                </tractor-action>\n            </div>\n        </section>\n\n        <section class=\"file-editor\">\n            <section class=\"file-editor__container\">\n                <h2>JSON data:</h2>\n                <textarea\n                    ng-model=\"mockDataEditor.fileModel.json\"\n                    required>\n                </textarea>\n            </section>\n        </section>\n    </form>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('app/features/MockDataEditor/Services/MockDataFileService.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/FileService.js', 'app/Core/Services/FileStructureService.js', 'app/features/MockDataEditor/Services/MockDataParserService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, angular, FileService, FileStructureService, MockDataParserService, MockDataFileService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesFileServiceJs) {
            FileService = _appCoreServicesFileServiceJs['default'];
        }, function (_appCoreServicesFileStructureServiceJs) {
            FileStructureService = _appCoreServicesFileStructureServiceJs['default'];
        }, function (_appFeaturesMockDataEditorServicesMockDataParserServiceJs) {
            MockDataParserService = _appFeaturesMockDataEditorServicesMockDataParserServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            MockDataFileService = (function (_FileService) {
                _inherits(MockDataFileService, _FileService);

                function MockDataFileService($http, fileStructureService, mockDataParserService) {
                    _classCallCheck(this, MockDataFileService);

                    _get(Object.getPrototypeOf(MockDataFileService.prototype), 'constructor', this).call(this, $http, mockDataParserService, fileStructureService, 'mock-data');
                }

                return MockDataFileService;
            })(FileService);

            _export('default', angular.module('tractor.mockDataFileService', [FileStructureService.name, MockDataParserService.name]).service('mockDataFileService', MockDataFileService));
        }
    };
});
System.register('app/features/MockDataEditor/MockDataEditorController.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ConfirmDialogService.js', 'app/features/FileEditor/FileEditorController.js', 'app/features/MockDataEditor/Services/MockDataFileService.js', 'app/features/MockDataEditor/Models/MockDataModel.js', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Services/PersistentStateService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, angular, ConfirmDialogService, FileEditorController, MockDataFileService, MockDataModel, NotifierService, PersistentStateService, MockDataEditorController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesConfirmDialogServiceJs) {
            ConfirmDialogService = _appCoreServicesConfirmDialogServiceJs['default'];
        }, function (_appFeaturesFileEditorFileEditorControllerJs) {
            FileEditorController = _appFeaturesFileEditorFileEditorControllerJs['default'];
        }, function (_appFeaturesMockDataEditorServicesMockDataFileServiceJs) {
            MockDataFileService = _appFeaturesMockDataEditorServicesMockDataFileServiceJs['default'];
        }, function (_appFeaturesMockDataEditorModelsMockDataModelJs) {
            MockDataModel = _appFeaturesMockDataEditorModelsMockDataModelJs['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            MockDataEditorController = (function (_FileEditorController) {
                _inherits(MockDataEditorController, _FileEditorController);

                function MockDataEditorController($state, confirmDialogService, persistentStateService, notifierService, mockDataFileService, MockDataModel, mockDataFileStructure, mockDataPath) {
                    _classCallCheck(this, MockDataEditorController);

                    _get(Object.getPrototypeOf(MockDataEditorController.prototype), 'constructor', this).call(this, $state, confirmDialogService, persistentStateService, notifierService, mockDataFileService, MockDataModel, mockDataFileStructure, mockDataPath);
                }

                return MockDataEditorController;
            })(FileEditorController);

            _export('default', angular.module('mockDataEditorController', [ConfirmDialogService.name, MockDataFileService.name, MockDataModel.name, NotifierService.name, PersistentStateService.name]).controller('MockDataEditorController', MockDataEditorController));
        }
    };
});
System.registerDynamic("app/features/FeatureEditor/FeatureEditor.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div ng-if=\"featureEditor.fileModel\">\n    <tractor-file-tree model=\"featureEditor\" type=\"features\"></tractor-file-tree>\n    <tractor-panel-handle panel-name=\"feature-file-tree\"></tractor-panel-handle>\n    <form class=\"file\" name=\"featureEditor.fileEditor\" novalidate\n        ng-submit=\"featureEditor.showErrors() && featureEditor.saveFile()\">\n        <section class=\"file-options\">\n            <h1 class=\"file-options__name\">{{ featureEditor.fileModel.name }}</h1>\n            <div>\n                <tractor-text-input class=\"file-options__name-input\"\n                    ng-if=\"!featureEditor.fileModel.isSaved\"\n                    form=\"featureEditor.fileEditor\"\n                    label=\"Name\"\n                    model=\"featureEditor.fileModel\"\n                    example=\"Feature\"\n                    validate-file-name>\n                </tractor-text-input>\n            </div>\n            <div class=\"file-options__file-actions\">\n                <tractor-confirm-dialog trigger=\"featureEditor.confirmOverWrite\">\n                    <p>This will overwrite \"{{ featureEditor.fileModel.name }}\". Continue?</p>\n                </tractor-confirm-dialog>\n                <tractor-submit class=\"file-options__save-file\"\n                    action=\"Save feature file\">\n                </tractor-submit>\n                <tractor-action class=\"file-options__save-file\"\n                    model=\"featureEditor\"\n                    action=\"New file\">\n                </tractor-action>\n            </div>\n        </section>\n\n        <section class=\"file-editor\">\n            <section ng-show=\"featureEditor.fileModel.name\">\n                <section class=\"file-editor__container\">\n                    <h2>Feature:</h2>\n\n                    <tractor-text-input\n                        form=\"featureEditor.fileEditor\"\n                        label=\"In order to\"\n                        model=\"featureEditor.fileModel\"\n                        example=\"achieve some goal\">\n                    </tractor-text-input>\n                    <tractor-text-input\n                        form=\"featureEditor.fileEditor\"\n                        label=\"As a\"\n                        model=\"featureEditor.fileModel\"\n                        example=\"certain type of user\">\n                    </tractor-text-input>\n                    <tractor-text-input\n                        form=\"featureEditor.fileEditor\"\n                        label=\"I want\"\n                        model=\"featureEditor.fileModel\"\n                        example=\"to be able to do something\">\n                    </tractor-text-input>\n                </section>\n\n                <section class=\"file-editor__container\">\n                    <h2>Scenarios:</h2>\n\n                    <ul ng-if=\"featureEditor.fileModel.scenarios.length\">\n                        <li class=\"file-editor__list-item\"\n                            ng-repeat=\"scenario in featureEditor.fileModel.scenarios\"\n                            ng-class=\"{ 'file-editor__list-item--minimised': scenario.minimised }\"\n                            ng-dblclick=\"featureEditor.minimise(scenario)\">\n\n                            <h3 class=\"file-editor__list-item-name\">{{ scenario.name }}</h3>\n\n                            <tractor-action\n                                model=\"featureEditor.fileModel\"\n                                action=\"Remove scenario\"\n                                argument=\"scenario\"\n                                icon=\"remove\"></tractor-action>\n\n                            <tractor-text-input\n                                form=\"featureEditor.fileEditor\"\n                                label=\"Name\"\n                                model=\"scenario\"\n                                example=\"Scenario\">\n                            </tractor-text-input>\n\n                            <section>\n                                <h3>Step Declarations:</h3>\n\n                                <ol ng-if=\"scenario.stepDeclarations.length\" as-sortable ng-model=\"scenario.stepDeclarations\" is-disabled=\"scenario.stepDeclarations.length < 2\">\n                                    <li class=\"file-editor__list-item\" ng-repeat=\"stepDeclaration in scenario.stepDeclarations\" as-sortable-item>\n                                        <tractor-action\n                                            model=\"scenario\"\n                                            action=\"Remove step declaration\"\n                                            argument=\"stepDeclaration\"\n                                            icon=\"remove\">\n                                        </tractor-action>\n                                        <div ng-if=\"scenario.stepDeclarations.length > 1\" class=\"file-editor__list-item-sort-handle\" as-sortable-item-handle title=\"Drag to sort\"></div>\n\n                                        <tractor-select label=\"Type\" model=\"stepDeclaration\"></tractor-select>\n                                        <tractor-step-input\n                                            form=\"featureEditor.fileEditor\"\n                                            label=\"Step\"\n                                            model=\"stepDeclaration\"\n                                            example=\"something happens\">\n                                        </tractor-step-input>\n                                    </li>\n                                </ol>\n\n                                <tractor-action\n                                    model=\"scenario\"\n                                    action=\"Add step declaration\">\n                                </tractor-action>\n                            </section>\n\n                            <section ng-show=\"scenario.exampleVariables.length\">\n                                <h3>Examples:</h3>\n                                <ul>\n                                    <li class=\"file-editor__list-item\" ng-repeat=\"example in scenario.examples\">\n                                        <tractor-action\n                                            model=\"scenario\"\n                                            action=\"Remove example\"\n                                            argument=\"example\"\n                                            icon=\"remove\">\n                                        </tractor-action>\n\n                                        <tractor-literal-input ng-repeat=\"exampleVariable in scenario.exampleVariables\"\n                                            form=\"featureEditor.fileEditor\"\n                                            name=\"exampleVariable\"\n                                            model=\"example.values[exampleVariable]\"\n                                            type=\"argument.type\">\n                                        </tractor-literal-input>\n                                    </li>\n                                </ul>\n\n                                <tractor-action\n                                    model=\"scenario\"\n                                    action=\"Add example\">\n                                </tractor-action>\n                            </section>\n                        </li>\n                    </ul>\n\n                    <tractor-action\n                        model=\"featureEditor.fileModel\"\n                        action=\"Add scenario\">\n                    </tractor-action>\n                </section>\n            </section>\n        </section>\n    </form>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.register('app/features/FeatureEditor/Services/StepDeclarationParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Models/StepDeclarationModel.js'], function (_export) {
    var _createClass, _classCallCheck, assert, angular, StepDeclarationModel, StepDeclarationParserService;

    function parseStepDeclaration(stepDeclaration, tokens) {
        stepDeclaration.type = tokens.type;
        assert(stepDeclaration.type);
        stepDeclaration.step = tokens.step;
        assert(stepDeclaration.step);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorModelsStepDeclarationModelJs) {
            StepDeclarationModel = _appFeaturesFeatureEditorModelsStepDeclarationModelJs['default'];
        }],
        execute: function () {

            // Dependencies
            'use strict';

            // Utilities:
            StepDeclarationParserService = (function () {
                function StepDeclarationParserService(StepDeclarationModel) {
                    _classCallCheck(this, StepDeclarationParserService);

                    this.StepDeclarationModel = StepDeclarationModel;
                }

                _createClass(StepDeclarationParserService, [{
                    key: 'parse',
                    value: function parse(tokens) {
                        try {
                            var stepDeclaration = new this.StepDeclarationModel();

                            parseStepDeclaration(stepDeclaration, tokens);

                            return stepDeclaration;
                        } catch (e) {
                            console.warn('Invaid step declarartion:', tokens);
                            return null;
                        }
                    }
                }]);

                return StepDeclarationParserService;
            })();

            _export('default', angular.module('tractor.stepDeclarationParserService', [StepDeclarationModel.name]).service('stepDeclarationParserService', StepDeclarationParserService));
        }
    };
});
System.register('app/features/FeatureEditor/Services/ExampleParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Models/ExampleModel.js'], function (_export) {
    var _createClass, _classCallCheck, angular, ExampleModel, ExampleParserService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorModelsExampleModelJs) {
            ExampleModel = _appFeaturesFeatureEditorModelsExampleModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            ExampleParserService = (function () {
                function ExampleParserService(ExampleModel) {
                    _classCallCheck(this, ExampleParserService);

                    this.ExampleModel = ExampleModel;
                }

                _createClass(ExampleParserService, [{
                    key: 'parse',
                    value: function parse(scenario, tokens) {
                        var _this = this;

                        try {
                            var _ret = (function () {
                                var example = new _this.ExampleModel(scenario);

                                scenario.exampleVariables.forEach(function (variable, index) {
                                    example.values[variable] = tokens[index].replace(/^"/, '').replace(/"$/, '');
                                });

                                return {
                                    v: example
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        } catch (e) {
                            console.warn('Invalid example:', tokens);
                            return null;
                        }
                    }
                }]);

                return ExampleParserService;
            })();

            _export('default', angular.module('tractor.exampleParserService', [ExampleModel.name]).service('exampleParserService', ExampleParserService));
        }
    };
});
System.register('app/features/FeatureEditor/Services/ScenarioParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Services/ExampleParserService.js', 'app/features/FeatureEditor/Models/ScenarioModel.js', 'app/features/FeatureEditor/Services/StepDeclarationParserService.js'], function (_export) {
    var _createClass, _classCallCheck, assert, angular, ExampleParserService, ScenarioModel, StepDeclarationParserService, ScenarioParserService;

    function parseScenario(scenario, tokens) {
        scenario.name = tokens.name;
        assert(scenario.name);
    }

    function tryParse(scenario, tokens, parsers) {
        var _this = this;

        var parsed = parsers.every(function (parser) {
            try {
                return parser.call(_this, scenario, tokens);
            } catch (e) {}
        });
        if (!parsed) {
            throw new Error();
        }
    }

    function parseStepDeclarations(scenario, tokens) {
        var _this2 = this;

        tokens.stepDeclarations.forEach(function (stepDeclaration) {
            var parsedStepDeclaration = _this2.stepDeclarationParserService.parse(stepDeclaration);
            assert(parsedStepDeclaration);
            scenario.stepDeclarations.push(parsedStepDeclaration);
        });
        return true;
    }

    function parseExamples(scenario, tokens) {
        var _this3 = this;

        tokens.examples.forEach(function (example) {
            var parsedExample = _this3.exampleParserService.parse(scenario, example);
            assert(parsedExample);
            scenario.examples.push(parsedExample);
        });
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorServicesExampleParserServiceJs) {
            ExampleParserService = _appFeaturesFeatureEditorServicesExampleParserServiceJs['default'];
        }, function (_appFeaturesFeatureEditorModelsScenarioModelJs) {
            ScenarioModel = _appFeaturesFeatureEditorModelsScenarioModelJs['default'];
        }, function (_appFeaturesFeatureEditorServicesStepDeclarationParserServiceJs) {
            StepDeclarationParserService = _appFeaturesFeatureEditorServicesStepDeclarationParserServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            ScenarioParserService = (function () {
                function ScenarioParserService(exampleParserService, ScenarioModel, stepDeclarationParserService) {
                    _classCallCheck(this, ScenarioParserService);

                    this.exampleParserService = exampleParserService;
                    this.ScenarioModel = ScenarioModel;
                    this.stepDeclarationParserService = stepDeclarationParserService;
                }

                _createClass(ScenarioParserService, [{
                    key: 'parse',
                    value: function parse(tokens) {
                        try {
                            var scenario = new this.ScenarioModel();

                            parseScenario.call(this, scenario, tokens);

                            var parsers = [parseStepDeclarations, parseExamples];
                            tryParse.call(this, scenario, tokens, parsers);

                            return scenario;
                        } catch (e) {
                            console.warn('Invalid scenario:', tokens);
                            return null;
                        }
                    }
                }]);

                return ScenarioParserService;
            })();

            _export('default', angular.module('tractor.scenarioParserService', [ExampleParserService.name, ScenarioModel.name, StepDeclarationParserService.name]).service('scenarioParserService', ScenarioParserService));
        }
    };
});
System.register('app/features/FeatureEditor/Models/ExampleModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/StringToLiteralService.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, StringToLiteralService, scenario, values;

    function createExampleModelConstructor(stringToLiteralService, FeatureIndent) {
        return (function () {
            function ExampleModel(_scenario) {
                _classCallCheck(this, ExampleModel);

                this[scenario] = _scenario;
                this[values] = {};
            }

            _createClass(ExampleModel, [{
                key: 'scenario',
                get: function get() {
                    return this[scenario];
                }
            }, {
                key: 'values',
                get: function get() {
                    var _this = this;

                    this.scenario.exampleVariables.forEach(function (exampleVariable) {
                        _this[values][exampleVariable] = _this[values][exampleVariable] || {
                            value: ''
                        };
                    });
                    return this[values];
                }
            }, {
                key: 'feature',
                get: function get() {
                    return toFeature.call(this);
                }
            }]);

            return ExampleModel;
        })();

        function toFeature() {
            var _this2 = this;

            var values = this.scenario.exampleVariables.map(function (variable) {
                var value = _this2.values[variable].value;
                var literal = stringToLiteralService.toLiteral(value);
                return angular.isUndefined(literal) ? '"' + value + '"' : literal;
            }).join(' | ');
            return '' + FeatureIndent + FeatureIndent + FeatureIndent + '| ' + values + ' |';
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesStringToLiteralServiceJs) {
            StringToLiteralService = _appCoreServicesStringToLiteralServiceJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Dependencies:
            'use strict';scenario = _Symbol();
            values = _Symbol();

            _export('default', angular.module('tractor.exampleModel', [StringToLiteralService.name]).factory('ExampleModel', createExampleModelConstructor));
        }
    };
});
System.registerDynamic("npm:lodash._createcache@3.1.2/index", ["npm:lodash._getnative@3.9.1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getNative = $__require('npm:lodash._getnative@3.9.1');
  var Set = getNative(global, 'Set');
  var nativeCreate = getNative(Object, 'create');
  function SetCache(values) {
    var length = values ? values.length : 0;
    this.data = {
      'hash': nativeCreate(null),
      'set': new Set
    };
    while (length--) {
      this.push(values[length]);
    }
  }
  function cachePush(value) {
    var data = this.data;
    if (typeof value == 'string' || isObject(value)) {
      data.set.add(value);
    } else {
      data.hash[value] = true;
    }
  }
  function createCache(values) {
    return (nativeCreate && Set) ? new SetCache(values) : null;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  SetCache.prototype.push = cachePush;
  module.exports = createCache;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._createcache@3.1.2", ["npm:lodash._createcache@3.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._createcache@3.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._cacheindexof@3.0.2/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function cacheIndexOf(cache, value) {
    var data = cache.data,
        result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
    return result ? 0 : -1;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  module.exports = cacheIndexOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._cacheindexof@3.0.2", ["npm:lodash._cacheindexof@3.0.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._cacheindexof@3.0.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseindexof@3.1.0/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);
    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }
  module.exports = baseIndexOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseindexof@3.1.0", ["npm:lodash._baseindexof@3.1.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._baseindexof@3.1.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseuniq@3.0.3/index", ["npm:lodash._baseindexof@3.1.0", "npm:lodash._cacheindexof@3.0.2", "npm:lodash._createcache@3.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseIndexOf = $__require('npm:lodash._baseindexof@3.1.0'),
      cacheIndexOf = $__require('npm:lodash._cacheindexof@3.0.2'),
      createCache = $__require('npm:lodash._createcache@3.1.2');
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee) {
    var index = -1,
        indexOf = baseIndexOf,
        length = array.length,
        isCommon = true,
        isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
        seen = isLarge ? createCache() : null,
        result = [];
    if (seen) {
      indexOf = cacheIndexOf;
      isCommon = false;
    } else {
      isLarge = false;
      seen = iteratee ? [] : result;
    }
    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;
      if (isCommon && value === value) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (indexOf(seen, computed, 0) < 0) {
        if (iteratee || isLarge) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }
  module.exports = baseUniq;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseuniq@3.0.3", ["npm:lodash._baseuniq@3.0.3/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._baseuniq@3.0.3/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.uniq@3.2.2/index", ["npm:lodash._basecallback@3.3.1", "npm:lodash._baseuniq@3.0.3", "npm:lodash._isiterateecall@3.0.9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseCallback = $__require('npm:lodash._basecallback@3.3.1'),
      baseUniq = $__require('npm:lodash._baseuniq@3.0.3'),
      isIterateeCall = $__require('npm:lodash._isiterateecall@3.0.9');
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];
    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;
      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }
  function uniq(array, isSorted, iteratee, thisArg) {
    var length = array ? array.length : 0;
    if (!length) {
      return [];
    }
    if (isSorted != null && typeof isSorted != 'boolean') {
      thisArg = iteratee;
      iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
      isSorted = false;
    }
    iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
    return (isSorted) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
  }
  module.exports = uniq;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.uniq@3.2.2", ["npm:lodash.uniq@3.2.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.uniq@3.2.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseeach@3.0.4/index", ["npm:lodash.keys@3.1.2", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var keys = $__require('npm:lodash.keys@3.1.2');
    var MAX_SAFE_INTEGER = 9007199254740991;
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);
        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var getLength = baseProperty('length');
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    module.exports = baseEach;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseeach@3.0.4", ["npm:lodash._baseeach@3.0.4/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._baseeach@3.0.4/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.pairs@3.0.1/index", ["npm:lodash.keys@3.1.2", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var keys = $__require('npm:lodash.keys@3.1.2');
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function pairs(object) {
      object = toObject(object);
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);
      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }
    module.exports = pairs;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.pairs@3.0.1", ["npm:lodash.pairs@3.0.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.pairs@3.0.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._bindcallback@3.0.1/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function bindCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    if (thisArg === undefined) {
      return func;
    }
    switch (argCount) {
      case 1:
        return function(value) {
          return func.call(thisArg, value);
        };
      case 3:
        return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
      case 4:
        return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      case 5:
        return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
    }
    return function() {
      return func.apply(thisArg, arguments);
    };
  }
  function identity(value) {
    return value;
  }
  module.exports = bindCallback;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._bindcallback@3.0.1", ["npm:lodash._bindcallback@3.0.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._bindcallback@3.0.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._getnative@3.9.1/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var funcTag = '[object Function]';
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  var objectProto = Object.prototype;
  var fnToString = Function.prototype.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objToString = objectProto.toString;
  var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  function getNative(object, key) {
    var value = object == null ? undefined : object[key];
    return isNative(value) ? value : undefined;
  }
  function isFunction(value) {
    return isObject(value) && objToString.call(value) == funcTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (isFunction(value)) {
      return reIsNative.test(fnToString.call(value));
    }
    return isObjectLike(value) && reIsHostCtor.test(value);
  }
  module.exports = getNative;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._getnative@3.9.1", ["npm:lodash._getnative@3.9.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._getnative@3.9.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.keys@3.1.2/index", ["npm:lodash._getnative@3.9.1", "npm:lodash.isarguments@3.0.4", "npm:lodash.isarray@3.0.4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getNative = $__require('npm:lodash._getnative@3.9.1'),
      isArguments = $__require('npm:lodash.isarguments@3.0.4'),
      isArray = $__require('npm:lodash.isarray@3.0.4');
  var reIsUint = /^\d+$/;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeKeys = getNative(Object, 'keys');
  var MAX_SAFE_INTEGER = 9007199254740991;
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  var getLength = baseProperty('length');
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  function isIndex(value, length) {
    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return value > -1 && value % 1 == 0 && value < length;
  }
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function shimKeys(object) {
    var props = keysIn(object),
        propsLength = props.length,
        length = propsLength && object.length;
    var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
    var index = -1,
        result = [];
    while (++index < propsLength) {
      var key = props[index];
      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
        result.push(key);
      }
    }
    return result;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  var keys = !nativeKeys ? shimKeys : function(object) {
    var Ctor = object == null ? undefined : object.constructor;
    if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
      return shimKeys(object);
    }
    return isObject(object) ? nativeKeys(object) : [];
  };
  function keysIn(object) {
    if (object == null) {
      return [];
    }
    if (!isObject(object)) {
      object = Object(object);
    }
    var length = object.length;
    length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
    var Ctor = object.constructor,
        index = -1,
        isProto = typeof Ctor == 'function' && Ctor.prototype === object,
        result = Array(length),
        skipIndexes = length > 0;
    while (++index < length) {
      result[index] = (index + '');
    }
    for (var key in object) {
      if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = keys;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.keys@3.1.2", ["npm:lodash.keys@3.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.keys@3.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.istypedarray@3.0.2/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  var objectProto = Object.prototype;
  var objToString = objectProto.toString;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
  }
  module.exports = isTypedArray;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.istypedarray@3.0.2", ["npm:lodash.istypedarray@3.0.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.istypedarray@3.0.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseisequal@3.0.7/index", ["npm:lodash.isarray@3.0.4", "npm:lodash.istypedarray@3.0.2", "npm:lodash.keys@3.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArray = $__require('npm:lodash.isarray@3.0.4'),
      isTypedArray = $__require('npm:lodash.istypedarray@3.0.2'),
      keys = $__require('npm:lodash.keys@3.1.2');
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      stringTag = '[object String]';
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objToString = objectProto.toString;
  function arraySome(array, predicate) {
    var index = -1,
        length = array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
  }
  function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;
    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag == argsTag) {
        objTag = objectTag;
      } else if (objTag != objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag == argsTag) {
        othTag = objectTag;
      } else if (othTag != objectTag) {
        othIsArr = isTypedArray(other);
      }
    }
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;
    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    if (!isLoose) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
      if (objIsWrapped || othIsWrapped) {
        return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stackA || (stackA = []);
    stackB || (stackB = []);
    var length = stackA.length;
    while (length--) {
      if (stackA[length] == object) {
        return stackB[length] == other;
      }
    }
    stackA.push(object);
    stackB.push(other);
    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
    stackA.pop();
    stackB.pop();
    return result;
  }
  function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length;
    if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
      return false;
    }
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index],
          result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
      if (result !== undefined) {
        if (result) {
          continue;
        }
        return false;
      }
      if (isLoose) {
        if (!arraySome(other, function(othValue) {
          return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
        })) {
          return false;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
        return false;
      }
    }
    return true;
  }
  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        return +object == +other;
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case numberTag:
        return (object != +object) ? other != +other : object == +other;
      case regexpTag:
      case stringTag:
        return object == (other + '');
    }
    return false;
  }
  function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;
    if (objLength != othLength && !isLoose) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var skipCtor = isLoose;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key],
          result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
      if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
        return false;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (!skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;
      if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  module.exports = baseIsEqual;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseisequal@3.0.7", ["npm:lodash._baseisequal@3.0.7/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._baseisequal@3.0.7/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._basecallback@3.3.1/index", ["npm:lodash._baseisequal@3.0.7", "npm:lodash._bindcallback@3.0.1", "npm:lodash.isarray@3.0.4", "npm:lodash.pairs@3.0.1", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var baseIsEqual = $__require('npm:lodash._baseisequal@3.0.7'),
        bindCallback = $__require('npm:lodash._bindcallback@3.0.1'),
        isArray = $__require('npm:lodash.isarray@3.0.4'),
        pairs = $__require('npm:lodash.pairs@3.0.1');
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    var reEscapeChar = /\\(\\)?/g;
    function baseToString(value) {
      return value == null ? '' : (value + '');
    }
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
    }
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;
      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;
      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;
      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }
    module.exports = baseCallback;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._basecallback@3.3.1", ["npm:lodash._basecallback@3.3.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._basecallback@3.3.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._arraymap@3.0.0/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array.length,
        result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  module.exports = arrayMap;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._arraymap@3.0.0", ["npm:lodash._arraymap@3.0.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._arraymap@3.0.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.map@3.1.4/index", ["npm:lodash._arraymap@3.0.0", "npm:lodash._basecallback@3.3.1", "npm:lodash._baseeach@3.0.4", "npm:lodash.isarray@3.0.4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var arrayMap = $__require('npm:lodash._arraymap@3.0.0'),
      baseCallback = $__require('npm:lodash._basecallback@3.3.1'),
      baseEach = $__require('npm:lodash._baseeach@3.0.4'),
      isArray = $__require('npm:lodash.isarray@3.0.4');
  var MAX_SAFE_INTEGER = 9007199254740991;
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  var getLength = baseProperty('length');
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function map(collection, iteratee, thisArg) {
    var func = isArray(collection) ? arrayMap : baseMap;
    iteratee = baseCallback(iteratee, thisArg, 3);
    return func(collection, iteratee);
  }
  module.exports = map;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.map@3.1.4", ["npm:lodash.map@3.1.4/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.map@3.1.4/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._topath@3.8.1/index", ["npm:lodash.isarray@3.0.4", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var isArray = $__require('npm:lodash.isarray@3.0.4');
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    var reEscapeChar = /\\(\\)?/g;
    function baseToString(value) {
      return value == null ? '' : (value + '');
    }
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }
    module.exports = toPath;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._topath@3.8.1", ["npm:lodash._topath@3.8.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._topath@3.8.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseget@3.7.2/index", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;
      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    module.exports = baseGet;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseget@3.7.2", ["npm:lodash._baseget@3.7.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._baseget@3.7.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.pluck@3.1.2/index", ["npm:lodash._baseget@3.7.2", "npm:lodash._topath@3.8.1", "npm:lodash.isarray@3.0.4", "npm:lodash.map@3.1.4", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var baseGet = $__require('npm:lodash._baseget@3.7.2'),
        toPath = $__require('npm:lodash._topath@3.8.1'),
        isArray = $__require('npm:lodash.isarray@3.0.4'),
        map = $__require('npm:lodash.map@3.1.4');
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }
    function pluck(collection, path) {
      return map(collection, property(path));
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }
    module.exports = pluck;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.pluck@3.1.2", ["npm:lodash.pluck@3.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.pluck@3.1.2/index');
  global.define = __define;
  return module.exports;
});

System.register('app/features/FeatureEditor/Models/ScenarioModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:lodash.flatten@3.0.2', 'npm:lodash.pluck@3.1.2', 'npm:lodash.uniq@3.2.2', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Models/ExampleModel.js', 'app/features/FeatureEditor/Models/StepDeclarationModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, flatten, pluck, unique, angular, ExampleModel, StepDeclarationModel, stepDeclarations, examples;

    function createScenarioModelConstructor(ExampleModel, FeatureIndent, FeatureNewLine, StepDeclarationModel) {
        var ScenarioModel = (function () {
            function ScenarioModel() {
                _classCallCheck(this, ScenarioModel);

                this[stepDeclarations] = [];
                this[examples] = [];

                this.name = '';
            }

            _createClass(ScenarioModel, [{
                key: 'addStepDeclaration',
                value: function addStepDeclaration() {
                    this.stepDeclarations.push(new StepDeclarationModel());
                }
            }, {
                key: 'removeStepDeclaration',
                value: function removeStepDeclaration(toRemove) {
                    this.stepDeclarations.splice(this.stepDeclarations.findIndex(function (stepDeclaration) {
                        return stepDeclaration === toRemove;
                    }), 1);
                }
            }, {
                key: 'addExample',
                value: function addExample() {
                    this.examples.push(new ExampleModel(this));
                }
            }, {
                key: 'removeExample',
                value: function removeExample(toRemove) {
                    this.examples.splice(this.examples.findIndex(function (example) {
                        return example === toRemove;
                    }), 1);
                }
            }, {
                key: 'stepDeclarations',
                get: function get() {
                    return this[stepDeclarations];
                }
            }, {
                key: 'examples',
                get: function get() {
                    return this[examples];
                }
            }, {
                key: 'exampleVariables',
                get: function get() {
                    return getExampleVariables.call(this, this.stepDeclarations);
                }
            }, {
                key: 'featureString',
                get: function get() {
                    return toFeatureString.call(this);
                }
            }]);

            return ScenarioModel;
        })();

        ScenarioModel.getExampleVariableNames = getExampleVariableNames;

        return ScenarioModel;

        function getExampleVariableNames(step) {
            var matches = step.match(new RegExp('<.+?>', 'g'));
            if (matches) {
                return matches.map(function (result) {
                    return result.replace(/^</, '').replace(/>$/, '');
                });
            } else {
                return [];
            }
        }

        function getExampleVariables(stepDeclarations) {
            return unique(flatten(pluck(stepDeclarations, 'step').map(getExampleVariableNames)));
        }

        function toFeatureString() {
            var scenario = 'Scenario' + (this.examples.length ? ' Outline' : '') + ': ' + this.name;

            var stepDeclarations = this.stepDeclarations.map(function (stepDeclaration) {
                return '' + FeatureIndent + FeatureIndent + stepDeclaration.feature;
            });

            var lines = [scenario, stepDeclarations];
            if (this.examples.length) {
                lines.push('' + FeatureIndent + FeatureIndent + 'Examples:');
                var variables = this.exampleVariables.join(' | ');
                lines.push('' + FeatureIndent + FeatureIndent + FeatureIndent + '| ' + variables + ' |');
                this.examples.forEach(function (example) {
                    return lines.push(example.feature);
                });
            }

            lines = flatten(lines);
            return lines.join(FeatureNewLine);
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmLodashFlatten302) {
            flatten = _npmLodashFlatten302['default'];
        }, function (_npmLodashPluck312) {
            pluck = _npmLodashPluck312['default'];
        }, function (_npmLodashUniq322) {
            unique = _npmLodashUniq322['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorModelsExampleModelJs) {
            ExampleModel = _appFeaturesFeatureEditorModelsExampleModelJs['default'];
        }, function (_appFeaturesFeatureEditorModelsStepDeclarationModelJs) {
            StepDeclarationModel = _appFeaturesFeatureEditorModelsStepDeclarationModelJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Utilities:
            'use strict';

            // Dependencies:
            stepDeclarations = _Symbol();
            examples = _Symbol();

            _export('default', angular.module('tractor.scenarioModel', [ExampleModel.name, StepDeclarationModel.name]).factory('ScenarioModel', createScenarioModelConstructor));
        }
    };
});
System.registerDynamic("npm:lodash._isiterateecall@3.0.9/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var reIsUint = /^\d+$/;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  var getLength = baseProperty('length');
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  function isIndex(value, length) {
    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return value > -1 && value % 1 == 0 && value < length;
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
      var other = object[index];
      return value === value ? (value === other) : (other !== other);
    }
    return false;
  }
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  module.exports = isIterateeCall;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._isiterateecall@3.0.9", ["npm:lodash._isiterateecall@3.0.9/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._isiterateecall@3.0.9/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isarray@3.0.4/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var arrayTag = '[object Array]',
      funcTag = '[object Function]';
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  var objectProto = Object.prototype;
  var fnToString = Function.prototype.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objToString = objectProto.toString;
  var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  var nativeIsArray = getNative(Array, 'isArray');
  var MAX_SAFE_INTEGER = 9007199254740991;
  function getNative(object, key) {
    var value = object == null ? undefined : object[key];
    return isNative(value) ? value : undefined;
  }
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var isArray = nativeIsArray || function(value) {
    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
  };
  function isFunction(value) {
    return isObject(value) && objToString.call(value) == funcTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (isFunction(value)) {
      return reIsNative.test(fnToString.call(value));
    }
    return isObjectLike(value) && reIsHostCtor.test(value);
  }
  module.exports = isArray;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isarray@3.0.4", ["npm:lodash.isarray@3.0.4/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.isarray@3.0.4/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isarguments@3.0.4/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  var getLength = baseProperty('length');
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isArguments(value) {
    return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  }
  module.exports = isArguments;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isarguments@3.0.4", ["npm:lodash.isarguments@3.0.4/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.isarguments@3.0.4/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseflatten@3.1.4/index", ["npm:lodash.isarguments@3.0.4", "npm:lodash.isarray@3.0.4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isArguments = $__require('npm:lodash.isarguments@3.0.4'),
      isArray = $__require('npm:lodash.isarray@3.0.4');
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFlatten(array, isDeep, isStrict, result) {
    result || (result = []);
    var index = -1,
        length = array.length;
    while (++index < length) {
      var value = array[index];
      if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
        if (isDeep) {
          baseFlatten(value, isDeep, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  var getLength = baseProperty('length');
  function isArrayLike(value) {
    return value != null && isLength(getLength(value));
  }
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  module.exports = baseFlatten;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash._baseflatten@3.1.4", ["npm:lodash._baseflatten@3.1.4/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash._baseflatten@3.1.4/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.flatten@3.0.2/index", ["npm:lodash._baseflatten@3.1.4", "npm:lodash._isiterateecall@3.0.9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var baseFlatten = $__require('npm:lodash._baseflatten@3.1.4'),
      isIterateeCall = $__require('npm:lodash._isiterateecall@3.0.9');
  function flatten(array, isDeep, guard) {
    var length = array ? array.length : 0;
    if (guard && isIterateeCall(array, isDeep, guard)) {
      isDeep = false;
    }
    return length ? baseFlatten(array, isDeep) : [];
  }
  module.exports = flatten;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.flatten@3.0.2", ["npm:lodash.flatten@3.0.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.flatten@3.0.2/index');
  global.define = __define;
  return module.exports;
});

System.register('app/features/FeatureEditor/Models/FeatureModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:lodash.flatten@3.0.2', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Models/ScenarioModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, flatten, angular, ScenarioModel, options, scenarios;

    function createFeatureModelConstructor(FeatureIndent, FeatureNewLine, ScenarioModel) {
        return (function () {
            function FeatureModel() {
                var _options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                _classCallCheck(this, FeatureModel);

                this[options] = _options;
                this[scenarios] = [];

                this.name = '';
                this.inOrderTo = '';
                this.asA = '';
                this.iWant = '';
            }

            _createClass(FeatureModel, [{
                key: 'addScenario',
                value: function addScenario() {
                    this.scenarios.push(new ScenarioModel());
                }
            }, {
                key: 'removeScenario',
                value: function removeScenario(toRemove) {
                    this.scenarios.splice(this.scenarios.findIndex(function (scenario) {
                        return scenario === toRemove;
                    }), 1);
                }
            }, {
                key: 'isSaved',
                get: function get() {
                    return !!this[options].isSaved;
                }
            }, {
                key: 'path',
                get: function get() {
                    return this[options].path;
                }
            }, {
                key: 'scenarios',
                get: function get() {
                    return this[scenarios];
                }
            }, {
                key: 'featureString',
                get: function get() {
                    return toFeatureString.call(this);
                }
            }, {
                key: 'data',
                get: function get() {
                    return this.featureString;
                }
            }]);

            return FeatureModel;
        })();

        function toFeatureString() {
            var feature = 'Feature: ' + this.name;

            var inOrderTo = FeatureIndent + 'In order to ' + this.inOrderTo;
            var asA = FeatureIndent + 'As a ' + this.asA;
            var iWant = FeatureIndent + 'I want ' + this.iWant;

            var scenarios = this.scenarios.map(function (scenario) {
                return '' + FeatureIndent + scenario.featureString;
            });

            var lines = flatten([feature, inOrderTo, asA, iWant, scenarios]);
            return lines.join(FeatureNewLine);
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmLodashFlatten302) {
            flatten = _npmLodashFlatten302['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorModelsScenarioModelJs) {
            ScenarioModel = _appFeaturesFeatureEditorModelsScenarioModelJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Dependencies:
            'use strict';

            // Utilities:
            options = _Symbol();
            scenarios = _Symbol();

            _export('default', angular.module('tractor.featureModel', [ScenarioModel.name]).factory('FeatureModel', createFeatureModelConstructor));
        }
    };
});
System.register('app/features/FeatureEditor/Services/FeatureParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Models/FeatureModel.js', 'app/features/FeatureEditor/Services/ScenarioParserService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, FeatureModel, ScenarioParserService, FeatureParserService;

    function parseFeature(feature, tokens) {
        feature.name = tokens.name;
        assert(feature.name);
        feature.inOrderTo = tokens.inOrderTo;
        assert(feature.inOrderTo);
        feature.asA = tokens.asA;
        assert(feature.asA);
        feature.iWant = tokens.iWant;
        assert(feature.iWant);
    }

    function tryParse(feature, tokens, parsers) {
        var _this = this;

        var parsed = parsers.some(function (parser) {
            try {
                return parser.call(_this, feature, tokens);
            } catch (e) {}
        });
        if (!parsed) {
            throw new Error();
        }
    }

    function parseScenarios(feature, tokens) {
        var _this2 = this;

        tokens.elements.forEach(function (element) {
            var parsedScenario = _this2.scenarioParserService.parse(element);
            assert(parsedScenario);
            feature.scenarios.push(parsedScenario);
        });
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorModelsFeatureModelJs) {
            FeatureModel = _appFeaturesFeatureEditorModelsFeatureModelJs['default'];
        }, function (_appFeaturesFeatureEditorServicesScenarioParserServiceJs) {
            ScenarioParserService = _appFeaturesFeatureEditorServicesScenarioParserServiceJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            FeatureParserService = (function () {
                function FeatureParserService(FeatureModel, scenarioParserService) {
                    _classCallCheck(this, FeatureParserService);

                    this.FeatureModel = FeatureModel;
                    this.scenarioParserService = scenarioParserService;
                }

                _createClass(FeatureParserService, [{
                    key: 'parse',
                    value: function parse(featureFile) {
                        var tokens = featureFile.tokens;

                        try {
                            var feature = new this.FeatureModel({
                                isSaved: true,
                                path: featureFile.path
                            });

                            var _tokens = _slicedToArray(tokens, 1);

                            var featureTokens = _tokens[0];

                            parseFeature(feature, featureTokens);

                            var parsers = [parseScenarios];
                            tryParse.call(this, feature, featureTokens, parsers);

                            return feature;
                        } catch (e) {
                            console.warn('Invalid feature:', tokens);
                            return null;
                        }
                    }
                }]);

                return FeatureParserService;
            })();

            _export('default', angular.module('tractor.featureParserService', [FeatureModel.name, ScenarioParserService.name]).service('featureParserService', FeatureParserService));
        }
    };
});
System.registerDynamic("npm:lodash.isfunction@2.4.1/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isFunction(value) {
    return typeof value == 'function';
  }
  module.exports = isFunction;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isfunction@2.4.1", ["npm:lodash.isfunction@2.4.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.isfunction@2.4.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.compose@2.4.1/index", ["npm:lodash.isfunction@2.4.1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isFunction = $__require('npm:lodash.isfunction@2.4.1');
  function compose() {
    var funcs = arguments,
        length = funcs.length;
    while (length--) {
      if (!isFunction(funcs[length])) {
        throw new TypeError;
      }
    }
    return function() {
      var args = arguments,
          length = funcs.length;
      while (length--) {
        args = [funcs[length].apply(this, args)];
      }
      return args[0];
    };
  }
  module.exports = compose;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.compose@2.4.1", ["npm:lodash.compose@2.4.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.compose@2.4.1/index');
  global.define = __define;
  return module.exports;
});

System.register('app/features/FeatureEditor/Services/FeatureFileService.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:lodash.compose@2.4.1', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Services/FeatureParserService.js', 'app/Core/Services/FileService.js', 'app/Core/Services/FileStructureService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, compose, angular, FeatureParserService, FileService, FileStructureService, FeatureFileService;

    function fixFeatureParameters(options) {
        options.data = options.data.replace(/"</g, '\'<').replace(/>"/g, '>\'');
        return options;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmLodashCompose241) {
            compose = _npmLodashCompose241['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorServicesFeatureParserServiceJs) {
            FeatureParserService = _appFeaturesFeatureEditorServicesFeatureParserServiceJs['default'];
        }, function (_appCoreServicesFileServiceJs) {
            FileService = _appCoreServicesFileServiceJs['default'];
        }, function (_appCoreServicesFileStructureServiceJs) {
            FileStructureService = _appCoreServicesFileStructureServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            FeatureFileService = (function (_FileService) {
                _inherits(FeatureFileService, _FileService);

                function FeatureFileService($http, featureParserService, fileStructureService) {
                    _classCallCheck(this, FeatureFileService);

                    _get(Object.getPrototypeOf(FeatureFileService.prototype), 'constructor', this).call(this, $http, featureParserService, fileStructureService, 'features');
                    this.saveFile = compose(this.saveFile, fixFeatureParameters);
                }

                return FeatureFileService;
            })(FileService);

            _export('default', angular.module('tractor.featureFileService', [FeatureParserService.name, FileStructureService.name]).service('featureFileService', FeatureFileService));
        }
    };
});
System.register('app/features/FeatureEditor/FeatureEditorController.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ConfirmDialogService.js', 'app/features/FeatureEditor/Services/FeatureFileService.js', 'app/features/FeatureEditor/Models/FeatureModel.js', 'app/features/FileEditor/FileEditorController.js', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Services/PersistentStateService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, angular, ConfirmDialogService, FeatureFileService, FeatureModel, FileEditorController, NotifierService, PersistentStateService, FeatureEditorController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesConfirmDialogServiceJs) {
            ConfirmDialogService = _appCoreServicesConfirmDialogServiceJs['default'];
        }, function (_appFeaturesFeatureEditorServicesFeatureFileServiceJs) {
            FeatureFileService = _appFeaturesFeatureEditorServicesFeatureFileServiceJs['default'];
        }, function (_appFeaturesFeatureEditorModelsFeatureModelJs) {
            FeatureModel = _appFeaturesFeatureEditorModelsFeatureModelJs['default'];
        }, function (_appFeaturesFileEditorFileEditorControllerJs) {
            FileEditorController = _appFeaturesFileEditorFileEditorControllerJs['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            FeatureEditorController = (function (_FileEditorController) {
                _inherits(FeatureEditorController, _FileEditorController);

                function FeatureEditorController($state, confirmDialogService, persistentStateService, notifierService, featureFileService, FeatureModel, featureFileStructure, featurePath) {
                    _classCallCheck(this, FeatureEditorController);

                    _get(Object.getPrototypeOf(FeatureEditorController.prototype), 'constructor', this).call(this, $state, confirmDialogService, persistentStateService, notifierService, featureFileService, FeatureModel, featureFileStructure, featurePath);
                }

                return FeatureEditorController;
            })(FileEditorController);

            _export('default', angular.module('featureEditorController', [ConfirmDialogService.name, FeatureFileService.name, FeatureModel.name, NotifierService.name, PersistentStateService.name]).constant('FeatureIndent', '  ').constant('FeatureNewLine', '\n').controller('FeatureEditorController', FeatureEditorController));
        }
    };
});
System.registerDynamic("app/features/ComponentEditor/ComponentEditor.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div ng-if=\"componentEditor.fileModel\">\n    <tractor-file-tree model=\"componentEditor\" type=\"components\"></tractor-file-tree>\n    <tractor-panel-handle panel-name=\"component-file-tree\"></tractor-panel-handle>\n    <form class=\"file\" name=\"componentEditor.fileEditor\" novalidate\n        ng-submit=\"componentEditor.showErrors() && componentEditor.saveFile()\">\n        <section class=\"file-options\">\n            <h1 class=\"file-options__name\">{{ componentEditor.fileModel.name }}</h1>\n            <div>\n                <tractor-variable-input class=\"file-options__name-input\"\n                    ng-if=\"!componentEditor.fileModel.isSaved\"\n                    form=\"componentEditor.fileEditor\"\n                    label=\"Name\"\n                    model=\"componentEditor.fileModel\"\n                    example=\"Component\"\n                    is-class>\n                </tractor-variable-input>\n            </div>\n            <div class=\"file-options__file-actions\">\n                <tractor-confirm-dialog trigger=\"componentEditor.confirmOverWrite\">\n                    <p>This will overwrite \"{{ componentEditor.fileModel.name }}\". Continue?</p>\n                </tractor-confirm-dialog>\n                <tractor-submit class=\"file-options__save-file\"\n                    action=\"Save component file\">\n                </tractor-submit>\n                <tractor-action class=\"file-options__new-file\"\n                    model=\"componentEditor\"\n                    action=\"New file\">\n                </tractor-action>\n            </div>\n        </section>\n\n        <section class=\"file-editor\">\n            <section ng-show=\"componentEditor.fileModel.name\">\n                <section class=\"file-editor__container\">\n                    <h2>Elements:</h2>\n\n                    <section ng-if=\"componentEditor.fileModel.domElements.length\">\n                        <ul>\n                            <li class=\"file-editor__list-item\"\n                                ng-repeat=\"domElement in componentEditor.fileModel.domElements\"\n                                ng-class=\"{ 'file-editor__list-item--minimised': domElement.minimised }\"\n                                ng-dblclick=\"componentEditor.minimise(domElement)\">\n\n                                <h3 class=\"file-editor__list-item-name\">{{ domElement.name }}</h3>\n\n                                <tractor-action\n                                    model=\"componentEditor.fileModel\"\n                                    action=\"Remove element\"\n                                    argument=\"domElement\"\n                                    icon=\"remove\">\n                                </tractor-action>\n\n                                <tractor-variable-input\n                                    form=\"componentEditor.fileEditor\"\n                                    label=\"Name\"\n                                    model=\"domElement\"\n                                    example=\"element\">\n                                </tractor-variable-input>\n                                <tractor-select\n                                    label=\"Type\"\n                                    model=\"domElement.selector\">\n                                </tractor-select>\n                                <tractor-text-input\n                                    form=\"componentEditor.fileEditor\"\n                                    label=\"Locator\"\n                                    model=\"domElement.selector\"\n                                    example=\"someController.someModel\">\n                                </tractor-text-input>\n\n                                <section>\n                                    <h3>Filters:</h3>\n\n                                    <ol ng-if=\"domElement.filters.length > 1\" as-sortable ng-model=\"domElement.sortableFilters\" is-disabled=\"domElement.filters.length < 3\">\n                                        <li class=\"file-editor__list-item\" ng-repeat=\"filter in domElement.sortableFilters\" as-sortable-item>\n                                            <tractor-action\n                                                model=\"domElement\"\n                                                action=\"Remove filter\"\n                                                argument=\"filter\"\n                                                icon=\"remove\">\n                                            </tractor-action>\n                                            <div class=\"file-editor__list-item-sort-handle\" title=\"Drag to sort\"\n                                                 ng-if=\"domElement.filters.length > 2\"\n                                                 as-sortable-item-handle>\n                                            </div>\n\n                                            <tractor-select ng-if=\"!domElement.filters[$index].isGroup\"\n                                                label=\"Type\"\n                                                model=\"filter\">\n                                            </tractor-select>\n                                            <tractor-text-input\n                                                form=\"componentEditor.fileEditor\"\n                                                label=\"Locator\"\n                                                model=\"filter\"\n                                                example=\"someController.someModel\">\n                                            </tractor-text-input>\n                                        </li>\n                                    </ol>\n\n                                    <tractor-action\n                                        model=\"domElement\"\n                                        action=\"Add filter\">\n                                    </tractor-action>\n                                </section>\n                            </li>\n                        </ul>\n                    </section>\n\n                    <tractor-action\n                        model=\"componentEditor.fileModel\"\n                        action=\"Add element\">\n                    </tractor-action>\n                </section>\n\n                <section class=\"file-editor__container\">\n                    <h2>Actions:</h2>\n\n                    <section ng-if=\"componentEditor.fileModel.actions.length\">\n                        <ul>\n                            <li class=\"file-editor__list-item\"\n                                ng-repeat=\"action in componentEditor.fileModel.actions\"\n                                ng-class=\"{ 'file-editor__list-item--minimised': action.minimised }\"\n                                ng-dblclick=\"componentEditor.minimise(action)\">\n\n                                <h3 class=\"file-editor__list-item-name\">{{ action.name }}</h3>\n\n                                <tractor-action\n                                    model=\"componentEditor.fileModel\"\n                                    action=\"Remove action\"\n                                    argument=\"action\"\n                                    icon=\"remove\">\n                                </tractor-action>\n\n                                <tractor-variable-input\n                                    form=\"componentEditor.fileEditor\"\n                                    label=\"Name\"\n                                    model=\"action\"\n                                    example=\"action\">\n                                </tractor-variable-input>\n\n                                <section>\n                                    <h3>Parameters:</h3>\n\n                                    <ol ng-if=\"action.parameters.length\" as-sortable ng-model=\"action.parameters\" is-disabled=\"action.parameters.length < 2\">\n                                        <li class=\"file-editor__list-item\" ng-repeat=\"parameter in action.parameters\" as-sortable-item>\n                                            <tractor-action\n                                                model=\"action\"\n                                                action=\"Remove parameter\"\n                                                argument=\"parameter\"\n                                                icon=\"remove\">\n                                            </tractor-action>\n                                            <div ng-if=\"action.parameters.length > 1\" class=\"file-editor__list-item-sort-handle\" as-sortable-item-handle title=\"Drag to sort\"></div>\n\n                                            <tractor-variable-input\n                                                form=\"componentEditor.fileEditor\"\n                                                label=\"Name\"\n                                                model=\"parameter\"\n                                                example=\"parameter\">\n                                            </tractor-variable-input>\n                                        </li>\n                                    </ol>\n\n                                    <tractor-action\n                                        model=\"action\"\n                                        action=\"Add parameter\">\n                                    </tractor-action>\n                                </section>\n\n                                <section>\n                                    <h3>Interactions:</h3>\n\n                                    <ol ng-if=\"action.interactions.length\" as-sortable ng-model=\"action.interactions\" is-disabled=\"action.interactions.length < 2\">\n                                        <li class=\"file-editor__list-item\" ng-repeat=\"interaction in action.interactions\" as-sortable-item>\n                                            <tractor-action\n                                                model=\"action\"\n                                                action=\"Remove interaction\"\n                                                argument=\"interaction\"\n                                                icon=\"remove\">\n                                            </tractor-action>\n                                            <div ng-if=\"action.interactions.length > 1\" class=\"file-editor__list-item-sort-handle\" as-sortable-item-handle title=\"Drag to sort\"></div>\n\n                                            <tractor-select\n                                                label=\"Element\"\n                                                model=\"interaction\"\n                                                options=\"componentEditor.fileModel.elements\"\n                                                as=\"name\">\n                                            </tractor-select>\n                                            <tractor-select\n                                                label=\"Method\"\n                                                model=\"interaction\"\n                                                options=\"interaction.element.methods\"\n                                                as=\"name\">\n                                            </tractor-select>\n\n                                            <div ng-repeat=\"argument in interaction.arguments\">\n                                                <tractor-literal-input\n                                                    form=\"componentEditor.fileEditor\"\n                                                    name=\"argument.name\"\n                                                    model=\"argument\"\n                                                    description=\"argument.description\"\n                                                    required=\"argument.required\"\n                                                    type=\"argument.type\">\n                                                </tractor-literal-input>\n                                            </div>\n                                        </li>\n                                    </ol>\n\n                                    <tractor-action\n                                        model=\"action\"\n                                        action=\"Add interaction\">\n                                    </tractor-action>\n                                </section>\n                            </li>\n                        </ul>\n                    </section>\n\n                    <tractor-action\n                        model=\"componentEditor.fileModel\"\n                        action=\"Add action\">\n                    </tractor-action>\n                </section>\n            </section>\n        </section>\n    </form>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.to-object", ["npm:core-js@1.2.3/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('npm:core-js@1.2.3/library/modules/$.defined');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.object.keys", ["npm:core-js@1.2.3/library/modules/$.to-object", "npm:core-js@1.2.3/library/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.2.3/library/modules/$.to-object');
  $__require('npm:core-js@1.2.3/library/modules/$.object-sap')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/object/keys", ["npm:core-js@1.2.3/library/modules/es6.object.keys", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.object.keys');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').Object.keys;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/keys", ["npm:core-js@1.2.3/library/fn/object/keys"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/object/keys'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register('app/features/FileEditor/FileEditorController.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/object/keys', 'npm:bluebird@2.10.2'], function (_export) {
    var _createClass, _classCallCheck, _Object$keys, Promise, FileEditorController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5825CoreJsObjectKeys['default'];
        }, function (_npmBluebird2102) {
            Promise = _npmBluebird2102['default'];
        }],
        execute: function () {
            'use strict';

            // Utilities:
            FileEditorController = (function () {
                function FileEditorController($state, confirmDialogService, persistentStateService, notifierService, fileService, FileModel, fileStructure, filePath) {
                    var _this = this;

                    _classCallCheck(this, FileEditorController);

                    this.$state = $state;
                    this.confirmDialogService = confirmDialogService;
                    this.persistentStateService = persistentStateService;
                    this.notifierService = notifierService;
                    this.fileService = fileService;
                    this.FileModel = FileModel;
                    this.fileStructure = fileStructure;

                    this.availableComponents = fileStructure.availableComponents;
                    this.availableMockData = fileStructure.availableMockData;

                    if (filePath) {
                        var path = filePath.path;

                        this.fileService.openFile({ path: path }, this.availableComponents, this.availableMockData).then(function (file) {
                            return _this.fileModel = file;
                        });
                    } else if (FileModel && !this.fileModel) {
                        this.newFile();
                    }
                }

                _createClass(FileEditorController, [{
                    key: 'newFile',
                    value: function newFile() {
                        if (this.fileModel) {
                            this.$state.go('.', { file: null });
                        }
                        this.fileModel = new this.FileModel();
                    }
                }, {
                    key: 'saveFile',
                    value: function saveFile() {
                        var _this2 = this;

                        var path = null;
                        var _fileModel = this.fileModel;
                        var data = _fileModel.data;
                        var name = _fileModel.name;

                        this.fileService.getPath({ path: this.fileModel.path, name: name }).then(function (filePath) {
                            path = filePath.path;
                            var exists = _this2.fileService.checkFileExists(_this2.fileStructure, path);

                            if (exists) {
                                _this2.confirmOverWrite = _this2.confirmDialogService.show();
                                return _this2.confirmOverWrite.promise['finally'](function () {
                                    _this2.confirmOverWrite = null;
                                });
                            } else {
                                return Promise.resolve();
                            }
                        }).then(function () {
                            return _this2.fileService.saveFile({ data: data, path: path });
                        }).then(function () {
                            return _this2.fileService.getFileStructure();
                        }).then(function (fileStructure) {
                            _this2.fileStructure = fileStructure;
                            return _this2.fileService.openFile({ path: path }, _this2.availableComponents, _this2.availableMockData);
                        }).then(function (file) {
                            return _this2.fileModel = file;
                        })['catch'](function () {
                            _this2.notifierService.error('File was not saved.');
                        });
                    }
                }, {
                    key: 'showErrors',
                    value: function showErrors() {
                        var fileEditor = this.fileEditor;
                        if (fileEditor.$invalid) {
                            _Object$keys(fileEditor.$error).forEach(function (invalidType) {
                                fileEditor.$error[invalidType].forEach(function (element) {
                                    element.$setTouched();
                                });
                            });
                            this.notifierService.error('Can\'t save file, something is invalid.');
                        }
                        return !fileEditor.$invalid;
                    }
                }, {
                    key: 'minimise',
                    value: function minimise(item) {
                        item.minimised = !item.minimised;

                        var displayState = this.persistentStateService.get(this.fileModel.name);
                        displayState[item.name] = item.minimised;
                        this.persistentStateService.set(this.fileModel.name, displayState);
                    }
                }]);

                return FileEditorController;
            })();

            _export('default', FileEditorController);
        }
    };
});
System.register('app/Core/Services/ConfirmDialogService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:bluebird@2.10.2', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _createClass, _classCallCheck, Promise, angular, ConfirmDialogService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBluebird2102) {
            Promise = _npmBluebird2102['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            ConfirmDialogService = (function () {
                function ConfirmDialogService() {
                    _classCallCheck(this, ConfirmDialogService);
                }

                _createClass(ConfirmDialogService, [{
                    key: 'show',
                    value: function show() {
                        var resolve = undefined,
                            reject = undefined;
                        var promise = new Promise(function () {
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }

                            resolve = args[0];
                            reject = args[1];
                        });
                        return { resolve: resolve, reject: reject, promise: promise };
                    }
                }]);

                return ConfirmDialogService;
            })();

            _export('default', angular.module('confirmDialogService', []).service('confirmDialogService', ConfirmDialogService));
        }
    };
});
System.register('app/Core/Services/FileService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check'], function (_export) {
    var _createClass, _classCallCheck, FileService;

    function findFileByPath(fileStructure, filePath) {
        return fileStructure.directory.allFiles.find(function (file) {
            return file.path.includes(filePath) || file.path.includes(filePath.replace(/\//g, '\\'));
        });
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }],
        execute: function () {
            'use strict';

            FileService = (function () {
                function FileService($http, parserService, fileStructureService, type) {
                    _classCallCheck(this, FileService);

                    this.$http = $http;
                    this.parserService = parserService;
                    this.fileStructureService = fileStructureService;
                    this.type = type;
                }

                _createClass(FileService, [{
                    key: 'checkFileExists',
                    value: function checkFileExists(fileStructure, filePath) {
                        return !!findFileByPath(fileStructure, filePath);
                    }
                }, {
                    key: 'getFileStructure',
                    value: function getFileStructure() {
                        return this.fileStructureService.getFileStructure(this.type);
                    }
                }, {
                    key: 'getPath',
                    value: function getPath(params) {
                        if (params.name) {
                            params.name = decodeURIComponent(params.name);
                        }
                        return this.$http.get('/' + this.type + '/file/path', { params: params });
                    }
                }, {
                    key: 'openFile',
                    value: function openFile(params, availableComponents, availableMockData) {
                        var _this = this;

                        if (params.path) {
                            params.path = decodeURIComponent(params.path);
                        }
                        return this.$http.get('/' + this.type + '/file', { params: params }).then(function (file) {
                            return _this.parserService.parse(file, availableComponents, availableMockData);
                        });
                    }
                }, {
                    key: 'saveFile',
                    value: function saveFile(options) {
                        return this.$http.put('/' + this.type + '/file', options);
                    }
                }]);

                return FileService;
            })();

            _export('default', FileService);
        }
    };
});
System.register('app/features/ComponentEditor/Services/ComponentFileService.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Services/ComponentParserService.js', 'app/Core/Services/FileService.js', 'app/Core/Services/FileStructureService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, angular, ComponentParserService, FileService, FileStructureService, ComponentFileService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorServicesComponentParserServiceJs) {
            ComponentParserService = _appFeaturesComponentEditorServicesComponentParserServiceJs['default'];
        }, function (_appCoreServicesFileServiceJs) {
            FileService = _appCoreServicesFileServiceJs['default'];
        }, function (_appCoreServicesFileStructureServiceJs) {
            FileStructureService = _appCoreServicesFileStructureServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            ComponentFileService = (function (_FileService) {
                _inherits(ComponentFileService, _FileService);

                function ComponentFileService($http, componentParserService, fileStructureService) {
                    _classCallCheck(this, ComponentFileService);

                    _get(Object.getPrototypeOf(ComponentFileService.prototype), 'constructor', this).call(this, $http, componentParserService, fileStructureService, 'components');
                }

                return ComponentFileService;
            })(FileService);

            _export('default', angular.module('tractor.componentFileService', [ComponentParserService.name, FileStructureService.name]).service('componentFileService', ComponentFileService));
        }
    };
});
System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.object.set-prototype-of", ["npm:core-js@1.2.3/library/modules/$.def", "npm:core-js@1.2.3/library/modules/$.set-proto"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/library/modules/$.def');
  $def($def.S, 'Object', {setPrototypeOf: $__require('npm:core-js@1.2.3/library/modules/$.set-proto').set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/object/set-prototype-of", ["npm:core-js@1.2.3/library/modules/es6.object.set-prototype-of", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.object.set-prototype-of');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/set-prototype-of", ["npm:core-js@1.2.3/library/fn/object/set-prototype-of"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/object/set-prototype-of'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/helpers/inherits", ["npm:babel-runtime@5.8.25/core-js/object/create", "npm:babel-runtime@5.8.25/core-js/object/set-prototype-of"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('npm:babel-runtime@5.8.25/core-js/object/create')["default"];
  var _Object$setPrototypeOf = $__require('npm:babel-runtime@5.8.25/core-js/object/set-prototype-of')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.object-sap", ["npm:core-js@1.2.3/library/modules/$.def", "npm:core-js@1.2.3/library/modules/$.core", "npm:core-js@1.2.3/library/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY, exec) {
    var $def = $__require('npm:core-js@1.2.3/library/modules/$.def'),
        fn = ($__require('npm:core-js@1.2.3/library/modules/$.core').Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $def($def.S + $def.F * $__require('npm:core-js@1.2.3/library/modules/$.fails')(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.object.get-own-property-descriptor", ["npm:core-js@1.2.3/library/modules/$.to-iobject", "npm:core-js@1.2.3/library/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.3/library/modules/$.to-iobject');
  $__require('npm:core-js@1.2.3/library/modules/$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/object/get-own-property-descriptor", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/es6.object.get-own-property-descriptor"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$');
  $__require('npm:core-js@1.2.3/library/modules/es6.object.get-own-property-descriptor');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/get-own-property-descriptor", ["npm:core-js@1.2.3/library/fn/object/get-own-property-descriptor"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/object/get-own-property-descriptor'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/helpers/get", ["npm:babel-runtime@5.8.25/core-js/object/get-own-property-descriptor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('npm:babel-runtime@5.8.25/core-js/object/get-own-property-descriptor')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('app/features/ComponentEditor/ComponentEditorController.js', ['npm:babel-runtime@5.8.25/helpers/get', 'npm:babel-runtime@5.8.25/helpers/inherits', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ComponentModel.js', 'app/features/ComponentEditor/Services/ComponentFileService.js', 'app/Core/Services/ConfirmDialogService.js', 'app/features/FileEditor/FileEditorController.js', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Services/PersistentStateService.js'], function (_export) {
    var _get, _inherits, _classCallCheck, angular, ComponentModel, ComponentFileService, ConfirmDialogService, FileEditorController, NotifierService, PersistentStateService, ComponentEditorController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersGet) {
            _get = _npmBabelRuntime5825HelpersGet['default'];
        }, function (_npmBabelRuntime5825HelpersInherits) {
            _inherits = _npmBabelRuntime5825HelpersInherits['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsComponentModelJs) {
            ComponentModel = _appFeaturesComponentEditorModelsComponentModelJs['default'];
        }, function (_appFeaturesComponentEditorServicesComponentFileServiceJs) {
            ComponentFileService = _appFeaturesComponentEditorServicesComponentFileServiceJs['default'];
        }, function (_appCoreServicesConfirmDialogServiceJs) {
            ConfirmDialogService = _appCoreServicesConfirmDialogServiceJs['default'];
        }, function (_appFeaturesFileEditorFileEditorControllerJs) {
            FileEditorController = _appFeaturesFileEditorFileEditorControllerJs['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            ComponentEditorController = (function (_FileEditorController) {
                _inherits(ComponentEditorController, _FileEditorController);

                function ComponentEditorController($state, confirmDialogService, persistentStateService, notifierService, componentFileService, ComponentModel, componentFileStructure, componentPath) {
                    _classCallCheck(this, ComponentEditorController);

                    _get(Object.getPrototypeOf(ComponentEditorController.prototype), 'constructor', this).call(this, $state, confirmDialogService, persistentStateService, notifierService, componentFileService, ComponentModel, componentFileStructure, componentPath);
                    this.component = this.fileModel;
                }

                return ComponentEditorController;
            })(FileEditorController);

            _export('default', angular.module('componentEditorController', [ComponentModel.name, ComponentFileService.name, ConfirmDialogService.name, NotifierService.name, PersistentStateService.name]).controller('ComponentEditorController', ComponentEditorController));
        }
    };
});
System.registerDynamic("app/features/ControlPanel/ControlPanel.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<header>\r\n    <section class=\"control-panel__top-row\">\r\n        <div>\r\n            <form class=\"control-panel__run-options\" name=\"controlPanelOptions\" novalidate\r\n                ng-submit=\"controlPanel.runProtractor()\">\r\n                <tractor-select\r\n                    label=\"Environment\"\r\n                    model=\"controlPanel\">\r\n                </tractor-select>\r\n                <tractor-submit\r\n                    action=\"Run protractor\">\r\n                </tractor-submit>\r\n            </form>\r\n        </div>\r\n        <span class=\"control-panel__server-status\"\r\n              ng-class=\"{ 'control-panel__server-status--running': controlPanel.isServerRunning }\"\r\n              ng-attr-title=\"{{ 'Tractor server is ' + (controlPanel.isServerRunning ? 'running.' : 'not running.') }}\">\r\n        </span>\r\n    </section>\r\n\r\n    <nav>\r\n        <ul>\r\n            <li ui-sref-active=\"active\">\r\n                <a ui-sref=\".components({ file: null })\">Components</a>\r\n            </li>\r\n            <li ui-sref-active=\"active\">\r\n                <a ui-sref=\".features({ file: null })\">Features</a>\r\n            </li>\r\n            <li ui-sref-active=\"active\">\r\n                <a ui-sref=\".step-definitions({ file: null })\">Step Definitions</a>\r\n            </li>\r\n            <li ui-sref-active=\"active\">\r\n                <a ui-sref=\".mock-data({ file: null })\">Mock Data</a>\r\n            </li>\r\n        </ul>\r\n    </nav>\r\n</header>\r\n\r\n<main ui-view></main>\r\n\r\n<tractor-notifier></tractor-notifier>\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/features/ControlPanel/Services/ServerStatusService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Services/RealTimeService.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, NotifierService, RealTimeService, DISCONNECT_MESSAGE, isServerRunning, ServerStatusService;

    function onConnect() {
        this[isServerRunning] = true;
        this.$rootScope.$apply();
    }

    function onDisconnect() {
        this[isServerRunning] = false;
        this.$rootScope.$apply();
        this.notifierService.error(DISCONNECT_MESSAGE);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreServicesRealTimeServiceJs) {
            RealTimeService = _appCoreServicesRealTimeServiceJs['default'];
        }],
        execute: function () {

            // Symbols:
            'use strict';

            // Constants:

            // Dependencies:
            DISCONNECT_MESSAGE = 'Tractor server disconnected...';
            isServerRunning = _Symbol();

            ServerStatusService = (function () {
                function ServerStatusService($rootScope, notifierService, realTimeService) {
                    _classCallCheck(this, ServerStatusService);

                    this.$rootScope = $rootScope;
                    this.notifierService = notifierService;
                    this.realTimeService = realTimeService;

                    this[isServerRunning] = false;
                }

                _createClass(ServerStatusService, [{
                    key: 'monitorServerStatus',
                    value: function monitorServerStatus() {
                        this.realTimeService.connect('server-status', {
                            connect: onConnect.bind(this),
                            disconnect: onDisconnect.bind(this)
                        });
                    }
                }, {
                    key: 'isServerRunning',
                    get: function get() {
                        return this[isServerRunning];
                    }
                }]);

                return ServerStatusService;
            })();

            _export('default', angular.module('tractor.serverStatusService', [NotifierService.name, RealTimeService.name]).service('serverStatusService', ServerStatusService));
        }
    };
});
System.register('app/features/ControlPanel/Services/RunnerService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Services/RealTimeService.js'], function (_export) {
    var _createClass, _classCallCheck, angular, NotifierService, RealTimeService, RunnerService;

    function notify(data) {
        var type = data.type;
        var message = data.message;

        this.notifierService[type](message);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreServicesRealTimeServiceJs) {
            RealTimeService = _appCoreServicesRealTimeServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            RunnerService = (function () {
                function RunnerService(notifierService, realTimeService) {
                    _classCallCheck(this, RunnerService);

                    this.notifierService = notifierService;
                    this.realTimeService = realTimeService;
                }

                _createClass(RunnerService, [{
                    key: 'runProtractor',
                    value: function runProtractor(options) {
                        var connection = this.realTimeService.connect('run-protractor', {
                            'protractor-out': notify.bind(this),
                            'protractor-err': notify.bind(this)
                        });
                        connection.emit('run', options);
                    }
                }]);

                return RunnerService;
            })();

            _export('default', angular.module('tractor.runnerService', [NotifierService.name, RealTimeService.name]).service('runnerService', RunnerService));
        }
    };
});
System.register('app/features/ControlPanel/ControlPanelController.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/features/ControlPanel/Services/RunnerService.js', 'app/features/ControlPanel/Services/ServerStatusService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, angular, RunnerService, ServerStatusService, environments, ControlPanelController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesControlPanelServicesRunnerServiceJs) {
            RunnerService = _appFeaturesControlPanelServicesRunnerServiceJs['default'];
        }, function (_appFeaturesControlPanelServicesServerStatusServiceJs) {
            ServerStatusService = _appFeaturesControlPanelServicesServerStatusServiceJs['default'];
        }],
        execute: function () {

            // Symbols:
            'use strict';

            // Dependencies:
            environments = _Symbol();

            ControlPanelController = (function () {
                function ControlPanelController(runnerService, serverStatusService, config) {
                    _classCallCheck(this, ControlPanelController);

                    this.runnerService = runnerService;
                    this.serverStatusService = serverStatusService;
                    this[environments] = config.environments;

                    var _environments = _slicedToArray(this.environments, 1);

                    var environment = _environments[0];

                    this.environment = environment;

                    this.serverStatusService.monitorServerStatus();
                }

                _createClass(ControlPanelController, [{
                    key: 'runProtractor',
                    value: function runProtractor() {
                        this.runnerService.runProtractor({
                            baseUrl: this.environment
                        });
                    }
                }, {
                    key: 'environments',
                    get: function get() {
                        return this[environments];
                    }
                }, {
                    key: 'isServerRunning',
                    get: function get() {
                        return this.serverStatusService.isServerRunning;
                    }
                }]);

                return ControlPanelController;
            })();

            _export('default', angular.module('controlPanelController', [RunnerService.name, ServerStatusService.name]).controller('ControlPanelController', ControlPanelController));
        }
    };
});
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
!function(e) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = e();
  else if ("function" == typeof define && define.amd)
    define("github:socketio/socket.io-client@1.3.7/socket.io", [], e);
  else {
    var f;
    "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.io = e();
  }
}(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          throw new Error("Cannot find module '" + o + "'");
        }
        var f = n[o] = {exports: {}};
        t[o][0].call(f.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, f, f.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(_dereq_, module, exports) {
      module.exports = _dereq_('./lib/');
    }, {"./lib/": 2}],
    2: [function(_dereq_, module, exports) {
      var url = _dereq_('./url');
      var parser = _dereq_('socket.io-parser');
      var Manager = _dereq_('./manager');
      var debug = _dereq_('debug')('socket.io-client');
      module.exports = exports = lookup;
      var cache = exports.managers = {};
      function lookup(uri, opts) {
        if (typeof uri == 'object') {
          opts = uri;
          uri = undefined;
        }
        opts = opts || {};
        var parsed = url(uri);
        var source = parsed.source;
        var id = parsed.id;
        var io;
        if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
          debug('ignoring socket cache for %s', source);
          io = Manager(source, opts);
        } else {
          if (!cache[id]) {
            debug('new io instance for %s', source);
            cache[id] = Manager(source, opts);
          }
          io = cache[id];
        }
        return io.socket(parsed.path);
      }
      exports.protocol = parser.protocol;
      exports.connect = lookup;
      exports.Manager = _dereq_('./manager');
      exports.Socket = _dereq_('./socket');
    }, {
      "./manager": 3,
      "./socket": 5,
      "./url": 6,
      "debug": 10,
      "socket.io-parser": 44
    }],
    3: [function(_dereq_, module, exports) {
      var url = _dereq_('./url');
      var eio = _dereq_('engine.io-client');
      var Socket = _dereq_('./socket');
      var Emitter = _dereq_('component-emitter');
      var parser = _dereq_('socket.io-parser');
      var on = _dereq_('./on');
      var bind = _dereq_('component-bind');
      var object = _dereq_('object-component');
      var debug = _dereq_('debug')('socket.io-client:manager');
      var indexOf = _dereq_('indexof');
      var Backoff = _dereq_('backo2');
      module.exports = Manager;
      function Manager(uri, opts) {
        if (!(this instanceof Manager))
          return new Manager(uri, opts);
        if (uri && ('object' == typeof uri)) {
          opts = uri;
          uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || '/socket.io';
        this.nsps = {};
        this.subs = [];
        this.opts = opts;
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor(opts.randomizationFactor || 0.5);
        this.backoff = new Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this.readyState = 'closed';
        this.uri = uri;
        this.connected = [];
        this.encoding = false;
        this.packetBuffer = [];
        this.encoder = new parser.Encoder();
        this.decoder = new parser.Decoder();
        this.autoConnect = opts.autoConnect !== false;
        if (this.autoConnect)
          this.open();
      }
      Manager.prototype.emitAll = function() {
        this.emit.apply(this, arguments);
        for (var nsp in this.nsps) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      };
      Manager.prototype.updateSocketIds = function() {
        for (var nsp in this.nsps) {
          this.nsps[nsp].id = this.engine.id;
        }
      };
      Emitter(Manager.prototype);
      Manager.prototype.reconnection = function(v) {
        if (!arguments.length)
          return this._reconnection;
        this._reconnection = !!v;
        return this;
      };
      Manager.prototype.reconnectionAttempts = function(v) {
        if (!arguments.length)
          return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      };
      Manager.prototype.reconnectionDelay = function(v) {
        if (!arguments.length)
          return this._reconnectionDelay;
        this._reconnectionDelay = v;
        this.backoff && this.backoff.setMin(v);
        return this;
      };
      Manager.prototype.randomizationFactor = function(v) {
        if (!arguments.length)
          return this._randomizationFactor;
        this._randomizationFactor = v;
        this.backoff && this.backoff.setJitter(v);
        return this;
      };
      Manager.prototype.reconnectionDelayMax = function(v) {
        if (!arguments.length)
          return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        this.backoff && this.backoff.setMax(v);
        return this;
      };
      Manager.prototype.timeout = function(v) {
        if (!arguments.length)
          return this._timeout;
        this._timeout = v;
        return this;
      };
      Manager.prototype.maybeReconnectOnOpen = function() {
        if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      };
      Manager.prototype.open = Manager.prototype.connect = function(fn) {
        debug('readyState %s', this.readyState);
        if (~this.readyState.indexOf('open'))
          return this;
        debug('opening %s', this.uri);
        this.engine = eio(this.uri, this.opts);
        var socket = this.engine;
        var self = this;
        this.readyState = 'opening';
        this.skipReconnect = false;
        var openSub = on(socket, 'open', function() {
          self.onopen();
          fn && fn();
        });
        var errorSub = on(socket, 'error', function(data) {
          debug('connect_error');
          self.cleanup();
          self.readyState = 'closed';
          self.emitAll('connect_error', data);
          if (fn) {
            var err = new Error('Connection error');
            err.data = data;
            fn(err);
          } else {
            self.maybeReconnectOnOpen();
          }
        });
        if (false !== this._timeout) {
          var timeout = this._timeout;
          debug('connect attempt will timeout after %d', timeout);
          var timer = setTimeout(function() {
            debug('connect attempt timed out after %d', timeout);
            openSub.destroy();
            socket.close();
            socket.emit('error', 'timeout');
            self.emitAll('connect_timeout', timeout);
          }, timeout);
          this.subs.push({destroy: function() {
              clearTimeout(timer);
            }});
        }
        this.subs.push(openSub);
        this.subs.push(errorSub);
        return this;
      };
      Manager.prototype.onopen = function() {
        debug('open');
        this.cleanup();
        this.readyState = 'open';
        this.emit('open');
        var socket = this.engine;
        this.subs.push(on(socket, 'data', bind(this, 'ondata')));
        this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
        this.subs.push(on(socket, 'error', bind(this, 'onerror')));
        this.subs.push(on(socket, 'close', bind(this, 'onclose')));
      };
      Manager.prototype.ondata = function(data) {
        this.decoder.add(data);
      };
      Manager.prototype.ondecoded = function(packet) {
        this.emit('packet', packet);
      };
      Manager.prototype.onerror = function(err) {
        debug('error', err);
        this.emitAll('error', err);
      };
      Manager.prototype.socket = function(nsp) {
        var socket = this.nsps[nsp];
        if (!socket) {
          socket = new Socket(this, nsp);
          this.nsps[nsp] = socket;
          var self = this;
          socket.on('connect', function() {
            socket.id = self.engine.id;
            if (!~indexOf(self.connected, socket)) {
              self.connected.push(socket);
            }
          });
        }
        return socket;
      };
      Manager.prototype.destroy = function(socket) {
        var index = indexOf(this.connected, socket);
        if (~index)
          this.connected.splice(index, 1);
        if (this.connected.length)
          return;
        this.close();
      };
      Manager.prototype.packet = function(packet) {
        debug('writing packet %j', packet);
        var self = this;
        if (!self.encoding) {
          self.encoding = true;
          this.encoder.encode(packet, function(encodedPackets) {
            for (var i = 0; i < encodedPackets.length; i++) {
              self.engine.write(encodedPackets[i]);
            }
            self.encoding = false;
            self.processPacketQueue();
          });
        } else {
          self.packetBuffer.push(packet);
        }
      };
      Manager.prototype.processPacketQueue = function() {
        if (this.packetBuffer.length > 0 && !this.encoding) {
          var pack = this.packetBuffer.shift();
          this.packet(pack);
        }
      };
      Manager.prototype.cleanup = function() {
        var sub;
        while (sub = this.subs.shift())
          sub.destroy();
        this.packetBuffer = [];
        this.encoding = false;
        this.decoder.destroy();
      };
      Manager.prototype.close = Manager.prototype.disconnect = function() {
        this.skipReconnect = true;
        this.backoff.reset();
        this.readyState = 'closed';
        this.engine && this.engine.close();
      };
      Manager.prototype.onclose = function(reason) {
        debug('close');
        this.cleanup();
        this.backoff.reset();
        this.readyState = 'closed';
        this.emit('close', reason);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      };
      Manager.prototype.reconnect = function() {
        if (this.reconnecting || this.skipReconnect)
          return this;
        var self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug('reconnect failed');
          this.backoff.reset();
          this.emitAll('reconnect_failed');
          this.reconnecting = false;
        } else {
          var delay = this.backoff.duration();
          debug('will wait %dms before reconnect attempt', delay);
          this.reconnecting = true;
          var timer = setTimeout(function() {
            if (self.skipReconnect)
              return;
            debug('attempting reconnect');
            self.emitAll('reconnect_attempt', self.backoff.attempts);
            self.emitAll('reconnecting', self.backoff.attempts);
            if (self.skipReconnect)
              return;
            self.open(function(err) {
              if (err) {
                debug('reconnect attempt error');
                self.reconnecting = false;
                self.reconnect();
                self.emitAll('reconnect_error', err.data);
              } else {
                debug('reconnect success');
                self.onreconnect();
              }
            });
          }, delay);
          this.subs.push({destroy: function() {
              clearTimeout(timer);
            }});
        }
      };
      Manager.prototype.onreconnect = function() {
        var attempt = this.backoff.attempts;
        this.reconnecting = false;
        this.backoff.reset();
        this.updateSocketIds();
        this.emitAll('reconnect', attempt);
      };
    }, {
      "./on": 4,
      "./socket": 5,
      "./url": 6,
      "backo2": 7,
      "component-bind": 8,
      "component-emitter": 9,
      "debug": 10,
      "engine.io-client": 11,
      "indexof": 40,
      "object-component": 41,
      "socket.io-parser": 44
    }],
    4: [function(_dereq_, module, exports) {
      module.exports = on;
      function on(obj, ev, fn) {
        obj.on(ev, fn);
        return {destroy: function() {
            obj.removeListener(ev, fn);
          }};
      }
    }, {}],
    5: [function(_dereq_, module, exports) {
      var parser = _dereq_('socket.io-parser');
      var Emitter = _dereq_('component-emitter');
      var toArray = _dereq_('to-array');
      var on = _dereq_('./on');
      var bind = _dereq_('component-bind');
      var debug = _dereq_('debug')('socket.io-client:socket');
      var hasBin = _dereq_('has-binary');
      module.exports = exports = Socket;
      var events = {
        connect: 1,
        connect_error: 1,
        connect_timeout: 1,
        disconnect: 1,
        error: 1,
        reconnect: 1,
        reconnect_attempt: 1,
        reconnect_failed: 1,
        reconnect_error: 1,
        reconnecting: 1
      };
      var emit = Emitter.prototype.emit;
      function Socket(io, nsp) {
        this.io = io;
        this.nsp = nsp;
        this.json = this;
        this.ids = 0;
        this.acks = {};
        if (this.io.autoConnect)
          this.open();
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.connected = false;
        this.disconnected = true;
      }
      Emitter(Socket.prototype);
      Socket.prototype.subEvents = function() {
        if (this.subs)
          return;
        var io = this.io;
        this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
      };
      Socket.prototype.open = Socket.prototype.connect = function() {
        if (this.connected)
          return this;
        this.subEvents();
        this.io.open();
        if ('open' == this.io.readyState)
          this.onopen();
        return this;
      };
      Socket.prototype.send = function() {
        var args = toArray(arguments);
        args.unshift('message');
        this.emit.apply(this, args);
        return this;
      };
      Socket.prototype.emit = function(ev) {
        if (events.hasOwnProperty(ev)) {
          emit.apply(this, arguments);
          return this;
        }
        var args = toArray(arguments);
        var parserType = parser.EVENT;
        if (hasBin(args)) {
          parserType = parser.BINARY_EVENT;
        }
        var packet = {
          type: parserType,
          data: args
        };
        if ('function' == typeof args[args.length - 1]) {
          debug('emitting packet with ack id %d', this.ids);
          this.acks[this.ids] = args.pop();
          packet.id = this.ids++;
        }
        if (this.connected) {
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        return this;
      };
      Socket.prototype.packet = function(packet) {
        packet.nsp = this.nsp;
        this.io.packet(packet);
      };
      Socket.prototype.onopen = function() {
        debug('transport is open - connecting');
        if ('/' != this.nsp) {
          this.packet({type: parser.CONNECT});
        }
      };
      Socket.prototype.onclose = function(reason) {
        debug('close (%s)', reason);
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emit('disconnect', reason);
      };
      Socket.prototype.onpacket = function(packet) {
        if (packet.nsp != this.nsp)
          return;
        switch (packet.type) {
          case parser.CONNECT:
            this.onconnect();
            break;
          case parser.EVENT:
            this.onevent(packet);
            break;
          case parser.BINARY_EVENT:
            this.onevent(packet);
            break;
          case parser.ACK:
            this.onack(packet);
            break;
          case parser.BINARY_ACK:
            this.onack(packet);
            break;
          case parser.DISCONNECT:
            this.ondisconnect();
            break;
          case parser.ERROR:
            this.emit('error', packet.data);
            break;
        }
      };
      Socket.prototype.onevent = function(packet) {
        var args = packet.data || [];
        debug('emitting event %j', args);
        if (null != packet.id) {
          debug('attaching ack callback to event');
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          emit.apply(this, args);
        } else {
          this.receiveBuffer.push(args);
        }
      };
      Socket.prototype.ack = function(id) {
        var self = this;
        var sent = false;
        return function() {
          if (sent)
            return;
          sent = true;
          var args = toArray(arguments);
          debug('sending ack %j', args);
          var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
          self.packet({
            type: type,
            id: id,
            data: args
          });
        };
      };
      Socket.prototype.onack = function(packet) {
        debug('calling ack %s with %j', packet.id, packet.data);
        var fn = this.acks[packet.id];
        fn.apply(this, packet.data);
        delete this.acks[packet.id];
      };
      Socket.prototype.onconnect = function() {
        this.connected = true;
        this.disconnected = false;
        this.emit('connect');
        this.emitBuffered();
      };
      Socket.prototype.emitBuffered = function() {
        var i;
        for (i = 0; i < this.receiveBuffer.length; i++) {
          emit.apply(this, this.receiveBuffer[i]);
        }
        this.receiveBuffer = [];
        for (i = 0; i < this.sendBuffer.length; i++) {
          this.packet(this.sendBuffer[i]);
        }
        this.sendBuffer = [];
      };
      Socket.prototype.ondisconnect = function() {
        debug('server disconnect (%s)', this.nsp);
        this.destroy();
        this.onclose('io server disconnect');
      };
      Socket.prototype.destroy = function() {
        if (this.subs) {
          for (var i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
          }
          this.subs = null;
        }
        this.io.destroy(this);
      };
      Socket.prototype.close = Socket.prototype.disconnect = function() {
        if (this.connected) {
          debug('performing disconnect (%s)', this.nsp);
          this.packet({type: parser.DISCONNECT});
        }
        this.destroy();
        if (this.connected) {
          this.onclose('io client disconnect');
        }
        return this;
      };
    }, {
      "./on": 4,
      "component-bind": 8,
      "component-emitter": 9,
      "debug": 10,
      "has-binary": 36,
      "socket.io-parser": 44,
      "to-array": 48
    }],
    6: [function(_dereq_, module, exports) {
      (function(global) {
        var parseuri = _dereq_('parseuri');
        var debug = _dereq_('debug')('socket.io-client:url');
        module.exports = url;
        function url(uri, loc) {
          var obj = uri;
          var loc = loc || global.location;
          if (null == uri)
            uri = loc.protocol + '//' + loc.host;
          if ('string' == typeof uri) {
            if ('/' == uri.charAt(0)) {
              if ('/' == uri.charAt(1)) {
                uri = loc.protocol + uri;
              } else {
                uri = loc.hostname + uri;
              }
            }
            if (!/^(https?|wss?):\/\//.test(uri)) {
              debug('protocol-less url %s', uri);
              if ('undefined' != typeof loc) {
                uri = loc.protocol + '//' + uri;
              } else {
                uri = 'https://' + uri;
              }
            }
            debug('parse %s', uri);
            obj = parseuri(uri);
          }
          if (!obj.port) {
            if (/^(http|ws)$/.test(obj.protocol)) {
              obj.port = '80';
            } else if (/^(http|ws)s$/.test(obj.protocol)) {
              obj.port = '443';
            }
          }
          obj.path = obj.path || '/';
          obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
          obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
          return obj;
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "debug": 10,
      "parseuri": 42
    }],
    7: [function(_dereq_, module, exports) {
      module.exports = Backoff;
      function Backoff(opts) {
        opts = opts || {};
        this.ms = opts.min || 100;
        this.max = opts.max || 10000;
        this.factor = opts.factor || 2;
        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
        this.attempts = 0;
      }
      Backoff.prototype.duration = function() {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var rand = Math.random();
          var deviation = Math.floor(rand * this.jitter * ms);
          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
      };
      Backoff.prototype.reset = function() {
        this.attempts = 0;
      };
      Backoff.prototype.setMin = function(min) {
        this.ms = min;
      };
      Backoff.prototype.setMax = function(max) {
        this.max = max;
      };
      Backoff.prototype.setJitter = function(jitter) {
        this.jitter = jitter;
      };
    }, {}],
    8: [function(_dereq_, module, exports) {
      var slice = [].slice;
      module.exports = function(obj, fn) {
        if ('string' == typeof fn)
          fn = obj[fn];
        if ('function' != typeof fn)
          throw new Error('bind() requires a function');
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.concat(slice.call(arguments)));
        };
      };
    }, {}],
    9: [function(_dereq_, module, exports) {
      module.exports = Emitter;
      function Emitter(obj) {
        if (obj)
          return mixin(obj);
      }
      ;
      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        var self = this;
        this._callbacks = this._callbacks || {};
        function on() {
          self.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks[event];
        if (!callbacks)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this._callbacks[event];
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0,
              len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    }, {}],
    10: [function(_dereq_, module, exports) {
      module.exports = debug;
      function debug(name) {
        if (!debug.enabled(name))
          return function() {};
        return function(fmt) {
          fmt = coerce(fmt);
          var curr = new Date;
          var ms = curr - (debug[name] || curr);
          debug[name] = curr;
          fmt = name + ' ' + fmt + ' +' + debug.humanize(ms);
          window.console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        };
      }
      debug.names = [];
      debug.skips = [];
      debug.enable = function(name) {
        try {
          localStorage.debug = name;
        } catch (e) {}
        var split = (name || '').split(/[\s,]+/),
            len = split.length;
        for (var i = 0; i < len; i++) {
          name = split[i].replace('*', '.*?');
          if (name[0] === '-') {
            debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
          } else {
            debug.names.push(new RegExp('^' + name + '$'));
          }
        }
      };
      debug.disable = function() {
        debug.enable('');
      };
      debug.humanize = function(ms) {
        var sec = 1000,
            min = 60 * 1000,
            hour = 60 * min;
        if (ms >= hour)
          return (ms / hour).toFixed(1) + 'h';
        if (ms >= min)
          return (ms / min).toFixed(1) + 'm';
        if (ms >= sec)
          return (ms / sec | 0) + 's';
        return ms + 'ms';
      };
      debug.enabled = function(name) {
        for (var i = 0,
            len = debug.skips.length; i < len; i++) {
          if (debug.skips[i].test(name)) {
            return false;
          }
        }
        for (var i = 0,
            len = debug.names.length; i < len; i++) {
          if (debug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      };
      function coerce(val) {
        if (val instanceof Error)
          return val.stack || val.message;
        return val;
      }
      try {
        if (window.localStorage)
          debug.enable(localStorage.debug);
      } catch (e) {}
    }, {}],
    11: [function(_dereq_, module, exports) {
      module.exports = _dereq_('./lib/');
    }, {"./lib/": 12}],
    12: [function(_dereq_, module, exports) {
      module.exports = _dereq_('./socket');
      module.exports.parser = _dereq_('engine.io-parser');
    }, {
      "./socket": 13,
      "engine.io-parser": 25
    }],
    13: [function(_dereq_, module, exports) {
      (function(global) {
        var transports = _dereq_('./transports');
        var Emitter = _dereq_('component-emitter');
        var debug = _dereq_('debug')('engine.io-client:socket');
        var index = _dereq_('indexof');
        var parser = _dereq_('engine.io-parser');
        var parseuri = _dereq_('parseuri');
        var parsejson = _dereq_('parsejson');
        var parseqs = _dereq_('parseqs');
        module.exports = Socket;
        function noop() {}
        function Socket(uri, opts) {
          if (!(this instanceof Socket))
            return new Socket(uri, opts);
          opts = opts || {};
          if (uri && 'object' == typeof uri) {
            opts = uri;
            uri = null;
          }
          if (uri) {
            uri = parseuri(uri);
            opts.host = uri.host;
            opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
            opts.port = uri.port;
            if (uri.query)
              opts.query = uri.query;
          }
          this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' == location.protocol);
          if (opts.host) {
            var pieces = opts.host.split(':');
            opts.hostname = pieces.shift();
            if (pieces.length) {
              opts.port = pieces.pop();
            } else if (!opts.port) {
              opts.port = this.secure ? '443' : '80';
            }
          }
          this.agent = opts.agent || false;
          this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
          this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80));
          this.query = opts.query || {};
          if ('string' == typeof this.query)
            this.query = parseqs.decode(this.query);
          this.upgrade = false !== opts.upgrade;
          this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
          this.forceJSONP = !!opts.forceJSONP;
          this.jsonp = false !== opts.jsonp;
          this.forceBase64 = !!opts.forceBase64;
          this.enablesXDR = !!opts.enablesXDR;
          this.timestampParam = opts.timestampParam || 't';
          this.timestampRequests = opts.timestampRequests;
          this.transports = opts.transports || ['polling', 'websocket'];
          this.readyState = '';
          this.writeBuffer = [];
          this.callbackBuffer = [];
          this.policyPort = opts.policyPort || 843;
          this.rememberUpgrade = opts.rememberUpgrade || false;
          this.binaryType = null;
          this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
          this.pfx = opts.pfx || null;
          this.key = opts.key || null;
          this.passphrase = opts.passphrase || null;
          this.cert = opts.cert || null;
          this.ca = opts.ca || null;
          this.ciphers = opts.ciphers || null;
          this.rejectUnauthorized = opts.rejectUnauthorized || null;
          this.open();
        }
        Socket.priorWebsocketSuccess = false;
        Emitter(Socket.prototype);
        Socket.protocol = parser.protocol;
        Socket.Socket = Socket;
        Socket.Transport = _dereq_('./transport');
        Socket.transports = _dereq_('./transports');
        Socket.parser = _dereq_('engine.io-parser');
        Socket.prototype.createTransport = function(name) {
          debug('creating transport "%s"', name);
          var query = clone(this.query);
          query.EIO = parser.protocol;
          query.transport = name;
          if (this.id)
            query.sid = this.id;
          var transport = new transports[name]({
            agent: this.agent,
            hostname: this.hostname,
            port: this.port,
            secure: this.secure,
            path: this.path,
            query: query,
            forceJSONP: this.forceJSONP,
            jsonp: this.jsonp,
            forceBase64: this.forceBase64,
            enablesXDR: this.enablesXDR,
            timestampRequests: this.timestampRequests,
            timestampParam: this.timestampParam,
            policyPort: this.policyPort,
            socket: this,
            pfx: this.pfx,
            key: this.key,
            passphrase: this.passphrase,
            cert: this.cert,
            ca: this.ca,
            ciphers: this.ciphers,
            rejectUnauthorized: this.rejectUnauthorized
          });
          return transport;
        };
        function clone(obj) {
          var o = {};
          for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
              o[i] = obj[i];
            }
          }
          return o;
        }
        Socket.prototype.open = function() {
          var transport;
          if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
            transport = 'websocket';
          } else if (0 == this.transports.length) {
            var self = this;
            setTimeout(function() {
              self.emit('error', 'No transports available');
            }, 0);
            return;
          } else {
            transport = this.transports[0];
          }
          this.readyState = 'opening';
          var transport;
          try {
            transport = this.createTransport(transport);
          } catch (e) {
            this.transports.shift();
            this.open();
            return;
          }
          transport.open();
          this.setTransport(transport);
        };
        Socket.prototype.setTransport = function(transport) {
          debug('setting transport %s', transport.name);
          var self = this;
          if (this.transport) {
            debug('clearing existing transport %s', this.transport.name);
            this.transport.removeAllListeners();
          }
          this.transport = transport;
          transport.on('drain', function() {
            self.onDrain();
          }).on('packet', function(packet) {
            self.onPacket(packet);
          }).on('error', function(e) {
            self.onError(e);
          }).on('close', function() {
            self.onClose('transport close');
          });
        };
        Socket.prototype.probe = function(name) {
          debug('probing transport "%s"', name);
          var transport = this.createTransport(name, {probe: 1}),
              failed = false,
              self = this;
          Socket.priorWebsocketSuccess = false;
          function onTransportOpen() {
            if (self.onlyBinaryUpgrades) {
              var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
              failed = failed || upgradeLosesBinary;
            }
            if (failed)
              return;
            debug('probe transport "%s" opened', name);
            transport.send([{
              type: 'ping',
              data: 'probe'
            }]);
            transport.once('packet', function(msg) {
              if (failed)
                return;
              if ('pong' == msg.type && 'probe' == msg.data) {
                debug('probe transport "%s" pong', name);
                self.upgrading = true;
                self.emit('upgrading', transport);
                if (!transport)
                  return;
                Socket.priorWebsocketSuccess = 'websocket' == transport.name;
                debug('pausing current transport "%s"', self.transport.name);
                self.transport.pause(function() {
                  if (failed)
                    return;
                  if ('closed' == self.readyState)
                    return;
                  debug('changing transport and sending upgrade packet');
                  cleanup();
                  self.setTransport(transport);
                  transport.send([{type: 'upgrade'}]);
                  self.emit('upgrade', transport);
                  transport = null;
                  self.upgrading = false;
                  self.flush();
                });
              } else {
                debug('probe transport "%s" failed', name);
                var err = new Error('probe error');
                err.transport = transport.name;
                self.emit('upgradeError', err);
              }
            });
          }
          function freezeTransport() {
            if (failed)
              return;
            failed = true;
            cleanup();
            transport.close();
            transport = null;
          }
          function onerror(err) {
            var error = new Error('probe error: ' + err);
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            self.emit('upgradeError', error);
          }
          function onTransportClose() {
            onerror("transport closed");
          }
          function onclose() {
            onerror("socket closed");
          }
          function onupgrade(to) {
            if (transport && to.name != transport.name) {
              debug('"%s" works - aborting "%s"', to.name, transport.name);
              freezeTransport();
            }
          }
          function cleanup() {
            transport.removeListener('open', onTransportOpen);
            transport.removeListener('error', onerror);
            transport.removeListener('close', onTransportClose);
            self.removeListener('close', onclose);
            self.removeListener('upgrading', onupgrade);
          }
          transport.once('open', onTransportOpen);
          transport.once('error', onerror);
          transport.once('close', onTransportClose);
          this.once('close', onclose);
          this.once('upgrading', onupgrade);
          transport.open();
        };
        Socket.prototype.onOpen = function() {
          debug('socket open');
          this.readyState = 'open';
          Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
          this.emit('open');
          this.flush();
          if ('open' == this.readyState && this.upgrade && this.transport.pause) {
            debug('starting upgrade probes');
            for (var i = 0,
                l = this.upgrades.length; i < l; i++) {
              this.probe(this.upgrades[i]);
            }
          }
        };
        Socket.prototype.onPacket = function(packet) {
          if ('opening' == this.readyState || 'open' == this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emit('packet', packet);
            this.emit('heartbeat');
            switch (packet.type) {
              case 'open':
                this.onHandshake(parsejson(packet.data));
                break;
              case 'pong':
                this.setPing();
                break;
              case 'error':
                var err = new Error('server error');
                err.code = packet.data;
                this.emit('error', err);
                break;
              case 'message':
                this.emit('data', packet.data);
                this.emit('message', packet.data);
                break;
            }
          } else {
            debug('packet received with socket readyState "%s"', this.readyState);
          }
        };
        Socket.prototype.onHandshake = function(data) {
          this.emit('handshake', data);
          this.id = data.sid;
          this.transport.query.sid = data.sid;
          this.upgrades = this.filterUpgrades(data.upgrades);
          this.pingInterval = data.pingInterval;
          this.pingTimeout = data.pingTimeout;
          this.onOpen();
          if ('closed' == this.readyState)
            return;
          this.setPing();
          this.removeListener('heartbeat', this.onHeartbeat);
          this.on('heartbeat', this.onHeartbeat);
        };
        Socket.prototype.onHeartbeat = function(timeout) {
          clearTimeout(this.pingTimeoutTimer);
          var self = this;
          self.pingTimeoutTimer = setTimeout(function() {
            if ('closed' == self.readyState)
              return;
            self.onClose('ping timeout');
          }, timeout || (self.pingInterval + self.pingTimeout));
        };
        Socket.prototype.setPing = function() {
          var self = this;
          clearTimeout(self.pingIntervalTimer);
          self.pingIntervalTimer = setTimeout(function() {
            debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
            self.ping();
            self.onHeartbeat(self.pingTimeout);
          }, self.pingInterval);
        };
        Socket.prototype.ping = function() {
          this.sendPacket('ping');
        };
        Socket.prototype.onDrain = function() {
          for (var i = 0; i < this.prevBufferLen; i++) {
            if (this.callbackBuffer[i]) {
              this.callbackBuffer[i]();
            }
          }
          this.writeBuffer.splice(0, this.prevBufferLen);
          this.callbackBuffer.splice(0, this.prevBufferLen);
          this.prevBufferLen = 0;
          if (this.writeBuffer.length == 0) {
            this.emit('drain');
          } else {
            this.flush();
          }
        };
        Socket.prototype.flush = function() {
          if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            debug('flushing %d packets in socket', this.writeBuffer.length);
            this.transport.send(this.writeBuffer);
            this.prevBufferLen = this.writeBuffer.length;
            this.emit('flush');
          }
        };
        Socket.prototype.write = Socket.prototype.send = function(msg, fn) {
          this.sendPacket('message', msg, fn);
          return this;
        };
        Socket.prototype.sendPacket = function(type, data, fn) {
          if ('closing' == this.readyState || 'closed' == this.readyState) {
            return;
          }
          var packet = {
            type: type,
            data: data
          };
          this.emit('packetCreate', packet);
          this.writeBuffer.push(packet);
          this.callbackBuffer.push(fn);
          this.flush();
        };
        Socket.prototype.close = function() {
          if ('opening' == this.readyState || 'open' == this.readyState) {
            this.readyState = 'closing';
            var self = this;
            function close() {
              self.onClose('forced close');
              debug('socket closing - telling transport to close');
              self.transport.close();
            }
            function cleanupAndClose() {
              self.removeListener('upgrade', cleanupAndClose);
              self.removeListener('upgradeError', cleanupAndClose);
              close();
            }
            function waitForUpgrade() {
              self.once('upgrade', cleanupAndClose);
              self.once('upgradeError', cleanupAndClose);
            }
            if (this.writeBuffer.length) {
              this.once('drain', function() {
                if (this.upgrading) {
                  waitForUpgrade();
                } else {
                  close();
                }
              });
            } else if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          }
          return this;
        };
        Socket.prototype.onError = function(err) {
          debug('socket error %j', err);
          Socket.priorWebsocketSuccess = false;
          this.emit('error', err);
          this.onClose('transport error', err);
        };
        Socket.prototype.onClose = function(reason, desc) {
          if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
            debug('socket close with reason: "%s"', reason);
            var self = this;
            clearTimeout(this.pingIntervalTimer);
            clearTimeout(this.pingTimeoutTimer);
            setTimeout(function() {
              self.writeBuffer = [];
              self.callbackBuffer = [];
              self.prevBufferLen = 0;
            }, 0);
            this.transport.removeAllListeners('close');
            this.transport.close();
            this.transport.removeAllListeners();
            this.readyState = 'closed';
            this.id = null;
            this.emit('close', reason, desc);
          }
        };
        Socket.prototype.filterUpgrades = function(upgrades) {
          var filteredUpgrades = [];
          for (var i = 0,
              j = upgrades.length; i < j; i++) {
            if (~index(this.transports, upgrades[i]))
              filteredUpgrades.push(upgrades[i]);
          }
          return filteredUpgrades;
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./transport": 14,
      "./transports": 15,
      "component-emitter": 9,
      "debug": 22,
      "engine.io-parser": 25,
      "indexof": 40,
      "parsejson": 32,
      "parseqs": 33,
      "parseuri": 34
    }],
    14: [function(_dereq_, module, exports) {
      var parser = _dereq_('engine.io-parser');
      var Emitter = _dereq_('component-emitter');
      module.exports = Transport;
      function Transport(opts) {
        this.path = opts.path;
        this.hostname = opts.hostname;
        this.port = opts.port;
        this.secure = opts.secure;
        this.query = opts.query;
        this.timestampParam = opts.timestampParam;
        this.timestampRequests = opts.timestampRequests;
        this.readyState = '';
        this.agent = opts.agent || false;
        this.socket = opts.socket;
        this.enablesXDR = opts.enablesXDR;
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
      }
      Emitter(Transport.prototype);
      Transport.timestamps = 0;
      Transport.prototype.onError = function(msg, desc) {
        var err = new Error(msg);
        err.type = 'TransportError';
        err.description = desc;
        this.emit('error', err);
        return this;
      };
      Transport.prototype.open = function() {
        if ('closed' == this.readyState || '' == this.readyState) {
          this.readyState = 'opening';
          this.doOpen();
        }
        return this;
      };
      Transport.prototype.close = function() {
        if ('opening' == this.readyState || 'open' == this.readyState) {
          this.doClose();
          this.onClose();
        }
        return this;
      };
      Transport.prototype.send = function(packets) {
        if ('open' == this.readyState) {
          this.write(packets);
        } else {
          throw new Error('Transport not open');
        }
      };
      Transport.prototype.onOpen = function() {
        this.readyState = 'open';
        this.writable = true;
        this.emit('open');
      };
      Transport.prototype.onData = function(data) {
        var packet = parser.decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
      };
      Transport.prototype.onPacket = function(packet) {
        this.emit('packet', packet);
      };
      Transport.prototype.onClose = function() {
        this.readyState = 'closed';
        this.emit('close');
      };
    }, {
      "component-emitter": 9,
      "engine.io-parser": 25
    }],
    15: [function(_dereq_, module, exports) {
      (function(global) {
        var XMLHttpRequest = _dereq_('xmlhttprequest');
        var XHR = _dereq_('./polling-xhr');
        var JSONP = _dereq_('./polling-jsonp');
        var websocket = _dereq_('./websocket');
        exports.polling = polling;
        exports.websocket = websocket;
        function polling(opts) {
          var xhr;
          var xd = false;
          var xs = false;
          var jsonp = false !== opts.jsonp;
          if (global.location) {
            var isSSL = 'https:' == location.protocol;
            var port = location.port;
            if (!port) {
              port = isSSL ? 443 : 80;
            }
            xd = opts.hostname != location.hostname || port != opts.port;
            xs = opts.secure != isSSL;
          }
          opts.xdomain = xd;
          opts.xscheme = xs;
          xhr = new XMLHttpRequest(opts);
          if ('open' in xhr && !opts.forceJSONP) {
            return new XHR(opts);
          } else {
            if (!jsonp)
              throw new Error('JSONP disabled');
            return new JSONP(opts);
          }
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./polling-jsonp": 16,
      "./polling-xhr": 17,
      "./websocket": 19,
      "xmlhttprequest": 20
    }],
    16: [function(_dereq_, module, exports) {
      (function(global) {
        var Polling = _dereq_('./polling');
        var inherit = _dereq_('component-inherit');
        module.exports = JSONPPolling;
        var rNewline = /\n/g;
        var rEscapedNewline = /\\n/g;
        var callbacks;
        var index = 0;
        function empty() {}
        function JSONPPolling(opts) {
          Polling.call(this, opts);
          this.query = this.query || {};
          if (!callbacks) {
            if (!global.___eio)
              global.___eio = [];
            callbacks = global.___eio;
          }
          this.index = callbacks.length;
          var self = this;
          callbacks.push(function(msg) {
            self.onData(msg);
          });
          this.query.j = this.index;
          if (global.document && global.addEventListener) {
            global.addEventListener('beforeunload', function() {
              if (self.script)
                self.script.onerror = empty;
            }, false);
          }
        }
        inherit(JSONPPolling, Polling);
        JSONPPolling.prototype.supportsBinary = false;
        JSONPPolling.prototype.doClose = function() {
          if (this.script) {
            this.script.parentNode.removeChild(this.script);
            this.script = null;
          }
          if (this.form) {
            this.form.parentNode.removeChild(this.form);
            this.form = null;
            this.iframe = null;
          }
          Polling.prototype.doClose.call(this);
        };
        JSONPPolling.prototype.doPoll = function() {
          var self = this;
          var script = document.createElement('script');
          if (this.script) {
            this.script.parentNode.removeChild(this.script);
            this.script = null;
          }
          script.async = true;
          script.src = this.uri();
          script.onerror = function(e) {
            self.onError('jsonp poll error', e);
          };
          var insertAt = document.getElementsByTagName('script')[0];
          insertAt.parentNode.insertBefore(script, insertAt);
          this.script = script;
          var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
          if (isUAgecko) {
            setTimeout(function() {
              var iframe = document.createElement('iframe');
              document.body.appendChild(iframe);
              document.body.removeChild(iframe);
            }, 100);
          }
        };
        JSONPPolling.prototype.doWrite = function(data, fn) {
          var self = this;
          if (!this.form) {
            var form = document.createElement('form');
            var area = document.createElement('textarea');
            var id = this.iframeId = 'eio_iframe_' + this.index;
            var iframe;
            form.className = 'socketio';
            form.style.position = 'absolute';
            form.style.top = '-1000px';
            form.style.left = '-1000px';
            form.target = id;
            form.method = 'POST';
            form.setAttribute('accept-charset', 'utf-8');
            area.name = 'd';
            form.appendChild(area);
            document.body.appendChild(form);
            this.form = form;
            this.area = area;
          }
          this.form.action = this.uri();
          function complete() {
            initIframe();
            fn();
          }
          function initIframe() {
            if (self.iframe) {
              try {
                self.form.removeChild(self.iframe);
              } catch (e) {
                self.onError('jsonp polling iframe removal error', e);
              }
            }
            try {
              var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
              iframe = document.createElement(html);
            } catch (e) {
              iframe = document.createElement('iframe');
              iframe.name = self.iframeId;
              iframe.src = 'javascript:0';
            }
            iframe.id = self.iframeId;
            self.form.appendChild(iframe);
            self.iframe = iframe;
          }
          initIframe();
          data = data.replace(rEscapedNewline, '\\\n');
          this.area.value = data.replace(rNewline, '\\n');
          try {
            this.form.submit();
          } catch (e) {}
          if (this.iframe.attachEvent) {
            this.iframe.onreadystatechange = function() {
              if (self.iframe.readyState == 'complete') {
                complete();
              }
            };
          } else {
            this.iframe.onload = complete;
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./polling": 18,
      "component-inherit": 21
    }],
    17: [function(_dereq_, module, exports) {
      (function(global) {
        var XMLHttpRequest = _dereq_('xmlhttprequest');
        var Polling = _dereq_('./polling');
        var Emitter = _dereq_('component-emitter');
        var inherit = _dereq_('component-inherit');
        var debug = _dereq_('debug')('engine.io-client:polling-xhr');
        module.exports = XHR;
        module.exports.Request = Request;
        function empty() {}
        function XHR(opts) {
          Polling.call(this, opts);
          if (global.location) {
            var isSSL = 'https:' == location.protocol;
            var port = location.port;
            if (!port) {
              port = isSSL ? 443 : 80;
            }
            this.xd = opts.hostname != global.location.hostname || port != opts.port;
            this.xs = opts.secure != isSSL;
          }
        }
        inherit(XHR, Polling);
        XHR.prototype.supportsBinary = true;
        XHR.prototype.request = function(opts) {
          opts = opts || {};
          opts.uri = this.uri();
          opts.xd = this.xd;
          opts.xs = this.xs;
          opts.agent = this.agent || false;
          opts.supportsBinary = this.supportsBinary;
          opts.enablesXDR = this.enablesXDR;
          opts.pfx = this.pfx;
          opts.key = this.key;
          opts.passphrase = this.passphrase;
          opts.cert = this.cert;
          opts.ca = this.ca;
          opts.ciphers = this.ciphers;
          opts.rejectUnauthorized = this.rejectUnauthorized;
          return new Request(opts);
        };
        XHR.prototype.doWrite = function(data, fn) {
          var isBinary = typeof data !== 'string' && data !== undefined;
          var req = this.request({
            method: 'POST',
            data: data,
            isBinary: isBinary
          });
          var self = this;
          req.on('success', fn);
          req.on('error', function(err) {
            self.onError('xhr post error', err);
          });
          this.sendXhr = req;
        };
        XHR.prototype.doPoll = function() {
          debug('xhr poll');
          var req = this.request();
          var self = this;
          req.on('data', function(data) {
            self.onData(data);
          });
          req.on('error', function(err) {
            self.onError('xhr poll error', err);
          });
          this.pollXhr = req;
        };
        function Request(opts) {
          this.method = opts.method || 'GET';
          this.uri = opts.uri;
          this.xd = !!opts.xd;
          this.xs = !!opts.xs;
          this.async = false !== opts.async;
          this.data = undefined != opts.data ? opts.data : null;
          this.agent = opts.agent;
          this.isBinary = opts.isBinary;
          this.supportsBinary = opts.supportsBinary;
          this.enablesXDR = opts.enablesXDR;
          this.pfx = opts.pfx;
          this.key = opts.key;
          this.passphrase = opts.passphrase;
          this.cert = opts.cert;
          this.ca = opts.ca;
          this.ciphers = opts.ciphers;
          this.rejectUnauthorized = opts.rejectUnauthorized;
          this.create();
        }
        Emitter(Request.prototype);
        Request.prototype.create = function() {
          var opts = {
            agent: this.agent,
            xdomain: this.xd,
            xscheme: this.xs,
            enablesXDR: this.enablesXDR
          };
          opts.pfx = this.pfx;
          opts.key = this.key;
          opts.passphrase = this.passphrase;
          opts.cert = this.cert;
          opts.ca = this.ca;
          opts.ciphers = this.ciphers;
          opts.rejectUnauthorized = this.rejectUnauthorized;
          var xhr = this.xhr = new XMLHttpRequest(opts);
          var self = this;
          try {
            debug('xhr open %s: %s', this.method, this.uri);
            xhr.open(this.method, this.uri, this.async);
            if (this.supportsBinary) {
              xhr.responseType = 'arraybuffer';
            }
            if ('POST' == this.method) {
              try {
                if (this.isBinary) {
                  xhr.setRequestHeader('Content-type', 'application/octet-stream');
                } else {
                  xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                }
              } catch (e) {}
            }
            if ('withCredentials' in xhr) {
              xhr.withCredentials = true;
            }
            if (this.hasXDR()) {
              xhr.onload = function() {
                self.onLoad();
              };
              xhr.onerror = function() {
                self.onError(xhr.responseText);
              };
            } else {
              xhr.onreadystatechange = function() {
                if (4 != xhr.readyState)
                  return;
                if (200 == xhr.status || 1223 == xhr.status) {
                  self.onLoad();
                } else {
                  setTimeout(function() {
                    self.onError(xhr.status);
                  }, 0);
                }
              };
            }
            debug('xhr data %s', this.data);
            xhr.send(this.data);
          } catch (e) {
            setTimeout(function() {
              self.onError(e);
            }, 0);
            return;
          }
          if (global.document) {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
          }
        };
        Request.prototype.onSuccess = function() {
          this.emit('success');
          this.cleanup();
        };
        Request.prototype.onData = function(data) {
          this.emit('data', data);
          this.onSuccess();
        };
        Request.prototype.onError = function(err) {
          this.emit('error', err);
          this.cleanup(true);
        };
        Request.prototype.cleanup = function(fromError) {
          if ('undefined' == typeof this.xhr || null === this.xhr) {
            return;
          }
          if (this.hasXDR()) {
            this.xhr.onload = this.xhr.onerror = empty;
          } else {
            this.xhr.onreadystatechange = empty;
          }
          if (fromError) {
            try {
              this.xhr.abort();
            } catch (e) {}
          }
          if (global.document) {
            delete Request.requests[this.index];
          }
          this.xhr = null;
        };
        Request.prototype.onLoad = function() {
          var data;
          try {
            var contentType;
            try {
              contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
            } catch (e) {}
            if (contentType === 'application/octet-stream') {
              data = this.xhr.response;
            } else {
              if (!this.supportsBinary) {
                data = this.xhr.responseText;
              } else {
                data = 'ok';
              }
            }
          } catch (e) {
            this.onError(e);
          }
          if (null != data) {
            this.onData(data);
          }
        };
        Request.prototype.hasXDR = function() {
          return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
        };
        Request.prototype.abort = function() {
          this.cleanup();
        };
        if (global.document) {
          Request.requestsCount = 0;
          Request.requests = {};
          if (global.attachEvent) {
            global.attachEvent('onunload', unloadHandler);
          } else if (global.addEventListener) {
            global.addEventListener('beforeunload', unloadHandler, false);
          }
        }
        function unloadHandler() {
          for (var i in Request.requests) {
            if (Request.requests.hasOwnProperty(i)) {
              Request.requests[i].abort();
            }
          }
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./polling": 18,
      "component-emitter": 9,
      "component-inherit": 21,
      "debug": 22,
      "xmlhttprequest": 20
    }],
    18: [function(_dereq_, module, exports) {
      var Transport = _dereq_('../transport');
      var parseqs = _dereq_('parseqs');
      var parser = _dereq_('engine.io-parser');
      var inherit = _dereq_('component-inherit');
      var debug = _dereq_('debug')('engine.io-client:polling');
      module.exports = Polling;
      var hasXHR2 = (function() {
        var XMLHttpRequest = _dereq_('xmlhttprequest');
        var xhr = new XMLHttpRequest({xdomain: false});
        return null != xhr.responseType;
      })();
      function Polling(opts) {
        var forceBase64 = (opts && opts.forceBase64);
        if (!hasXHR2 || forceBase64) {
          this.supportsBinary = false;
        }
        Transport.call(this, opts);
      }
      inherit(Polling, Transport);
      Polling.prototype.name = 'polling';
      Polling.prototype.doOpen = function() {
        this.poll();
      };
      Polling.prototype.pause = function(onPause) {
        var pending = 0;
        var self = this;
        this.readyState = 'pausing';
        function pause() {
          debug('paused');
          self.readyState = 'paused';
          onPause();
        }
        if (this.polling || !this.writable) {
          var total = 0;
          if (this.polling) {
            debug('we are currently polling - waiting to pause');
            total++;
            this.once('pollComplete', function() {
              debug('pre-pause polling complete');
              --total || pause();
            });
          }
          if (!this.writable) {
            debug('we are currently writing - waiting to pause');
            total++;
            this.once('drain', function() {
              debug('pre-pause writing complete');
              --total || pause();
            });
          }
        } else {
          pause();
        }
      };
      Polling.prototype.poll = function() {
        debug('polling');
        this.polling = true;
        this.doPoll();
        this.emit('poll');
      };
      Polling.prototype.onData = function(data) {
        var self = this;
        debug('polling got data %s', data);
        var callback = function(packet, index, total) {
          if ('opening' == self.readyState) {
            self.onOpen();
          }
          if ('close' == packet.type) {
            self.onClose();
            return false;
          }
          self.onPacket(packet);
        };
        parser.decodePayload(data, this.socket.binaryType, callback);
        if ('closed' != this.readyState) {
          this.polling = false;
          this.emit('pollComplete');
          if ('open' == this.readyState) {
            this.poll();
          } else {
            debug('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      };
      Polling.prototype.doClose = function() {
        var self = this;
        function close() {
          debug('writing close packet');
          self.write([{type: 'close'}]);
        }
        if ('open' == this.readyState) {
          debug('transport open - closing');
          close();
        } else {
          debug('transport not open - deferring close');
          this.once('open', close);
        }
      };
      Polling.prototype.write = function(packets) {
        var self = this;
        this.writable = false;
        var callbackfn = function() {
          self.writable = true;
          self.emit('drain');
        };
        var self = this;
        parser.encodePayload(packets, this.supportsBinary, function(data) {
          self.doWrite(data, callbackfn);
        });
      };
      Polling.prototype.uri = function() {
        var query = this.query || {};
        var schema = this.secure ? 'https' : 'http';
        var port = '';
        if (false !== this.timestampRequests) {
          query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);
        if (this.port && (('https' == schema && this.port != 443) || ('http' == schema && this.port != 80))) {
          port = ':' + this.port;
        }
        if (query.length) {
          query = '?' + query;
        }
        return schema + '://' + this.hostname + port + this.path + query;
      };
    }, {
      "../transport": 14,
      "component-inherit": 21,
      "debug": 22,
      "engine.io-parser": 25,
      "parseqs": 33,
      "xmlhttprequest": 20
    }],
    19: [function(_dereq_, module, exports) {
      var Transport = _dereq_('../transport');
      var parser = _dereq_('engine.io-parser');
      var parseqs = _dereq_('parseqs');
      var inherit = _dereq_('component-inherit');
      var debug = _dereq_('debug')('engine.io-client:websocket');
      var WebSocket = _dereq_('ws');
      module.exports = WS;
      function WS(opts) {
        var forceBase64 = (opts && opts.forceBase64);
        if (forceBase64) {
          this.supportsBinary = false;
        }
        Transport.call(this, opts);
      }
      inherit(WS, Transport);
      WS.prototype.name = 'websocket';
      WS.prototype.supportsBinary = true;
      WS.prototype.doOpen = function() {
        if (!this.check()) {
          return;
        }
        var self = this;
        var uri = this.uri();
        var protocols = void(0);
        var opts = {agent: this.agent};
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        this.ws = new WebSocket(uri, protocols, opts);
        if (this.ws.binaryType === undefined) {
          this.supportsBinary = false;
        }
        this.ws.binaryType = 'arraybuffer';
        this.addEventListeners();
      };
      WS.prototype.addEventListeners = function() {
        var self = this;
        this.ws.onopen = function() {
          self.onOpen();
        };
        this.ws.onclose = function() {
          self.onClose();
        };
        this.ws.onmessage = function(ev) {
          self.onData(ev.data);
        };
        this.ws.onerror = function(e) {
          self.onError('websocket error', e);
        };
      };
      if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
        WS.prototype.onData = function(data) {
          var self = this;
          setTimeout(function() {
            Transport.prototype.onData.call(self, data);
          }, 0);
        };
      }
      WS.prototype.write = function(packets) {
        var self = this;
        this.writable = false;
        for (var i = 0,
            l = packets.length; i < l; i++) {
          parser.encodePacket(packets[i], this.supportsBinary, function(data) {
            try {
              self.ws.send(data);
            } catch (e) {
              debug('websocket closed before onclose event');
            }
          });
        }
        function ondrain() {
          self.writable = true;
          self.emit('drain');
        }
        setTimeout(ondrain, 0);
      };
      WS.prototype.onClose = function() {
        Transport.prototype.onClose.call(this);
      };
      WS.prototype.doClose = function() {
        if (typeof this.ws !== 'undefined') {
          this.ws.close();
        }
      };
      WS.prototype.uri = function() {
        var query = this.query || {};
        var schema = this.secure ? 'wss' : 'ws';
        var port = '';
        if (this.port && (('wss' == schema && this.port != 443) || ('ws' == schema && this.port != 80))) {
          port = ':' + this.port;
        }
        if (this.timestampRequests) {
          query[this.timestampParam] = +new Date;
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);
        if (query.length) {
          query = '?' + query;
        }
        return schema + '://' + this.hostname + port + this.path + query;
      };
      WS.prototype.check = function() {
        return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
      };
    }, {
      "../transport": 14,
      "component-inherit": 21,
      "debug": 22,
      "engine.io-parser": 25,
      "parseqs": 33,
      "ws": 35
    }],
    20: [function(_dereq_, module, exports) {
      var hasCORS = _dereq_('has-cors');
      module.exports = function(opts) {
        var xdomain = opts.xdomain;
        var xscheme = opts.xscheme;
        var enablesXDR = opts.enablesXDR;
        try {
          if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}
        try {
          if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {}
        if (!xdomain) {
          try {
            return new ActiveXObject('Microsoft.XMLHTTP');
          } catch (e) {}
        }
      };
    }, {"has-cors": 38}],
    21: [function(_dereq_, module, exports) {
      module.exports = function(a, b) {
        var fn = function() {};
        fn.prototype = b.prototype;
        a.prototype = new fn;
        a.prototype.constructor = a;
      };
    }, {}],
    22: [function(_dereq_, module, exports) {
      exports = module.exports = _dereq_('./debug');
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
      function useColors() {
        return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
      }
      exports.formatters.j = function(v) {
        return JSON.stringify(v);
      };
      function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
        if (!useColors)
          return args;
        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
          if ('%%' === match)
            return;
          index++;
          if ('%c' === match) {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
        return args;
      }
      function log() {
        return 'object' == typeof console && 'function' == typeof console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (null == namespaces) {
            localStorage.removeItem('debug');
          } else {
            localStorage.debug = namespaces;
          }
        } catch (e) {}
      }
      function load() {
        var r;
        try {
          r = localStorage.debug;
        } catch (e) {}
        return r;
      }
      exports.enable(load());
    }, {"./debug": 23}],
    23: [function(_dereq_, module, exports) {
      exports = module.exports = debug;
      exports.coerce = coerce;
      exports.disable = disable;
      exports.enable = enable;
      exports.enabled = enabled;
      exports.humanize = _dereq_('ms');
      exports.names = [];
      exports.skips = [];
      exports.formatters = {};
      var prevColor = 0;
      var prevTime;
      function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length];
      }
      function debug(namespace) {
        function disabled() {}
        disabled.enabled = false;
        function enabled() {
          var self = enabled;
          var curr = +new Date();
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          if (null == self.useColors)
            self.useColors = exports.useColors();
          if (null == self.color && self.useColors)
            self.color = selectColor();
          var args = Array.prototype.slice.call(arguments);
          args[0] = exports.coerce(args[0]);
          if ('string' !== typeof args[0]) {
            args = ['%o'].concat(args);
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
            if (match === '%%')
              return match;
            index++;
            var formatter = exports.formatters[format];
            if ('function' === typeof formatter) {
              var val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          if ('function' === typeof exports.formatArgs) {
            args = exports.formatArgs.apply(self, args);
          }
          var logFn = enabled.log || exports.log || console.log.bind(console);
          logFn.apply(self, args);
        }
        enabled.enabled = true;
        var fn = exports.enabled(namespace) ? enabled : disabled;
        fn.namespace = namespace;
        return fn;
      }
      function enable(namespaces) {
        exports.save(namespaces);
        var split = (namespaces || '').split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
          if (!split[i])
            continue;
          namespaces = split[i].replace(/\*/g, '.*?');
          if (namespaces[0] === '-') {
            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            exports.names.push(new RegExp('^' + namespaces + '$'));
          }
        }
      }
      function disable() {
        exports.enable('');
      }
      function enabled(name) {
        var i,
            len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
          if (exports.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
          if (exports.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error)
          return val.stack || val.message;
        return val;
      }
    }, {"ms": 24}],
    24: [function(_dereq_, module, exports) {
      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        if ('string' == typeof val)
          return parse(val);
        return options.long ? long(val) : short(val);
      };
      function parse(str) {
        var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
        if (!match)
          return;
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
          case 'years':
          case 'year':
          case 'y':
            return n * y;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 's':
            return n * s;
          case 'ms':
            return n;
        }
      }
      function short(ms) {
        if (ms >= d)
          return Math.round(ms / d) + 'd';
        if (ms >= h)
          return Math.round(ms / h) + 'h';
        if (ms >= m)
          return Math.round(ms / m) + 'm';
        if (ms >= s)
          return Math.round(ms / s) + 's';
        return ms + 'ms';
      }
      function long(ms) {
        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
      }
      function plural(ms, n, name) {
        if (ms < n)
          return;
        if (ms < n * 1.5)
          return Math.floor(ms / n) + ' ' + name;
        return Math.ceil(ms / n) + ' ' + name + 's';
      }
    }, {}],
    25: [function(_dereq_, module, exports) {
      (function(global) {
        var keys = _dereq_('./keys');
        var hasBinary = _dereq_('has-binary');
        var sliceBuffer = _dereq_('arraybuffer.slice');
        var base64encoder = _dereq_('base64-arraybuffer');
        var after = _dereq_('after');
        var utf8 = _dereq_('utf8');
        var isAndroid = navigator.userAgent.match(/Android/i);
        var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
        var dontSendBlobs = isAndroid || isPhantomJS;
        exports.protocol = 3;
        var packets = exports.packets = {
          open: 0,
          close: 1,
          ping: 2,
          pong: 3,
          message: 4,
          upgrade: 5,
          noop: 6
        };
        var packetslist = keys(packets);
        var err = {
          type: 'error',
          data: 'parser error'
        };
        var Blob = _dereq_('blob');
        exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
          if ('function' == typeof supportsBinary) {
            callback = supportsBinary;
            supportsBinary = false;
          }
          if ('function' == typeof utf8encode) {
            callback = utf8encode;
            utf8encode = null;
          }
          var data = (packet.data === undefined) ? undefined : packet.data.buffer || packet.data;
          if (global.ArrayBuffer && data instanceof ArrayBuffer) {
            return encodeArrayBuffer(packet, supportsBinary, callback);
          } else if (Blob && data instanceof global.Blob) {
            return encodeBlob(packet, supportsBinary, callback);
          }
          if (data && data.base64) {
            return encodeBase64Object(packet, callback);
          }
          var encoded = packets[packet.type];
          if (undefined !== packet.data) {
            encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
          }
          return callback('' + encoded);
        };
        function encodeBase64Object(packet, callback) {
          var message = 'b' + exports.packets[packet.type] + packet.data.data;
          return callback(message);
        }
        function encodeArrayBuffer(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }
          var data = packet.data;
          var contentArray = new Uint8Array(data);
          var resultBuffer = new Uint8Array(1 + data.byteLength);
          resultBuffer[0] = packets[packet.type];
          for (var i = 0; i < contentArray.length; i++) {
            resultBuffer[i + 1] = contentArray[i];
          }
          return callback(resultBuffer.buffer);
        }
        function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }
          var fr = new FileReader();
          fr.onload = function() {
            packet.data = fr.result;
            exports.encodePacket(packet, supportsBinary, true, callback);
          };
          return fr.readAsArrayBuffer(packet.data);
        }
        function encodeBlob(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }
          if (dontSendBlobs) {
            return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
          }
          var length = new Uint8Array(1);
          length[0] = packets[packet.type];
          var blob = new Blob([length.buffer, packet.data]);
          return callback(blob);
        }
        exports.encodeBase64Packet = function(packet, callback) {
          var message = 'b' + exports.packets[packet.type];
          if (Blob && packet.data instanceof Blob) {
            var fr = new FileReader();
            fr.onload = function() {
              var b64 = fr.result.split(',')[1];
              callback(message + b64);
            };
            return fr.readAsDataURL(packet.data);
          }
          var b64data;
          try {
            b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
          } catch (e) {
            var typed = new Uint8Array(packet.data);
            var basic = new Array(typed.length);
            for (var i = 0; i < typed.length; i++) {
              basic[i] = typed[i];
            }
            b64data = String.fromCharCode.apply(null, basic);
          }
          message += global.btoa(b64data);
          return callback(message);
        };
        exports.decodePacket = function(data, binaryType, utf8decode) {
          if (typeof data == 'string' || data === undefined) {
            if (data.charAt(0) == 'b') {
              return exports.decodeBase64Packet(data.substr(1), binaryType);
            }
            if (utf8decode) {
              try {
                data = utf8.decode(data);
              } catch (e) {
                return err;
              }
            }
            var type = data.charAt(0);
            if (Number(type) != type || !packetslist[type]) {
              return err;
            }
            if (data.length > 1) {
              return {
                type: packetslist[type],
                data: data.substring(1)
              };
            } else {
              return {type: packetslist[type]};
            }
          }
          var asArray = new Uint8Array(data);
          var type = asArray[0];
          var rest = sliceBuffer(data, 1);
          if (Blob && binaryType === 'blob') {
            rest = new Blob([rest]);
          }
          return {
            type: packetslist[type],
            data: rest
          };
        };
        exports.decodeBase64Packet = function(msg, binaryType) {
          var type = packetslist[msg.charAt(0)];
          if (!global.ArrayBuffer) {
            return {
              type: type,
              data: {
                base64: true,
                data: msg.substr(1)
              }
            };
          }
          var data = base64encoder.decode(msg.substr(1));
          if (binaryType === 'blob' && Blob) {
            data = new Blob([data]);
          }
          return {
            type: type,
            data: data
          };
        };
        exports.encodePayload = function(packets, supportsBinary, callback) {
          if (typeof supportsBinary == 'function') {
            callback = supportsBinary;
            supportsBinary = null;
          }
          var isBinary = hasBinary(packets);
          if (supportsBinary && isBinary) {
            if (Blob && !dontSendBlobs) {
              return exports.encodePayloadAsBlob(packets, callback);
            }
            return exports.encodePayloadAsArrayBuffer(packets, callback);
          }
          if (!packets.length) {
            return callback('0:');
          }
          function setLengthHeader(message) {
            return message.length + ':' + message;
          }
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
              doneCallback(null, setLengthHeader(message));
            });
          }
          map(packets, encodeOne, function(err, results) {
            return callback(results.join(''));
          });
        };
        function map(ary, each, done) {
          var result = new Array(ary.length);
          var next = after(ary.length, done);
          var eachWithIndex = function(i, el, cb) {
            each(el, function(error, msg) {
              result[i] = msg;
              cb(error, result);
            });
          };
          for (var i = 0; i < ary.length; i++) {
            eachWithIndex(i, ary[i], next);
          }
        }
        exports.decodePayload = function(data, binaryType, callback) {
          if (typeof data != 'string') {
            return exports.decodePayloadAsBinary(data, binaryType, callback);
          }
          if (typeof binaryType === 'function') {
            callback = binaryType;
            binaryType = null;
          }
          var packet;
          if (data == '') {
            return callback(err, 0, 1);
          }
          var length = '',
              n,
              msg;
          for (var i = 0,
              l = data.length; i < l; i++) {
            var chr = data.charAt(i);
            if (':' != chr) {
              length += chr;
            } else {
              if ('' == length || (length != (n = Number(length)))) {
                return callback(err, 0, 1);
              }
              msg = data.substr(i + 1, n);
              if (length != msg.length) {
                return callback(err, 0, 1);
              }
              if (msg.length) {
                packet = exports.decodePacket(msg, binaryType, true);
                if (err.type == packet.type && err.data == packet.data) {
                  return callback(err, 0, 1);
                }
                var ret = callback(packet, i + n, l);
                if (false === ret)
                  return;
              }
              i += n;
              length = '';
            }
          }
          if (length != '') {
            return callback(err, 0, 1);
          }
        };
        exports.encodePayloadAsArrayBuffer = function(packets, callback) {
          if (!packets.length) {
            return callback(new ArrayBuffer(0));
          }
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, true, true, function(data) {
              return doneCallback(null, data);
            });
          }
          map(packets, encodeOne, function(err, encodedPackets) {
            var totalLength = encodedPackets.reduce(function(acc, p) {
              var len;
              if (typeof p === 'string') {
                len = p.length;
              } else {
                len = p.byteLength;
              }
              return acc + len.toString().length + len + 2;
            }, 0);
            var resultArray = new Uint8Array(totalLength);
            var bufferIndex = 0;
            encodedPackets.forEach(function(p) {
              var isString = typeof p === 'string';
              var ab = p;
              if (isString) {
                var view = new Uint8Array(p.length);
                for (var i = 0; i < p.length; i++) {
                  view[i] = p.charCodeAt(i);
                }
                ab = view.buffer;
              }
              if (isString) {
                resultArray[bufferIndex++] = 0;
              } else {
                resultArray[bufferIndex++] = 1;
              }
              var lenStr = ab.byteLength.toString();
              for (var i = 0; i < lenStr.length; i++) {
                resultArray[bufferIndex++] = parseInt(lenStr[i]);
              }
              resultArray[bufferIndex++] = 255;
              var view = new Uint8Array(ab);
              for (var i = 0; i < view.length; i++) {
                resultArray[bufferIndex++] = view[i];
              }
            });
            return callback(resultArray.buffer);
          });
        };
        exports.encodePayloadAsBlob = function(packets, callback) {
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, true, true, function(encoded) {
              var binaryIdentifier = new Uint8Array(1);
              binaryIdentifier[0] = 1;
              if (typeof encoded === 'string') {
                var view = new Uint8Array(encoded.length);
                for (var i = 0; i < encoded.length; i++) {
                  view[i] = encoded.charCodeAt(i);
                }
                encoded = view.buffer;
                binaryIdentifier[0] = 0;
              }
              var len = (encoded instanceof ArrayBuffer) ? encoded.byteLength : encoded.size;
              var lenStr = len.toString();
              var lengthAry = new Uint8Array(lenStr.length + 1);
              for (var i = 0; i < lenStr.length; i++) {
                lengthAry[i] = parseInt(lenStr[i]);
              }
              lengthAry[lenStr.length] = 255;
              if (Blob) {
                var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
                doneCallback(null, blob);
              }
            });
          }
          map(packets, encodeOne, function(err, results) {
            return callback(new Blob(results));
          });
        };
        exports.decodePayloadAsBinary = function(data, binaryType, callback) {
          if (typeof binaryType === 'function') {
            callback = binaryType;
            binaryType = null;
          }
          var bufferTail = data;
          var buffers = [];
          var numberTooLong = false;
          while (bufferTail.byteLength > 0) {
            var tailArray = new Uint8Array(bufferTail);
            var isString = tailArray[0] === 0;
            var msgLength = '';
            for (var i = 1; ; i++) {
              if (tailArray[i] == 255)
                break;
              if (msgLength.length > 310) {
                numberTooLong = true;
                break;
              }
              msgLength += tailArray[i];
            }
            if (numberTooLong)
              return callback(err, 0, 1);
            bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
            msgLength = parseInt(msgLength);
            var msg = sliceBuffer(bufferTail, 0, msgLength);
            if (isString) {
              try {
                msg = String.fromCharCode.apply(null, new Uint8Array(msg));
              } catch (e) {
                var typed = new Uint8Array(msg);
                msg = '';
                for (var i = 0; i < typed.length; i++) {
                  msg += String.fromCharCode(typed[i]);
                }
              }
            }
            buffers.push(msg);
            bufferTail = sliceBuffer(bufferTail, msgLength);
          }
          var total = buffers.length;
          buffers.forEach(function(buffer, i) {
            callback(exports.decodePacket(buffer, binaryType, true), i, total);
          });
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./keys": 26,
      "after": 27,
      "arraybuffer.slice": 28,
      "base64-arraybuffer": 29,
      "blob": 30,
      "has-binary": 36,
      "utf8": 31
    }],
    26: [function(_dereq_, module, exports) {
      module.exports = Object.keys || function keys(obj) {
        var arr = [];
        var has = Object.prototype.hasOwnProperty;
        for (var i in obj) {
          if (has.call(obj, i)) {
            arr.push(i);
          }
        }
        return arr;
      };
    }, {}],
    27: [function(_dereq_, module, exports) {
      module.exports = after;
      function after(count, callback, err_cb) {
        var bail = false;
        err_cb = err_cb || noop;
        proxy.count = count;
        return (count === 0) ? callback() : proxy;
        function proxy(err, result) {
          if (proxy.count <= 0) {
            throw new Error('after called too many times');
          }
          --proxy.count;
          if (err) {
            bail = true;
            callback(err);
            callback = err_cb;
          } else if (proxy.count === 0 && !bail) {
            callback(null, result);
          }
        }
      }
      function noop() {}
    }, {}],
    28: [function(_dereq_, module, exports) {
      module.exports = function(arraybuffer, start, end) {
        var bytes = arraybuffer.byteLength;
        start = start || 0;
        end = end || bytes;
        if (arraybuffer.slice) {
          return arraybuffer.slice(start, end);
        }
        if (start < 0) {
          start += bytes;
        }
        if (end < 0) {
          end += bytes;
        }
        if (end > bytes) {
          end = bytes;
        }
        if (start >= bytes || start >= end || bytes === 0) {
          return new ArrayBuffer(0);
        }
        var abv = new Uint8Array(arraybuffer);
        var result = new Uint8Array(end - start);
        for (var i = start,
            ii = 0; i < end; i++, ii++) {
          result[ii] = abv[i];
        }
        return result.buffer;
      };
    }, {}],
    29: [function(_dereq_, module, exports) {
      (function(chars) {
        "use strict";
        exports.encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer),
              i,
              len = bytes.length,
              base64 = "";
          for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
            base64 += chars[bytes[i + 2] & 63];
          }
          if ((len % 3) === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        exports.decode = function(base64) {
          var bufferLength = base64.length * 0.75,
              len = base64.length,
              i,
              p = 0,
              encoded1,
              encoded2,
              encoded3,
              encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength),
              bytes = new Uint8Array(arraybuffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i + 1]);
            encoded3 = chars.indexOf(base64[i + 2]);
            encoded4 = chars.indexOf(base64[i + 3]);
            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
          }
          return arraybuffer;
        };
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    }, {}],
    30: [function(_dereq_, module, exports) {
      (function(global) {
        var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
        var blobSupported = (function() {
          try {
            var a = new Blob(['hi']);
            return a.size === 2;
          } catch (e) {
            return false;
          }
        })();
        var blobSupportsArrayBufferView = blobSupported && (function() {
          try {
            var b = new Blob([new Uint8Array([1, 2])]);
            return b.size === 2;
          } catch (e) {
            return false;
          }
        })();
        var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
        function mapArrayBufferViews(ary) {
          for (var i = 0; i < ary.length; i++) {
            var chunk = ary[i];
            if (chunk.buffer instanceof ArrayBuffer) {
              var buf = chunk.buffer;
              if (chunk.byteLength !== buf.byteLength) {
                var copy = new Uint8Array(chunk.byteLength);
                copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
                buf = copy.buffer;
              }
              ary[i] = buf;
            }
          }
        }
        function BlobBuilderConstructor(ary, options) {
          options = options || {};
          var bb = new BlobBuilder();
          mapArrayBufferViews(ary);
          for (var i = 0; i < ary.length; i++) {
            bb.append(ary[i]);
          }
          return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
        }
        ;
        function BlobConstructor(ary, options) {
          mapArrayBufferViews(ary);
          return new Blob(ary, options || {});
        }
        ;
        module.exports = (function() {
          if (blobSupported) {
            return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
          } else if (blobBuilderSupported) {
            return BlobBuilderConstructor;
          } else {
            return undefined;
          }
        })();
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    31: [function(_dereq_, module, exports) {
      (function(global) {
        ;
        (function(root) {
          var freeExports = typeof exports == 'object' && exports;
          var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
          var freeGlobal = typeof global == 'object' && global;
          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
            root = freeGlobal;
          }
          var stringFromCharCode = String.fromCharCode;
          function ucs2decode(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            var value;
            var extra;
            while (counter < length) {
              value = string.charCodeAt(counter++);
              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                  output.push(value);
                  counter--;
                }
              } else {
                output.push(value);
              }
            }
            return output;
          }
          function ucs2encode(array) {
            var length = array.length;
            var index = -1;
            var value;
            var output = '';
            while (++index < length) {
              value = array[index];
              if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
              }
              output += stringFromCharCode(value);
            }
            return output;
          }
          function checkScalarValue(codePoint) {
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
              throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
            }
          }
          function createByte(codePoint, shift) {
            return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
          }
          function encodeCodePoint(codePoint) {
            if ((codePoint & 0xFFFFFF80) == 0) {
              return stringFromCharCode(codePoint);
            }
            var symbol = '';
            if ((codePoint & 0xFFFFF800) == 0) {
              symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
            } else if ((codePoint & 0xFFFF0000) == 0) {
              checkScalarValue(codePoint);
              symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
              symbol += createByte(codePoint, 6);
            } else if ((codePoint & 0xFFE00000) == 0) {
              symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
              symbol += createByte(codePoint, 12);
              symbol += createByte(codePoint, 6);
            }
            symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
            return symbol;
          }
          function utf8encode(string) {
            var codePoints = ucs2decode(string);
            var length = codePoints.length;
            var index = -1;
            var codePoint;
            var byteString = '';
            while (++index < length) {
              codePoint = codePoints[index];
              byteString += encodeCodePoint(codePoint);
            }
            return byteString;
          }
          function readContinuationByte() {
            if (byteIndex >= byteCount) {
              throw Error('Invalid byte index');
            }
            var continuationByte = byteArray[byteIndex] & 0xFF;
            byteIndex++;
            if ((continuationByte & 0xC0) == 0x80) {
              return continuationByte & 0x3F;
            }
            throw Error('Invalid continuation byte');
          }
          function decodeSymbol() {
            var byte1;
            var byte2;
            var byte3;
            var byte4;
            var codePoint;
            if (byteIndex > byteCount) {
              throw Error('Invalid byte index');
            }
            if (byteIndex == byteCount) {
              return false;
            }
            byte1 = byteArray[byteIndex] & 0xFF;
            byteIndex++;
            if ((byte1 & 0x80) == 0) {
              return byte1;
            }
            if ((byte1 & 0xE0) == 0xC0) {
              var byte2 = readContinuationByte();
              codePoint = ((byte1 & 0x1F) << 6) | byte2;
              if (codePoint >= 0x80) {
                return codePoint;
              } else {
                throw Error('Invalid continuation byte');
              }
            }
            if ((byte1 & 0xF0) == 0xE0) {
              byte2 = readContinuationByte();
              byte3 = readContinuationByte();
              codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
              if (codePoint >= 0x0800) {
                checkScalarValue(codePoint);
                return codePoint;
              } else {
                throw Error('Invalid continuation byte');
              }
            }
            if ((byte1 & 0xF8) == 0xF0) {
              byte2 = readContinuationByte();
              byte3 = readContinuationByte();
              byte4 = readContinuationByte();
              codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) | (byte3 << 0x06) | byte4;
              if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
                return codePoint;
              }
            }
            throw Error('Invalid UTF-8 detected');
          }
          var byteArray;
          var byteCount;
          var byteIndex;
          function utf8decode(byteString) {
            byteArray = ucs2decode(byteString);
            byteCount = byteArray.length;
            byteIndex = 0;
            var codePoints = [];
            var tmp;
            while ((tmp = decodeSymbol()) !== false) {
              codePoints.push(tmp);
            }
            return ucs2encode(codePoints);
          }
          var utf8 = {
            'version': '2.0.0',
            'encode': utf8encode,
            'decode': utf8decode
          };
          if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
            define(function() {
              return utf8;
            });
          } else if (freeExports && !freeExports.nodeType) {
            if (freeModule) {
              freeModule.exports = utf8;
            } else {
              var object = {};
              var hasOwnProperty = object.hasOwnProperty;
              for (var key in utf8) {
                hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
              }
            }
          } else {
            root.utf8 = utf8;
          }
        }(this));
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    32: [function(_dereq_, module, exports) {
      (function(global) {
        var rvalidchars = /^[\],:{}\s]*$/;
        var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
        var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
        var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
        var rtrimLeft = /^\s+/;
        var rtrimRight = /\s+$/;
        module.exports = function parsejson(data) {
          if ('string' != typeof data || !data) {
            return null;
          }
          data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
          if (global.JSON && JSON.parse) {
            return JSON.parse(data);
          }
          if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
            return (new Function('return ' + data))();
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    33: [function(_dereq_, module, exports) {
      exports.encode = function(obj) {
        var str = '';
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (str.length)
              str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
          }
        }
        return str;
      };
      exports.decode = function(qs) {
        var qry = {};
        var pairs = qs.split('&');
        for (var i = 0,
            l = pairs.length; i < l; i++) {
          var pair = pairs[i].split('=');
          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return qry;
      };
    }, {}],
    34: [function(_dereq_, module, exports) {
      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
      module.exports = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');
        if (b != -1 && e != -1) {
          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }
        var m = re.exec(str || ''),
            uri = {},
            i = 14;
        while (i--) {
          uri[parts[i]] = m[i] || '';
        }
        if (b != -1 && e != -1) {
          uri.source = src;
          uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
          uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
          uri.ipv6uri = true;
        }
        return uri;
      };
    }, {}],
    35: [function(_dereq_, module, exports) {
      var global = (function() {
        return this;
      })();
      var WebSocket = global.WebSocket || global.MozWebSocket;
      module.exports = WebSocket ? ws : null;
      function ws(uri, protocols, opts) {
        var instance;
        if (protocols) {
          instance = new WebSocket(uri, protocols);
        } else {
          instance = new WebSocket(uri);
        }
        return instance;
      }
      if (WebSocket)
        ws.prototype = WebSocket.prototype;
    }, {}],
    36: [function(_dereq_, module, exports) {
      (function(global) {
        var isArray = _dereq_('isarray');
        module.exports = hasBinary;
        function hasBinary(data) {
          function _hasBinary(obj) {
            if (!obj)
              return false;
            if ((global.Buffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer) || (global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
              return true;
            }
            if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                if (_hasBinary(obj[i])) {
                  return true;
                }
              }
            } else if (obj && 'object' == typeof obj) {
              if (obj.toJSON) {
                obj = obj.toJSON();
              }
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                  return true;
                }
              }
            }
            return false;
          }
          return _hasBinary(data);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {"isarray": 37}],
    37: [function(_dereq_, module, exports) {
      module.exports = Array.isArray || function(arr) {
        return Object.prototype.toString.call(arr) == '[object Array]';
      };
    }, {}],
    38: [function(_dereq_, module, exports) {
      var global = _dereq_('global');
      try {
        module.exports = 'XMLHttpRequest' in global && 'withCredentials' in new global.XMLHttpRequest();
      } catch (err) {
        module.exports = false;
      }
    }, {"global": 39}],
    39: [function(_dereq_, module, exports) {
      module.exports = (function() {
        return this;
      })();
    }, {}],
    40: [function(_dereq_, module, exports) {
      var indexOf = [].indexOf;
      module.exports = function(arr, obj) {
        if (indexOf)
          return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
          if (arr[i] === obj)
            return i;
        }
        return -1;
      };
    }, {}],
    41: [function(_dereq_, module, exports) {
      var has = Object.prototype.hasOwnProperty;
      exports.keys = Object.keys || function(obj) {
        var keys = [];
        for (var key in obj) {
          if (has.call(obj, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      exports.values = function(obj) {
        var vals = [];
        for (var key in obj) {
          if (has.call(obj, key)) {
            vals.push(obj[key]);
          }
        }
        return vals;
      };
      exports.merge = function(a, b) {
        for (var key in b) {
          if (has.call(b, key)) {
            a[key] = b[key];
          }
        }
        return a;
      };
      exports.length = function(obj) {
        return exports.keys(obj).length;
      };
      exports.isEmpty = function(obj) {
        return 0 == exports.length(obj);
      };
    }, {}],
    42: [function(_dereq_, module, exports) {
      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
      module.exports = function parseuri(str) {
        var m = re.exec(str || ''),
            uri = {},
            i = 14;
        while (i--) {
          uri[parts[i]] = m[i] || '';
        }
        return uri;
      };
    }, {}],
    43: [function(_dereq_, module, exports) {
      (function(global) {
        var isArray = _dereq_('isarray');
        var isBuf = _dereq_('./is-buffer');
        exports.deconstructPacket = function(packet) {
          var buffers = [];
          var packetData = packet.data;
          function _deconstructPacket(data) {
            if (!data)
              return data;
            if (isBuf(data)) {
              var placeholder = {
                _placeholder: true,
                num: buffers.length
              };
              buffers.push(data);
              return placeholder;
            } else if (isArray(data)) {
              var newData = new Array(data.length);
              for (var i = 0; i < data.length; i++) {
                newData[i] = _deconstructPacket(data[i]);
              }
              return newData;
            } else if ('object' == typeof data && !(data instanceof Date)) {
              var newData = {};
              for (var key in data) {
                newData[key] = _deconstructPacket(data[key]);
              }
              return newData;
            }
            return data;
          }
          var pack = packet;
          pack.data = _deconstructPacket(packetData);
          pack.attachments = buffers.length;
          return {
            packet: pack,
            buffers: buffers
          };
        };
        exports.reconstructPacket = function(packet, buffers) {
          var curPlaceHolder = 0;
          function _reconstructPacket(data) {
            if (data && data._placeholder) {
              var buf = buffers[data.num];
              return buf;
            } else if (isArray(data)) {
              for (var i = 0; i < data.length; i++) {
                data[i] = _reconstructPacket(data[i]);
              }
              return data;
            } else if (data && 'object' == typeof data) {
              for (var key in data) {
                data[key] = _reconstructPacket(data[key]);
              }
              return data;
            }
            return data;
          }
          packet.data = _reconstructPacket(packet.data);
          packet.attachments = undefined;
          return packet;
        };
        exports.removeBlobs = function(data, callback) {
          function _removeBlobs(obj, curKey, containingObject) {
            if (!obj)
              return obj;
            if ((global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
              pendingBlobs++;
              var fileReader = new FileReader();
              fileReader.onload = function() {
                if (containingObject) {
                  containingObject[curKey] = this.result;
                } else {
                  bloblessData = this.result;
                }
                if (!--pendingBlobs) {
                  callback(bloblessData);
                }
              };
              fileReader.readAsArrayBuffer(obj);
            } else if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                _removeBlobs(obj[i], i, obj);
              }
            } else if (obj && 'object' == typeof obj && !isBuf(obj)) {
              for (var key in obj) {
                _removeBlobs(obj[key], key, obj);
              }
            }
          }
          var pendingBlobs = 0;
          var bloblessData = data;
          _removeBlobs(bloblessData);
          if (!pendingBlobs) {
            callback(bloblessData);
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./is-buffer": 45,
      "isarray": 46
    }],
    44: [function(_dereq_, module, exports) {
      var debug = _dereq_('debug')('socket.io-parser');
      var json = _dereq_('json3');
      var isArray = _dereq_('isarray');
      var Emitter = _dereq_('component-emitter');
      var binary = _dereq_('./binary');
      var isBuf = _dereq_('./is-buffer');
      exports.protocol = 4;
      exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'BINARY_EVENT', 'ACK', 'BINARY_ACK', 'ERROR'];
      exports.CONNECT = 0;
      exports.DISCONNECT = 1;
      exports.EVENT = 2;
      exports.ACK = 3;
      exports.ERROR = 4;
      exports.BINARY_EVENT = 5;
      exports.BINARY_ACK = 6;
      exports.Encoder = Encoder;
      exports.Decoder = Decoder;
      function Encoder() {}
      Encoder.prototype.encode = function(obj, callback) {
        debug('encoding packet %j', obj);
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          encodeAsBinary(obj, callback);
        } else {
          var encoding = encodeAsString(obj);
          callback([encoding]);
        }
      };
      function encodeAsString(obj) {
        var str = '';
        var nsp = false;
        str += obj.type;
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          str += obj.attachments;
          str += '-';
        }
        if (obj.nsp && '/' != obj.nsp) {
          nsp = true;
          str += obj.nsp;
        }
        if (null != obj.id) {
          if (nsp) {
            str += ',';
            nsp = false;
          }
          str += obj.id;
        }
        if (null != obj.data) {
          if (nsp)
            str += ',';
          str += json.stringify(obj.data);
        }
        debug('encoded %j as %s', obj, str);
        return str;
      }
      function encodeAsBinary(obj, callback) {
        function writeEncoding(bloblessData) {
          var deconstruction = binary.deconstructPacket(bloblessData);
          var pack = encodeAsString(deconstruction.packet);
          var buffers = deconstruction.buffers;
          buffers.unshift(pack);
          callback(buffers);
        }
        binary.removeBlobs(obj, writeEncoding);
      }
      function Decoder() {
        this.reconstructor = null;
      }
      Emitter(Decoder.prototype);
      Decoder.prototype.add = function(obj) {
        var packet;
        if ('string' == typeof obj) {
          packet = decodeString(obj);
          if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
            this.reconstructor = new BinaryReconstructor(packet);
            if (this.reconstructor.reconPack.attachments === 0) {
              this.emit('decoded', packet);
            }
          } else {
            this.emit('decoded', packet);
          }
        } else if (isBuf(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error('got binary data when not reconstructing a packet');
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              this.emit('decoded', packet);
            }
          }
        } else {
          throw new Error('Unknown type: ' + obj);
        }
      };
      function decodeString(str) {
        var p = {};
        var i = 0;
        p.type = Number(str.charAt(0));
        if (null == exports.types[p.type])
          return error();
        if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
          var buf = '';
          while (str.charAt(++i) != '-') {
            buf += str.charAt(i);
            if (i == str.length)
              break;
          }
          if (buf != Number(buf) || str.charAt(i) != '-') {
            throw new Error('Illegal attachments');
          }
          p.attachments = Number(buf);
        }
        if ('/' == str.charAt(i + 1)) {
          p.nsp = '';
          while (++i) {
            var c = str.charAt(i);
            if (',' == c)
              break;
            p.nsp += c;
            if (i == str.length)
              break;
          }
        } else {
          p.nsp = '/';
        }
        var next = str.charAt(i + 1);
        if ('' !== next && Number(next) == next) {
          p.id = '';
          while (++i) {
            var c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            p.id += str.charAt(i);
            if (i == str.length)
              break;
          }
          p.id = Number(p.id);
        }
        if (str.charAt(++i)) {
          try {
            p.data = json.parse(str.substr(i));
          } catch (e) {
            return error();
          }
        }
        debug('decoded %s as %j', str, p);
        return p;
      }
      Decoder.prototype.destroy = function() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      };
      function BinaryReconstructor(packet) {
        this.reconPack = packet;
        this.buffers = [];
      }
      BinaryReconstructor.prototype.takeBinaryData = function(binData) {
        this.buffers.push(binData);
        if (this.buffers.length == this.reconPack.attachments) {
          var packet = binary.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      };
      BinaryReconstructor.prototype.finishedReconstruction = function() {
        this.reconPack = null;
        this.buffers = [];
      };
      function error(data) {
        return {
          type: exports.ERROR,
          data: 'parser error'
        };
      }
    }, {
      "./binary": 43,
      "./is-buffer": 45,
      "component-emitter": 9,
      "debug": 10,
      "isarray": 46,
      "json3": 47
    }],
    45: [function(_dereq_, module, exports) {
      (function(global) {
        module.exports = isBuf;
        function isBuf(obj) {
          return (global.Buffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    46: [function(_dereq_, module, exports) {
      module.exports = _dereq_(37);
    }, {}],
    47: [function(_dereq_, module, exports) {
      ;
      (function(window) {
        var getClass = {}.toString,
            isProperty,
            forEach,
            undef;
        var isLoader = typeof define === "function" && define.amd;
        var nativeJSON = typeof JSON == "object" && JSON;
        var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;
        if (JSON3 && nativeJSON) {
          JSON3.stringify = nativeJSON.stringify;
          JSON3.parse = nativeJSON.parse;
        } else {
          JSON3 = window.JSON = nativeJSON || {};
        }
        var isExtended = new Date(-3509827334573292);
        try {
          isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
        } catch (exception) {}
        function has(name) {
          if (has[name] !== undef) {
            return has[name];
          }
          var isSupported;
          if (name == "bug-string-char-index") {
            isSupported = "a"[0] != "a";
          } else if (name == "json") {
            isSupported = has("json-stringify") && has("json-parse");
          } else {
            var value,
                serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
            if (name == "json-stringify") {
              var stringify = JSON3.stringify,
                  stringifySupported = typeof stringify == "function" && isExtended;
              if (stringifySupported) {
                (value = function() {
                  return 1;
                }).toJSON = value;
                try {
                  stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({"a": [value, true, false, null, "\x00\b\n\f\r\t"]}) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                } catch (exception) {
                  stringifySupported = false;
                }
              }
              isSupported = stringifySupported;
            }
            if (name == "json-parse") {
              var parse = JSON3.parse;
              if (typeof parse == "function") {
                try {
                  if (parse("0") === 0 && !parse(false)) {
                    value = parse(serialized);
                    var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                    if (parseSupported) {
                      try {
                        parseSupported = !parse('"\t"');
                      } catch (exception) {}
                      if (parseSupported) {
                        try {
                          parseSupported = parse("01") !== 1;
                        } catch (exception) {}
                      }
                      if (parseSupported) {
                        try {
                          parseSupported = parse("1.") !== 1;
                        } catch (exception) {}
                      }
                    }
                  }
                } catch (exception) {
                  parseSupported = false;
                }
              }
              isSupported = parseSupported;
            }
          }
          return has[name] = !!isSupported;
        }
        if (!has("json")) {
          var functionClass = "[object Function]";
          var dateClass = "[object Date]";
          var numberClass = "[object Number]";
          var stringClass = "[object String]";
          var arrayClass = "[object Array]";
          var booleanClass = "[object Boolean]";
          var charIndexBuggy = has("bug-string-char-index");
          if (!isExtended) {
            var floor = Math.floor;
            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            var getDay = function(year, month) {
              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
            };
          }
          if (!(isProperty = {}.hasOwnProperty)) {
            isProperty = function(property) {
              var members = {},
                  constructor;
              if ((members.__proto__ = null, members.__proto__ = {"toString": 1}, members).toString != getClass) {
                isProperty = function(property) {
                  var original = this.__proto__,
                      result = property in (this.__proto__ = null, this);
                  this.__proto__ = original;
                  return result;
                };
              } else {
                constructor = members.constructor;
                isProperty = function(property) {
                  var parent = (this.constructor || constructor).prototype;
                  return property in this && !(property in parent && this[property] === parent[property]);
                };
              }
              members = null;
              return isProperty.call(this, property);
            };
          }
          var PrimitiveTypes = {
            'boolean': 1,
            'number': 1,
            'string': 1,
            'undefined': 1
          };
          var isHostType = function(object, property) {
            var type = typeof object[property];
            return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
          };
          forEach = function(object, callback) {
            var size = 0,
                Properties,
                members,
                property;
            (Properties = function() {
              this.valueOf = 0;
            }).prototype.valueOf = 0;
            members = new Properties();
            for (property in members) {
              if (isProperty.call(members, property)) {
                size++;
              }
            }
            Properties = members = null;
            if (!size) {
              members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
              forEach = function(object, callback) {
                var isFunction = getClass.call(object) == functionClass,
                    property,
                    length;
                var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
                for (property in object) {
                  if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                    callback(property);
                  }
                }
                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property))
                  ;
              };
            } else if (size == 2) {
              forEach = function(object, callback) {
                var members = {},
                    isFunction = getClass.call(object) == functionClass,
                    property;
                for (property in object) {
                  if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                    callback(property);
                  }
                }
              };
            } else {
              forEach = function(object, callback) {
                var isFunction = getClass.call(object) == functionClass,
                    property,
                    isConstructor;
                for (property in object) {
                  if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                    callback(property);
                  }
                }
                if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                  callback(property);
                }
              };
            }
            return forEach(object, callback);
          };
          if (!has("json-stringify")) {
            var Escapes = {
              92: "\\\\",
              34: '\\"',
              8: "\\b",
              12: "\\f",
              10: "\\n",
              13: "\\r",
              9: "\\t"
            };
            var leadingZeroes = "000000";
            var toPaddedString = function(width, value) {
              return (leadingZeroes + (value || 0)).slice(-width);
            };
            var unicodePrefix = "\\u00";
            var quote = function(value) {
              var result = '"',
                  index = 0,
                  length = value.length,
                  isLarge = length > 10 && charIndexBuggy,
                  symbols;
              if (isLarge) {
                symbols = value.split("");
              }
              for (; index < length; index++) {
                var charCode = value.charCodeAt(index);
                switch (charCode) {
                  case 8:
                  case 9:
                  case 10:
                  case 12:
                  case 13:
                  case 34:
                  case 92:
                    result += Escapes[charCode];
                    break;
                  default:
                    if (charCode < 32) {
                      result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                      break;
                    }
                    result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
                }
              }
              return result + '"';
            };
            var serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
              var value,
                  className,
                  year,
                  month,
                  date,
                  time,
                  hours,
                  minutes,
                  seconds,
                  milliseconds,
                  results,
                  element,
                  index,
                  length,
                  prefix,
                  result;
              try {
                value = object[property];
              } catch (exception) {}
              if (typeof value == "object" && value) {
                className = getClass.call(value);
                if (className == dateClass && !isProperty.call(value, "toJSON")) {
                  if (value > -1 / 0 && value < 1 / 0) {
                    if (getDay) {
                      date = floor(value / 864e5);
                      for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++)
                        ;
                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++)
                        ;
                      date = 1 + date - getDay(year, month);
                      time = (value % 864e5 + 864e5) % 864e5;
                      hours = floor(time / 36e5) % 24;
                      minutes = floor(time / 6e4) % 60;
                      seconds = floor(time / 1e3) % 60;
                      milliseconds = time % 1e3;
                    } else {
                      year = value.getUTCFullYear();
                      month = value.getUTCMonth();
                      date = value.getUTCDate();
                      hours = value.getUTCHours();
                      minutes = value.getUTCMinutes();
                      seconds = value.getUTCSeconds();
                      milliseconds = value.getUTCMilliseconds();
                    }
                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
                  } else {
                    value = null;
                  }
                } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                  value = value.toJSON(property);
                }
              }
              if (callback) {
                value = callback.call(object, property, value);
              }
              if (value === null) {
                return "null";
              }
              className = getClass.call(value);
              if (className == booleanClass) {
                return "" + value;
              } else if (className == numberClass) {
                return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
              } else if (className == stringClass) {
                return quote("" + value);
              }
              if (typeof value == "object") {
                for (length = stack.length; length--; ) {
                  if (stack[length] === value) {
                    throw TypeError();
                  }
                }
                stack.push(value);
                results = [];
                prefix = indentation;
                indentation += whitespace;
                if (className == arrayClass) {
                  for (index = 0, length = value.length; index < length; index++) {
                    element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                    results.push(element === undef ? "null" : element);
                  }
                  result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                } else {
                  forEach(properties || value, function(property) {
                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                    if (element !== undef) {
                      results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                    }
                  });
                  result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                }
                stack.pop();
                return result;
              }
            };
            JSON3.stringify = function(source, filter, width) {
              var whitespace,
                  callback,
                  properties,
                  className;
              if (typeof filter == "function" || typeof filter == "object" && filter) {
                if ((className = getClass.call(filter)) == functionClass) {
                  callback = filter;
                } else if (className == arrayClass) {
                  properties = {};
                  for (var index = 0,
                      length = filter.length,
                      value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1))
                    ;
                }
              }
              if (width) {
                if ((className = getClass.call(width)) == numberClass) {
                  if ((width -= width % 1) > 0) {
                    for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ")
                      ;
                  }
                } else if (className == stringClass) {
                  whitespace = width.length <= 10 ? width : width.slice(0, 10);
                }
              }
              return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
            };
          }
          if (!has("json-parse")) {
            var fromCharCode = String.fromCharCode;
            var Unescapes = {
              92: "\\",
              34: '"',
              47: "/",
              98: "\b",
              116: "\t",
              110: "\n",
              102: "\f",
              114: "\r"
            };
            var Index,
                Source;
            var abort = function() {
              Index = Source = null;
              throw SyntaxError();
            };
            var lex = function() {
              var source = Source,
                  length = source.length,
                  value,
                  begin,
                  position,
                  isSigned,
                  charCode;
              while (Index < length) {
                charCode = source.charCodeAt(Index);
                switch (charCode) {
                  case 9:
                  case 10:
                  case 13:
                  case 32:
                    Index++;
                    break;
                  case 123:
                  case 125:
                  case 91:
                  case 93:
                  case 58:
                  case 44:
                    value = charIndexBuggy ? source.charAt(Index) : source[Index];
                    Index++;
                    return value;
                  case 34:
                    for (value = "@", Index++; Index < length; ) {
                      charCode = source.charCodeAt(Index);
                      if (charCode < 32) {
                        abort();
                      } else if (charCode == 92) {
                        charCode = source.charCodeAt(++Index);
                        switch (charCode) {
                          case 92:
                          case 34:
                          case 47:
                          case 98:
                          case 116:
                          case 110:
                          case 102:
                          case 114:
                            value += Unescapes[charCode];
                            Index++;
                            break;
                          case 117:
                            begin = ++Index;
                            for (position = Index + 4; Index < position; Index++) {
                              charCode = source.charCodeAt(Index);
                              if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                abort();
                              }
                            }
                            value += fromCharCode("0x" + source.slice(begin, Index));
                            break;
                          default:
                            abort();
                        }
                      } else {
                        if (charCode == 34) {
                          break;
                        }
                        charCode = source.charCodeAt(Index);
                        begin = Index;
                        while (charCode >= 32 && charCode != 92 && charCode != 34) {
                          charCode = source.charCodeAt(++Index);
                        }
                        value += source.slice(begin, Index);
                      }
                    }
                    if (source.charCodeAt(Index) == 34) {
                      Index++;
                      return value;
                    }
                    abort();
                  default:
                    begin = Index;
                    if (charCode == 45) {
                      isSigned = true;
                      charCode = source.charCodeAt(++Index);
                    }
                    if (charCode >= 48 && charCode <= 57) {
                      if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                        abort();
                      }
                      isSigned = false;
                      for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++)
                        ;
                      if (source.charCodeAt(Index) == 46) {
                        position = ++Index;
                        for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                          ;
                        if (position == Index) {
                          abort();
                        }
                        Index = position;
                      }
                      charCode = source.charCodeAt(Index);
                      if (charCode == 101 || charCode == 69) {
                        charCode = source.charCodeAt(++Index);
                        if (charCode == 43 || charCode == 45) {
                          Index++;
                        }
                        for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                          ;
                        if (position == Index) {
                          abort();
                        }
                        Index = position;
                      }
                      return +source.slice(begin, Index);
                    }
                    if (isSigned) {
                      abort();
                    }
                    if (source.slice(Index, Index + 4) == "true") {
                      Index += 4;
                      return true;
                    } else if (source.slice(Index, Index + 5) == "false") {
                      Index += 5;
                      return false;
                    } else if (source.slice(Index, Index + 4) == "null") {
                      Index += 4;
                      return null;
                    }
                    abort();
                }
              }
              return "$";
            };
            var get = function(value) {
              var results,
                  hasMembers;
              if (value == "$") {
                abort();
              }
              if (typeof value == "string") {
                if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                  return value.slice(1);
                }
                if (value == "[") {
                  results = [];
                  for (; ; hasMembers || (hasMembers = true)) {
                    value = lex();
                    if (value == "]") {
                      break;
                    }
                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();
                        if (value == "]") {
                          abort();
                        }
                      } else {
                        abort();
                      }
                    }
                    if (value == ",") {
                      abort();
                    }
                    results.push(get(value));
                  }
                  return results;
                } else if (value == "{") {
                  results = {};
                  for (; ; hasMembers || (hasMembers = true)) {
                    value = lex();
                    if (value == "}") {
                      break;
                    }
                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();
                        if (value == "}") {
                          abort();
                        }
                      } else {
                        abort();
                      }
                    }
                    if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                      abort();
                    }
                    results[value.slice(1)] = get(lex());
                  }
                  return results;
                }
                abort();
              }
              return value;
            };
            var update = function(source, property, callback) {
              var element = walk(source, property, callback);
              if (element === undef) {
                delete source[property];
              } else {
                source[property] = element;
              }
            };
            var walk = function(source, property, callback) {
              var value = source[property],
                  length;
              if (typeof value == "object" && value) {
                if (getClass.call(value) == arrayClass) {
                  for (length = value.length; length--; ) {
                    update(value, length, callback);
                  }
                } else {
                  forEach(value, function(property) {
                    update(value, property, callback);
                  });
                }
              }
              return callback.call(source, property, value);
            };
            JSON3.parse = function(source, callback) {
              var result,
                  value;
              Index = 0;
              Source = "" + source;
              result = get(lex());
              if (lex() != "$") {
                abort();
              }
              Index = Source = null;
              return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
            };
          }
        }
        if (isLoader) {
          define(function() {
            return JSON3;
          });
        }
      }(this));
    }, {}],
    48: [function(_dereq_, module, exports) {
      module.exports = toArray;
      function toArray(list, index) {
        var array = [];
        index = index || 0;
        for (var i = index || 0; i < list.length; i++) {
          array[i - index] = list[i];
        }
        return array;
      }
    }, {}]
  }, {}, [1])(1);
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("github:socketio/socket.io-client@1.3.7", ["github:socketio/socket.io-client@1.3.7/socket.io"], function(main) {
  return main;
});

_removeDefine();
})();
System.registerDynamic("npm:core-js@1.2.3/library/modules/$.object-to-array", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.to-iobject"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
      toIObject = $__require('npm:core-js@1.2.3/library/modules/$.to-iobject'),
      isEnum = $.isEnum;
  module.exports = function(isEntries) {
    return function(it) {
      var O = toIObject(it),
          keys = $.getKeys(O),
          length = keys.length,
          i = 0,
          result = [],
          key;
      while (length > i)
        if (isEnum.call(O, key = keys[i++])) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      return result;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es7.object.entries", ["npm:core-js@1.2.3/library/modules/$.def", "npm:core-js@1.2.3/library/modules/$.object-to-array"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/library/modules/$.def'),
      $entries = $__require('npm:core-js@1.2.3/library/modules/$.object-to-array')(true);
  $def($def.S, 'Object', {entries: function entries(it) {
      return $entries(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/object/entries", ["npm:core-js@1.2.3/library/modules/es7.object.entries", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es7.object.entries');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').Object.entries;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/entries", ["npm:core-js@1.2.3/library/fn/object/entries"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/object/entries'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Services/RealTimeService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/object/entries', 'github:angular/bower-angular@1.4.7', 'github:socketio/socket.io-client@1.3.7'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Object$entries, angular, socket, RealTimeService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsObjectEntries) {
            _Object$entries = _npmBabelRuntime5825CoreJsObjectEntries['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_githubSocketioSocketIoClient137) {
            socket = _githubSocketioSocketIoClient137['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            RealTimeService = (function () {
                function RealTimeService(config) {
                    _classCallCheck(this, RealTimeService);

                    this.config = config;
                }

                _createClass(RealTimeService, [{
                    key: 'connect',
                    value: function connect(room, events) {
                        var url = 'http://localhost:' + this.config.port + '/' + room;
                        var connection = socket.connect(url, {
                            forceNew: true
                        });
                        _Object$entries(events).forEach(function (entry) {
                            var _entry = _slicedToArray(entry, 2);

                            var event = _entry[0];
                            var handler = _entry[1];

                            connection.on(event, handler);
                        });
                        return connection;
                    }
                }]);

                return RealTimeService;
            })();

            _export('default', angular.module('tractor.realTimeService', []).service('realTimeService', RealTimeService));
        }
    };
});
System.register('app/Core/Services/HttpResponseInterceptor.js', ['npm:bluebird@2.10.2', 'github:angular/bower-angular@1.4.7'], function (_export) {

    // Utilities:
    'use strict';

    // Dependencies:
    var Promise, angular, HttpResponseInterceptor;
    return {
        setters: [function (_npmBluebird2102) {
            Promise = _npmBluebird2102['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {
            HttpResponseInterceptor = function HttpResponseInterceptor(notifierService) {
                var handleResponseData = function handleResponseData(response) {
                    return Promise.resolve(response.config.url.match(/.html$/) ? response : response.data);
                };

                var handleResponseError = function handleResponseError(response) {
                    var error = new Error();
                    notifierService.error(response.data.error);
                    error.message = response.data.error;
                    error.response = response;
                    return Promise.reject(error);
                };

                return {
                    response: handleResponseData,
                    responseError: handleResponseError
                };
            };

            _export('default', angular.module('tractor.httpResponseInterceptor', []).factory('httpResponseInterceptor', HttpResponseInterceptor).config(function ($httpProvider) {
                return $httpProvider.interceptors.push('httpResponseInterceptor');
            }));
        }
    };
});
System.register('app/Core/Validators/FileNameValidator.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Notifier/NotifierService.js'], function (_export) {
    var _classCallCheck, angular, NotifierService, FileNameValidator;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            FileNameValidator = function FileNameValidator(notifierService) {
                _classCallCheck(this, FileNameValidator);

                this.notifierService = notifierService;

                this.restrict = 'A';
                this.require = 'ngModel';

                this.link = function ($scope, $element, $attrs, ngModelController) {
                    ngModelController.$validators.fileName = function (value) {
                        if (value.includes('_')) {
                            this.notifierService.error('Invalid character: "_"');
                            return false;
                        }
                        if (value.includes('/')) {
                            this.notifierService.error('Invalid character: "/"');
                            return false;
                        }
                        if (value.includes('\\')) {
                            this.notifierService.error('Invalid character: "\\"');
                            return false;
                        }
                        return true;
                    };
                };
            };

            _export('default', angular.module('fileName', [NotifierService.name]).directive('fileName', function (notifierService) {
                return new FileNameValidator(notifierService);
            }));
        }
    };
});
System.register('app/Core/Validators/VariableNameValidator.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ValidationService.js'], function (_export) {
    var _classCallCheck, changecase, angular, ValidationService, MODEL_CHANGE_EVENT, VariableNameValidator;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesValidationServiceJs) {
            ValidationService = _appCoreServicesValidationServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Constants:

            // Utilities:
            MODEL_CHANGE_EVENT = 'VariableNameValidator:ModelChange';

            VariableNameValidator = function VariableNameValidator($rootScope, validationService) {
                var _this = this;

                _classCallCheck(this, VariableNameValidator);

                this.$rootScope = $rootScope;
                this.validationService = validationService;

                this.restrict = 'A';
                this.require = 'ngModel';

                this.scope = {
                    variableValue: '=ngModel',
                    variableNameModel: '='
                };

                this.link = function ($scope, element, attrs, ngModelController) {
                    var destroy = _this.$rootScope.$on(MODEL_CHANGE_EVENT, function (event, changing) {
                        if (ngModelController !== changing) {
                            ngModelController.$validate();
                        }
                    });
                    $scope.$on('$destroy', destroy);
                    $scope.$watch('variableValue', function () {
                        _this.$rootScope.$broadcast(MODEL_CHANGE_EVENT, ngModelController);
                    });

                    ngModelController.$validators.variableNameUnique = function (value) {
                        var allVariableNames = $scope.variableNameModel.getAllVariableNames();
                        return !allVariableNames.includes(value);
                    };

                    ngModelController.$validators.variableNameValid = function (value) {
                        var variableName = $scope.$parent.isClass ? changecase.pascal(value) : changecase.camel(value);
                        if (variableName.length === 0) {
                            return false;
                        }
                        return _this.validationService.validateVariableName(variableName);
                    };
                };
            };

            _export('default', angular.module('variableName', [ValidationService.name]).directive('variableName', function ($rootScope, validationService) {
                return new VariableNameValidator($rootScope, validationService);
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/VariableInput/VariableInput.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<label>{{ label }}: </label>\r\n<input name=\"variable-input-{{ id }}\" type=\"text\" placeholder=\"e.g. {{ example }}\"\r\n    ng-model=\"model[property]\"\r\n    ng-model-options=\"{ allowInvalid: true }\"\r\n    ng-blur=\"blur(model[property])\"\r\n    required\r\n    file-name\r\n    variable-name\r\n    variable-name-model=\"model\"/>\r\n<div ng-messages=\"form['variable-input-' + id].$error\">\r\n    <ng-message when=\"required\">Required</ng-message>\r\n    <ng-message when=\"fileName\">That is not a valid name</ng-message>\r\n    <ng-message when=\"variableNameValid\">That is not a valid name</ng-message>\r\n    <ng-message when=\"variableNameUnique\">There is something else with the same name</ng-message>\r\n</div>\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/VariableInput/VariableInputDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/VariableInput/VariableInput.html', 'app/Core/Validators/VariableNameValidator.js'], function (_export) {
    var _classCallCheck, changecase, angular, template, VariableNameValidator, VariableInputDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsVariableInputVariableInputHtml) {
            template = _appCoreComponentsVariableInputVariableInputHtml['default'];
        }, function (_appCoreValidatorsVariableNameValidatorJs) {
            VariableNameValidator = _appCoreValidatorsVariableNameValidatorJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            VariableInputDirective = function VariableInputDirective() {
                _classCallCheck(this, VariableInputDirective);

                this.restrict = 'E';

                this.scope = {
                    form: '=',
                    model: '=',
                    label: '@',
                    example: '@'
                };

                this.template = template;

                this.link = function ($scope, $element, $attrs) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-variable-input> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.label)) {
                        throw new Error('The <tractor-variable-input> directive requires a "label" attribute.');
                    }

                    if (angular.isUndefined($scope.form)) {
                        throw new Error('The <tractor-variable-input> directive requires a "form" attribute.');
                    }

                    $scope.id = Math.floor(Math.random() * Date.now());

                    $scope.isClass = Object.prototype.hasOwnProperty.call($attrs, 'isClass');
                    $scope.property = changecase.camel($scope.label);
                };
            };

            _export('default', angular.module('tractor.variableInput', [VariableNameValidator.name]).directive('tractorVariableInput', function () {
                return new VariableInputDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/TextInput/TextInput.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<label>{{ label }}: </label>\r\n<input name=\"text-{{ id }}\" type=\"text\" placeholder=\"e.g. {{ example }}\"\r\n    ng-if=\"!validateFileName\"\r\n    ng-model=\"model[property]\"\r\n    ng-model-options=\"{ allowInvalid: true }\"\r\n    required />\r\n<input name=\"text-{{ id }}\" type=\"text\" placeholder=\"e.g. {{ example }}\"\r\n    ng-if=\"validateFileName\"\r\n    ng-model=\"model[property]\"\r\n    ng-model-options=\"{ allowInvalid: true }\"\r\n    file-name\r\n    required />\r\n<div ng-messages=\"form['text-' + id].$error\">\r\n    <ng-message when=\"fileName\">That is not a valid input</ng-message>\r\n    <ng-message when=\"required\">Required</ng-message>\r\n</div>\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/TextInput/TextInputDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/TextInput/TextInput.html'], function (_export) {
    var _classCallCheck, changecase, angular, template, TextInputDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsTextInputTextInputHtml) {
            template = _appCoreComponentsTextInputTextInputHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            TextInputDirective = function TextInputDirective() {
                _classCallCheck(this, TextInputDirective);

                this.restrict = 'E';

                this.scope = {
                    form: '=',
                    model: '=',
                    label: '@',
                    example: '@'
                };

                this.template = template;

                this.link = function ($scope, $element, $attrs) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-text-input> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.label)) {
                        throw new Error('The <tractor-text-input> directive requires a "label" attribute.');
                    }

                    if (angular.isUndefined($scope.form)) {
                        throw new Error('The <tractor-text-input> directive requires a "form" attribute.');
                    }

                    $scope.id = Math.floor(Math.random() * Date.now());
                    $scope.validateFileName = Object.prototype.hasOwnProperty.call($attrs, 'validateFileName');

                    $scope.property = changecase.camel($scope.label);
                };
            };

            _export('default', angular.module('tractor.textInput', []).directive('tractorTextInput', function () {
                return new TextInputDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/Submit/Submit.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<button type=\"submit\">\r\n    <span>{{ action }}</span>\r\n</button>\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/Submit/SubmitDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Submit/Submit.html'], function (_export) {
    var _classCallCheck, angular, template, SubmitDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsSubmitSubmitHtml) {
            template = _appCoreComponentsSubmitSubmitHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            SubmitDirective = function SubmitDirective() {
                _classCallCheck(this, SubmitDirective);

                this.restrict = 'E';

                this.scope = {
                    action: '@'
                };

                this.template = template;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.action)) {
                        throw new Error('The <tractor-submit> directive requires an "action" attribute.');
                    }
                };
            };

            _export('default', angular.module('tractor.submit', []).directive('tractorSubmit', function () {
                return new SubmitDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/StepInput/StepInput.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<label>{{ label }}: </label>\r\n<input name=\"step-{{ id }}\" type=\"text\" placeholder=\"e.g. {{ example }}\"\r\n    ng-model=\"model[property]\"\r\n    ng-model-options=\"{ allowInvalid: true }\"\r\n    example-name\r\n    required />\r\n<div ng-messages=\"form['step-' + id].$error\">\r\n    <ng-message when=\"required\">Required</ng-message>\r\n    <ng-message when=\"exampleName\">That is not a valid example name</ng-message>\r\n</div>\r\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-var-name@1.0.0/is-var-name-cjs", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isVarName(str) {
    'use strict';
    if (typeof str !== 'string') {
      return false;
    }
    try {
      new Function('var ' + str)();
    } catch (e) {
      return false;
    }
    return true;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-var-name@1.0.0", ["npm:is-var-name@1.0.0/is-var-name-cjs"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:is-var-name@1.0.0/is-var-name-cjs');
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Services/ValidationService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:is-var-name@1.0.0', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _createClass, _classCallCheck, isVarName, angular, ValidationService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmIsVarName100) {
            isVarName = _npmIsVarName100['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            ValidationService = (function () {
                function ValidationService() {
                    _classCallCheck(this, ValidationService);
                }

                _createClass(ValidationService, [{
                    key: 'validateVariableName',
                    value: function validateVariableName(variableName) {
                        return isVarName(variableName) ? variableName : false;
                    }
                }]);

                return ValidationService;
            })();

            _export('default', angular.module('tractor.validationService', []).service('validationService', ValidationService));
        }
    };
});
System.register('app/features/FeatureEditor/Models/StepDeclarationModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, angular, types;

    function createStepDeclarationModelConstructor() {
        return (function () {
            function StepDeclarationModel() {
                _classCallCheck(this, StepDeclarationModel);

                this[types] = ['Given', 'When', 'Then', 'And', 'But'];

                var _types = _slicedToArray(this.types, 1);

                var type = _types[0];

                this.type = type;
                this.step = '';
            }

            _createClass(StepDeclarationModel, [{
                key: 'types',
                get: function get() {
                    return this[types];
                }
            }, {
                key: 'feature',
                get: function get() {
                    return toFeature.call(this);
                }
            }]);

            return StepDeclarationModel;
        })();

        function toFeature() {
            return this.type + ' ' + this.step;
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {

            // Symbols:
            'use strict';

            // Dependencies:
            types = _Symbol();

            _export('default', angular.module('tractor.stepDeclarationModel', []).factory('StepDeclarationModel', createStepDeclarationModelConstructor));
        }
    };
});
System.register('app/Core/Validators/ExampleNameValidator.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/features/FeatureEditor/Models/StepDeclarationModel.js', 'app/Core/Services/ValidationService.js'], function (_export) {
    var _classCallCheck, angular, StepDeclarationModel, ValidationService, ExampleNameValidator;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesFeatureEditorModelsStepDeclarationModelJs) {
            StepDeclarationModel = _appFeaturesFeatureEditorModelsStepDeclarationModelJs['default'];
        }, function (_appCoreServicesValidationServiceJs) {
            ValidationService = _appCoreServicesValidationServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            ExampleNameValidator = function ExampleNameValidator(ScenarioModel, validationService) {
                var _this = this;

                _classCallCheck(this, ExampleNameValidator);

                this.ScenarioModel = ScenarioModel;
                this.validationService = validationService;

                this.restrict = 'A';
                this.require = 'ngModel';

                this.link = function ($scope, $element, $attrs, ngModelController) {
                    ngModelController.$validators.exampleName = function (value) {
                        var variableNames = _this.ScenarioModel.getExampleVariableNames(value);
                        return variableNames.filter(function (variableName) {
                            return _this.validationService.validateVariableName(variableName);
                        }).length === variableNames.length;
                    };
                };
            };

            _export('default', angular.module('exampleName', [StepDeclarationModel.name, ValidationService.name]).directive('exampleName', function (ScenarioModel, validationService) {
                return new ExampleNameValidator(ScenarioModel, validationService);
            }));
        }
    };
});
System.register('app/Core/Components/StepInput/StepInputDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Validators/ExampleNameValidator.js', 'app/Core/Components/StepInput/StepInput.html'], function (_export) {
    var _classCallCheck, changecase, angular, ExampleNameValidator, template, StepInputDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreValidatorsExampleNameValidatorJs) {
            ExampleNameValidator = _appCoreValidatorsExampleNameValidatorJs['default'];
        }, function (_appCoreComponentsStepInputStepInputHtml) {
            template = _appCoreComponentsStepInputStepInputHtml['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            StepInputDirective = function StepInputDirective() {
                _classCallCheck(this, StepInputDirective);

                this.restrict = 'E';

                this.scope = {
                    form: '=',
                    model: '=',
                    label: '@',
                    example: '@'
                };

                this.template = template;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-step-input> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.label)) {
                        throw new Error('The <tractor-step-input> directive requires a "label" attribute.');
                    }

                    if (angular.isUndefined($scope.form)) {
                        throw new Error('The <tractor-step-input> directive requires a "form" attribute.');
                    }

                    $scope.id = Math.floor(Math.random() * Date.now());

                    $scope.property = changecase.camel($scope.label);
                };
            };

            _export('default', angular.module('tractor.stepInput', [ExampleNameValidator.name]).directive('tractorStepInput', function () {
                return new StepInputDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/SelectInput/SelectInput.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<label ng-if=\"model[property].description\" title=\"{{ model[property].description }}\">{{ label }}: </label>\r\n<label ng-if=\"!model[property].description\">{{ label }}: </label>\r\n<select ng-if=\"as\"\r\n        ng-model=\"model[property]\"\r\n        ng-options=\"option as option[as] for option in selectOptions\">\r\n</select>\r\n<select ng-if=\"!as\"\r\n        ng-model=\"model[property]\"\r\n        ng-options=\"option for option in selectOptions\">\r\n</select>\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/SelectInput/SelectInputDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/SelectInput/SelectInput.html'], function (_export) {
    var _classCallCheck, changecase, angular, template, SelectInputDirective;

    function getOptionsFromProperty($scope) {
        return $scope.model[$scope.property + 's'];
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsSelectInputSelectInputHtml) {
            template = _appCoreComponentsSelectInputSelectInputHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            SelectInputDirective = function SelectInputDirective() {
                _classCallCheck(this, SelectInputDirective);

                this.restrict = 'E';

                this.scope = {
                    model: '=',
                    label: '@',
                    options: '=',
                    as: '@'
                };

                this.template = template;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-select> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.label)) {
                        throw new Error('The <tractor-select> directive requires a "label" attribute.');
                    }

                    $scope.property = changecase.camel($scope.label);
                    $scope.selectOptions = getOptionsFromProperty($scope);

                    if (angular.isUndefined($scope.selectOptions) && angular.isUndefined($scope.options)) {
                        throw new Error('The <tractor-select> directive requires an "options" attribute, or a "label" attribute that matches a set of options on the "model".');
                    }

                    $scope.$watchCollection('options', function () {
                        $scope.selectOptions = $scope.options || getOptionsFromProperty($scope);
                    });
                };
            };

            _export('default', angular.module('tractor.select', []).directive('tractorSelect', function () {
                return new SelectInputDirective();
            }));
        }
    };
});
System.register('app/Core/Components/PanelHandle/PanelHandleDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/PersistentStateService.js'], function (_export) {
    var _classCallCheck, _slicedToArray, angular, PersistentStateService, FULL_WIDTH, HANDLE_WIDTH, MAX_POSITION, MIN_POSITION, PanelHandleDirective;

    function save($handle) {
        var panelName = $handle.data('panelName');
        var beforeElement = $handle.data('beforeElement');
        var afterElement = $handle.data('afterElement');
        var before = beforeElement.style.width;
        var after = afterElement.style.width;
        this.persistentStateService.set(panelName, { before: before, after: after });
    }

    function mousedown($handle) {
        angular.element(document.body).data('handle', $handle);
        document.body.classList.add('resizing');
        document.body.addEventListener('mousemove', mousemove);
        document.body.addEventListener('mouseup', mouseup);
    }

    function mousemove(event) {
        var $body = angular.element(document.body);
        var $handle = $body.data('handle');
        var parent = $handle.data('parent');
        var beforeElement = $handle.data('beforeElement');
        var afterElement = $handle.data('afterElement');
        var containerWidth = parseFloat(window.getComputedStyle(parent).width);
        var percent = Math.max(MIN_POSITION, event.clientX / containerWidth * FULL_WIDTH);
        percent = Math.min(percent, MAX_POSITION);
        beforeElement.style.width = percent + '%';
        afterElement.style.width = FULL_WIDTH - HANDLE_WIDTH - percent + '%';
    }

    function mouseup() {
        document.body.classList.remove('resizing');
        document.body.removeEventListener('mousemove', mousemove);
        document.body.removeEventListener('mouseup', mouseup);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Constants:
            FULL_WIDTH = 100;
            HANDLE_WIDTH = 0.25;
            MAX_POSITION = 70;
            MIN_POSITION = 10;

            PanelHandleDirective = function PanelHandleDirective($rootScope, persistentStateService) {
                var _this = this;

                _classCallCheck(this, PanelHandleDirective);

                this.persistentStateService = persistentStateService;

                this.restrict = 'E';

                this.link = function ($scope, $element, $attrs) {
                    var $handle = $element;

                    var _$handle = _slicedToArray($handle, 1);

                    var handle = _$handle[0];

                    var $parent = $handle.parent();

                    var _$parent = _slicedToArray($parent, 1);

                    var parent = _$parent[0];

                    var $children = $parent.children();
                    var $siblings = [].filter.call($children, function (element) {
                        return element !== handle;
                    });
                    var panelName = $attrs.panelName;

                    var _$siblings = _slicedToArray($siblings, 1);

                    var beforeElement = _$siblings[0];

                    var _$siblings$slice$reverse = $siblings.slice().reverse();

                    var _$siblings$slice$reverse2 = _slicedToArray(_$siblings$slice$reverse, 1);

                    var afterElement = _$siblings$slice$reverse2[0];

                    $handle.data('parent', parent);
                    $handle.data('beforeElement', beforeElement);
                    $handle.data('afterElement', afterElement);
                    $handle.data('panelName', panelName);

                    handle.addEventListener('mousedown', function () {
                        return mousedown($handle);
                    });
                    var $destroy = $rootScope.$on('$stateChangeStart', function () {
                        return save.call(_this, $handle);
                    });
                    $scope.$on('$destroy', $destroy);

                    var panelHandlePosition = _this.persistentStateService.get(panelName);
                    if (panelHandlePosition) {
                        beforeElement.style.width = panelHandlePosition.before;
                        afterElement.style.width = panelHandlePosition.after;
                    }
                };
            };

            _export('default', angular.module('tractor.panelHandle', [PersistentStateService.name]).directive('tractorPanelHandle', function ($rootScope, persistentStateService) {
                return new PanelHandleDirective($rootScope, persistentStateService);
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/Notifier/Notifier.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<aside>\n    <ul class=\"notifier__notifications\">\n        <li ng-repeat=\"notification in notifications\"\n            ng-class=\"'notifier__notification notifier__notification--' + notification.type\">\n            <span class=\"notifier__notification-message\">{{ notification.message }}</span>\n\n            <button ng-click=\"dismiss(notification)\"\n                    class=\"notifier__notification-dismiss\"\n                    type=\"button\"\n                    title=\"Dismiss\">\n            </button>\n        </li>\n    </ul>\n</aside>\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/Notifier/NotifierController.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check'], function (_export) {
    var _classCallCheck, NotifierController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }],
        execute: function () {
            'use strict';

            NotifierController = function NotifierController(notifierService) {
                _classCallCheck(this, NotifierController);

                this.notifications = notifierService.notifications;
                this.dismiss = notifierService.dismiss;
            };

            _export('default', NotifierController);
        }
    };
});
System.register('app/Core/Components/Notifier/NotifierDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Notifier/NotifierController.js', 'app/Core/Components/Notifier/NotifierService.js', 'app/Core/Components/Notifier/Notifier.html'], function (_export) {
    var _classCallCheck, angular, NotifierController, NotifierService, template, NotifierDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsNotifierNotifierControllerJs) {
            NotifierController = _appCoreComponentsNotifierNotifierControllerJs['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }, function (_appCoreComponentsNotifierNotifierHtml) {
            template = _appCoreComponentsNotifierNotifierHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            NotifierDirective = function NotifierDirective() {
                _classCallCheck(this, NotifierDirective);

                this.restrict = 'E';
                this.template = template;

                this.controller = NotifierController;
                this.controllerAs = 'notifier';
                this.bindToController = true;
            };

            _export('default', angular.module('tractor.notifier', [NotifierService.name]).directive('tractorNotifier', function () {
                return new NotifierDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/LiteralInput/LiteralInput.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<label ng-if=\"description\" title=\"{{ description }}\">{{ name }}: </label>\r\n<label ng-if=\"!description\">{{ name }}: </label>\r\n<input name=\"literal-required-{{ id }}\" type=\"text\"\r\n    ng-if=\"required\"\r\n    ng-model=\"model.value\"\r\n    ng-model-options=\"{ allowInvalid: true }\"\r\n    placeholder=\"({{ type ? type + ' - ' : '' }}required)\"\r\n    required />\r\n<input name=\"literal-optional-{{ id }}\" type=\"text\"\r\n    ng-if=\"!required\"\r\n    ng-model=\"model.value\"\r\n    ng-model-options=\"{ allowInvalid: true }\"\r\n    placeholder=\"({{ type ? type + ' - ' : '' }}optional)\" />\r\n\r\n<div ng-messages=\"form['literal-required-' + id].$error\">\r\n    <ng-message when=\"required\">Required</ng-message>\r\n</div>\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/LiteralInput/LiteralInputDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/LiteralInput/LiteralInput.html'], function (_export) {
    var _classCallCheck, angular, template, LiteralInputDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsLiteralInputLiteralInputHtml) {
            template = _appCoreComponentsLiteralInputLiteralInputHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            LiteralInputDirective = function LiteralInputDirective() {
                _classCallCheck(this, LiteralInputDirective);

                this.restrict = 'E';

                this.scope = {
                    form: '=',
                    model: '=',
                    name: '=',
                    description: '=',
                    required: '=',
                    type: '='
                };

                this.template = template;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-literal-input> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.name)) {
                        throw new Error('The <tractor-literal-input> directive requires a "name" attribute.');
                    }

                    if (angular.isUndefined($scope.form)) {
                        throw new Error('The <tractor-literal-input> directive requires a "form" attribute.');
                    }

                    $scope.id = Math.floor(Math.random() * Date.now());
                };
            };

            _export('default', angular.module('tractor.literalInput', []).directive('tractorLiteralInput', function () {
                return new LiteralInputDirective();
            }));
        }
    };
});
System.register('app/Core/Components/GiveFocus/GiveFocusDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _classCallCheck, _slicedToArray, angular, GiveFocusDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            GiveFocusDirective = function GiveFocusDirective() {
                _classCallCheck(this, GiveFocusDirective);

                this.restrict = 'A';

                this.scope = {
                    focusOn: '='
                };

                this.link = function ($scope, $element) {
                    $scope.$watch('focusOn', function (currentValue) {
                        var _$element = _slicedToArray($element, 1);

                        var input = _$element[0];

                        if (currentValue) {
                            input.focus();
                            input.select();
                        } else {
                            input.blur();
                        }
                    });
                };
            };

            _export('default', angular.module('tractor.giveFocus', []).directive('tractorGiveFocus', function () {
                return new GiveFocusDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/FileTree/FileTree.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<script type=\"text/ng-template\" id=\"file-options.html\">\n    <div class=\"file-tree__item-options\"\n         ng-class=\"{ 'file-tree__item-active-options': item.showOptions }\"\n         ng-click=\"fileTree.showOptions(item)\">\n    </div>\n    <div class=\"file-tree__item-options-panel\"\n         ng-if=\"item.showOptions\"\n         ng-mouseleave=\"fileTree.hideOptions(item)\">\n        <tractor-action\n            ng-if=\"fileTree.canModify\"\n            model=\"fileTree\"\n            action=\"Edit name\"\n            argument=\"item\">\n        </tractor-action>\n        <tractor-action\n            ng-if=\"fileTree.canModify && !item.isDirectory\"\n            model=\"fileTree\"\n            action=\"Copy\"\n            argument=\"item\">\n        </tractor-action>\n        <tractor-action\n            model=\"fileTree\"\n            action=\"Delete\"\n            argument=\"item\">\n        </tractor-action>\n    </div>\n</script>\n\n<script type=\"text/ng-template\" id=\"rename-input.html\">\n    <input class=\"file-tree__item-rename\"\n            ng-if=\"item.editingName\"\n            ng-model=\"item.name\"\n            ng-blur=\"fileTree.saveNewName(item)\"\n            ng-keypress=\"fileTree.renameOnEnter($event, item)\"\n            tractor-give-focus\n            focus-on=\"item.editingName\">\n    </input>\n</script>\n\n<script type=\"text/ng-template\" id=\"file-structure.html\">\n    <div ng-include=\"'file-options.html'\"></div>\n\n    <p class=\"file-tree__item-name\"\n        ng-if=\"item.name && !item.editingName\"\n        ng-click=\"fileTree.toggleOpenDirectory(item)\"\n        ng-dblclick=\"fileTree.editName(item)\">\n        {{ item.name }}\n    </p>\n    <div ng-include=\"'rename-input.html'\"></div>\n\n    <ul class=\"file-tree__file-list\"\n        ng-if=\"(item || fileTree.model.fileStructure.directory).open\">\n        <li class=\"file-tree__file-list-item file-tree__file-list-item--new-directory\">\n            <tractor-action\n                model=\"fileTree\"\n                action=\"Add directory\"\n                argument=\"item || fileTree.model.fileStructure.directory\">\n            </tractor-action>\n        </li>\n\n        <li class=\"file-tree__file-list-item file-tree__file-list-item--directory\"\n            ng-class=\"{ 'file-tree__file-list-item--open-directory': item.open }\"\n            ng-repeat=\"item in (item || fileTree.model.fileStructure.directory).directories\"\n            ng-include=\"'file-structure.html'\"\n            tractor-drop-file\n            on-drop=\"fileTree.editFilePath\"\n            drop-directory=\"item\">\n        </li>\n\n        <li class=\"file-tree__file-list-item\"\n            ng-repeat=\"item in (item || fileTree.model.fileStructure.directory).files\"\n            tractor-drag-file>\n            <div ng-include=\"'file-options.html'\"></div>\n\n            <p class=\"file-tree__item-name\"\n                ng-if=\"item.name && !item.editingName\"\n                ng-click=\"fileTree.openFile(item)\"\n                ng-dblclick=\"fileTree.editName(item)\">\n                {{ fileTree.getName(item) }}\n            </p>\n            <div ng-include=\"'rename-input.html'\"></div>\n        </li>\n    </ul>\n</script>\n\n<section class=\"file-tree__container\"\n    tractor-drop-file\n    on-drop=\"fileTree.editFilePath\"\n    drop-directory=\"fileTree.model.fileStructure.directory\">\n\n    <h2 class=\"file-tree__header\">\n        {{ fileTree.headerName }} files:\n    </h2>\n    <div class=\"file-tree\"\n        ng-class=\"{\n            'file-tree--javascript': fileTree.type === 'components' || fileTree.type === 'step-definitions',\n            'file-tree--feature': fileTree.type === 'features',\n            'file-tree--json': fileTree.type === 'mock-data'\n        }\"\n        ng-include=\"'file-structure.html'\">\n    </div>\n</section>\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/Notifier/NotificationTypes.js', [], function (_export) {
    'use strict';

    // Constants:
    var SUCCESS, INFO, ERROR;
    return {
        setters: [],
        execute: function () {
            SUCCESS = 'success';
            INFO = 'info';
            ERROR = 'error';

            _export('default', {
                SUCCESS: SUCCESS,
                INFO: INFO,
                ERROR: ERROR
            });
        }
    };
});
System.register('app/Core/Components/Notifier/NotifierService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Notifier/NotificationTypes.js'], function (_export) {
    var _createClass, _classCallCheck, angular, NotificationTypes, TEN_SECONDS, NotifierService;

    function addNotification(notification) {
        var _this = this;

        this.notifications.push(notification);
        this.$interval(function () {}, 0, 1);
        this.$interval(function () {
            _this.dismiss(notification);
        }, TEN_SECONDS, 1);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsNotifierNotificationTypesJs) {
            NotificationTypes = _appCoreComponentsNotifierNotificationTypesJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Constants:
            TEN_SECONDS = 10000;

            NotifierService = (function () {
                function NotifierService($interval) {
                    _classCallCheck(this, NotifierService);

                    this.$interval = $interval;
                    this.notifications = [];
                }

                _createClass(NotifierService, [{
                    key: 'success',
                    value: function success(message) {
                        addNotification.call(this, {
                            message: message,
                            type: NotificationTypes.SUCCESS
                        });
                    }
                }, {
                    key: 'info',
                    value: function info(message) {
                        addNotification.call(this, {
                            message: message,
                            type: NotificationTypes.INFO
                        });
                    }
                }, {
                    key: 'error',
                    value: function error(message) {
                        addNotification.call(this, {
                            message: message,
                            type: NotificationTypes.ERROR
                        });
                    }
                }, {
                    key: 'dismiss',
                    value: function dismiss(toRemove) {
                        this.notifications.splice(this.notifications.indexOf(toRemove), 1);
                    }
                }]);

                return NotifierService;
            })();

            _export('default', angular.module('notifierService', []).service('notifierService', function ($interval) {
                return new NotifierService($interval);
            }));
        }
    };
});
System.register('app/features/MockDataEditor/Models/MockDataModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, json, options;

    function createMockDataModelConstructor() {
        return (function () {
            function MockDataModel() {
                var _json = arguments.length <= 0 || arguments[0] === undefined ? '{}' : arguments[0];

                var _options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                _classCallCheck(this, MockDataModel);

                this[json] = _json;
                this[options] = _options;

                this.name = '';
            }

            _createClass(MockDataModel, [{
                key: 'isSaved',
                get: function get() {
                    return !!this[options].isSaved;
                }
            }, {
                key: 'path',
                get: function get() {
                    return this[options].path;
                }
            }, {
                key: 'json',
                get: function get() {
                    var formatted = undefined;
                    try {
                        formatted = JSON.stringify(JSON.parse(this[json]), null, '    ');
                    } catch (e) {
                        formatted = this[json];
                    }
                    return formatted;
                },
                set: function set(newJSON) {
                    this[json] = newJSON;
                }
            }, {
                key: 'data',
                get: function get() {
                    return this.json;
                }
            }]);

            return MockDataModel;
        })();
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {

            // Symbols:
            'use strict';

            // Dependencies:
            json = _Symbol();
            options = _Symbol();

            _export('default', angular.module('tractor.mockDataModel', []).factory('MockDataModel', createMockDataModelConstructor));
        }
    };
});
System.register('app/features/MockDataEditor/Services/MockDataParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/MockDataEditor/Models/MockDataModel.js'], function (_export) {
    var _createClass, _classCallCheck, assert, angular, MockDataModel, MockDataParserService;

    function parseMockData(mockDataModel, mockDataFile) {
        var name = mockDataFile.name;

        mockDataModel.name = name;
        assert(mockDataModel.name);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesMockDataEditorModelsMockDataModelJs) {
            MockDataModel = _appFeaturesMockDataEditorModelsMockDataModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            MockDataParserService = (function () {
                function MockDataParserService(MockDataModel) {
                    _classCallCheck(this, MockDataParserService);

                    this.MockDataModel = MockDataModel;
                }

                _createClass(MockDataParserService, [{
                    key: 'parse',
                    value: function parse(mockDataFile) {
                        try {
                            var content = mockDataFile.content;
                            var path = mockDataFile.path;

                            var mockDataModel = new this.MockDataModel(content, {
                                isSaved: true,
                                path: path
                            });

                            parseMockData(mockDataModel, mockDataFile);

                            return mockDataModel;
                        } catch (e) {
                            console.warn('Invalid mock data:', mockDataFile.content);
                            return null;
                        }
                    }
                }]);

                return MockDataParserService;
            })();

            _export('default', angular.module('tractor.mockDataParserService', [MockDataModel.name]).service('mockDataParserService', MockDataParserService));
        }
    };
});
System.registerDynamic("npm:angular-local-storage@0.2.2/dist/angular-local-storage", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(window, angular, undefined) {
    'use strict';
    var isDefined = angular.isDefined,
        isUndefined = angular.isUndefined,
        isNumber = angular.isNumber,
        isObject = angular.isObject,
        isArray = angular.isArray,
        extend = angular.extend,
        toJson = angular.toJson;
    var angularLocalStorage = angular.module('LocalStorageModule', []);
    angularLocalStorage.provider('localStorageService', function() {
      this.prefix = 'ls';
      this.storageType = 'localStorage';
      this.cookie = {
        expiry: 30,
        path: '/'
      };
      this.notify = {
        setItem: true,
        removeItem: false
      };
      this.setPrefix = function(prefix) {
        this.prefix = prefix;
        return this;
      };
      this.setStorageType = function(storageType) {
        this.storageType = storageType;
        return this;
      };
      this.setStorageCookie = function(exp, path) {
        this.cookie.expiry = exp;
        this.cookie.path = path;
        return this;
      };
      this.setStorageCookieDomain = function(domain) {
        this.cookie.domain = domain;
        return this;
      };
      this.setNotify = function(itemSet, itemRemove) {
        this.notify = {
          setItem: itemSet,
          removeItem: itemRemove
        };
        return this;
      };
      this.$get = ['$rootScope', '$window', '$document', '$parse', function($rootScope, $window, $document, $parse) {
        var self = this;
        var prefix = self.prefix;
        var cookie = self.cookie;
        var notify = self.notify;
        var storageType = self.storageType;
        var webStorage;
        if (!$document) {
          $document = document;
        } else if ($document[0]) {
          $document = $document[0];
        }
        if (prefix.substr(-1) !== '.') {
          prefix = !!prefix ? prefix + '.' : '';
        }
        var deriveQualifiedKey = function(key) {
          return prefix + key;
        };
        var browserSupportsLocalStorage = (function() {
          try {
            var supported = (storageType in $window && $window[storageType] !== null);
            var key = deriveQualifiedKey('__' + Math.round(Math.random() * 1e7));
            if (supported) {
              webStorage = $window[storageType];
              webStorage.setItem(key, '');
              webStorage.removeItem(key);
            }
            return supported;
          } catch (e) {
            storageType = 'cookie';
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
        }());
        var addToLocalStorage = function(key, value) {
          if (isUndefined(value)) {
            value = null;
          } else {
            value = toJson(value);
          }
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            if (notify.setItem) {
              $rootScope.$broadcast('LocalStorageModule.notification.setitem', {
                key: key,
                newvalue: value,
                storageType: 'cookie'
              });
            }
            return addToCookies(key, value);
          }
          try {
            if (webStorage) {
              webStorage.setItem(deriveQualifiedKey(key), value);
            }
            ;
            if (notify.setItem) {
              $rootScope.$broadcast('LocalStorageModule.notification.setitem', {
                key: key,
                newvalue: value,
                storageType: self.storageType
              });
            }
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return addToCookies(key, value);
          }
          return true;
        };
        var getFromLocalStorage = function(key) {
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            return getFromCookies(key);
          }
          var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
          if (!item || item === 'null') {
            return null;
          }
          try {
            return JSON.parse(item);
          } catch (e) {
            return item;
          }
        };
        var removeFromLocalStorage = function() {
          var i,
              key;
          for (i = 0; i < arguments.length; i++) {
            key = arguments[i];
            if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
              if (!browserSupportsLocalStorage) {
                $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
              }
              if (notify.removeItem) {
                $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                  key: key,
                  storageType: 'cookie'
                });
              }
              removeFromCookies(key);
            } else {
              try {
                webStorage.removeItem(deriveQualifiedKey(key));
                if (notify.removeItem) {
                  $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                    key: key,
                    storageType: self.storageType
                  });
                }
              } catch (e) {
                $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                removeFromCookies(key);
              }
            }
          }
        };
        var getKeysForLocalStorage = function() {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            return false;
          }
          var prefixLength = prefix.length;
          var keys = [];
          for (var key in webStorage) {
            if (key.substr(0, prefixLength) === prefix) {
              try {
                keys.push(key.substr(prefixLength));
              } catch (e) {
                $rootScope.$broadcast('LocalStorageModule.notification.error', e.Description);
                return [];
              }
            }
          }
          return keys;
        };
        var clearAllFromLocalStorage = function(regularExpression) {
          var prefixRegex = !!prefix ? new RegExp('^' + prefix) : new RegExp();
          var testRegex = !!regularExpression ? new RegExp(regularExpression) : new RegExp();
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            return clearAllFromCookies();
          }
          var prefixLength = prefix.length;
          for (var key in webStorage) {
            if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) {
              try {
                removeFromLocalStorage(key.substr(prefixLength));
              } catch (e) {
                $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                return clearAllFromCookies();
              }
            }
          }
          return true;
        };
        var browserSupportsCookies = (function() {
          try {
            return $window.navigator.cookieEnabled || ("cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1));
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
        }());
        var addToCookies = function(key, value, daysToExpiry) {
          if (isUndefined(value)) {
            return false;
          } else if (isArray(value) || isObject(value)) {
            value = toJson(value);
          }
          if (!browserSupportsCookies) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
            return false;
          }
          try {
            var expiry = '',
                expiryDate = new Date(),
                cookieDomain = '';
            if (value === null) {
              expiryDate.setTime(expiryDate.getTime() + (-1 * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
              value = '';
            } else if (isNumber(daysToExpiry) && daysToExpiry !== 0) {
              expiryDate.setTime(expiryDate.getTime() + (daysToExpiry * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
            } else if (cookie.expiry !== 0) {
              expiryDate.setTime(expiryDate.getTime() + (cookie.expiry * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
            }
            if (!!key) {
              var cookiePath = "; path=" + cookie.path;
              if (cookie.domain) {
                cookieDomain = "; domain=" + cookie.domain;
              }
              $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
            }
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
          return true;
        };
        var getFromCookies = function(key) {
          if (!browserSupportsCookies) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
            return false;
          }
          var cookies = $document.cookie && $document.cookie.split(';') || [];
          for (var i = 0; i < cookies.length; i++) {
            var thisCookie = cookies[i];
            while (thisCookie.charAt(0) === ' ') {
              thisCookie = thisCookie.substring(1, thisCookie.length);
            }
            if (thisCookie.indexOf(deriveQualifiedKey(key) + '=') === 0) {
              var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
              try {
                return JSON.parse(storedValues);
              } catch (e) {
                return storedValues;
              }
            }
          }
          return null;
        };
        var removeFromCookies = function(key) {
          addToCookies(key, null);
        };
        var clearAllFromCookies = function() {
          var thisCookie = null,
              thisKey = null;
          var prefixLength = prefix.length;
          var cookies = $document.cookie.split(';');
          for (var i = 0; i < cookies.length; i++) {
            thisCookie = cookies[i];
            while (thisCookie.charAt(0) === ' ') {
              thisCookie = thisCookie.substring(1, thisCookie.length);
            }
            var key = thisCookie.substring(prefixLength, thisCookie.indexOf('='));
            removeFromCookies(key);
          }
        };
        var getStorageType = function() {
          return storageType;
        };
        var bindToScope = function(scope, key, def, lsKey) {
          lsKey = lsKey || key;
          var value = getFromLocalStorage(lsKey);
          if (value === null && isDefined(def)) {
            value = def;
          } else if (isObject(value) && isObject(def)) {
            value = extend(def, value);
          }
          $parse(key).assign(scope, value);
          return scope.$watch(key, function(newVal) {
            addToLocalStorage(lsKey, newVal);
          }, isObject(scope[key]));
        };
        var lengthOfLocalStorage = function() {
          var count = 0;
          var storage = $window[storageType];
          for (var i = 0; i < storage.length; i++) {
            if (storage.key(i).indexOf(prefix) === 0) {
              count++;
            }
          }
          return count;
        };
        return {
          isSupported: browserSupportsLocalStorage,
          getStorageType: getStorageType,
          set: addToLocalStorage,
          add: addToLocalStorage,
          get: getFromLocalStorage,
          keys: getKeysForLocalStorage,
          remove: removeFromLocalStorage,
          clearAll: clearAllFromLocalStorage,
          bind: bindToScope,
          deriveKey: deriveQualifiedKey,
          length: lengthOfLocalStorage,
          cookie: {
            isSupported: browserSupportsCookies,
            set: addToCookies,
            add: addToCookies,
            get: getFromCookies,
            remove: removeFromCookies,
            clearAll: clearAllFromCookies
          }
        };
      }];
    });
  })(window, window.angular);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-local-storage@0.2.2", ["npm:angular-local-storage@0.2.2/dist/angular-local-storage"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-local-storage@0.2.2/dist/angular-local-storage');
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Services/PersistentStateService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'npm:angular-local-storage@0.2.2'], function (_export) {
    var _createClass, _classCallCheck, angular, PERSISTENT_STATE_KEY, PersistentStateService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_npmAngularLocalStorage022) {}],
        execute: function () {
            'use strict';

            // Constants:

            // Dependencies:
            PERSISTENT_STATE_KEY = 'PERSISTENT_STATE';

            PersistentStateService = (function () {
                function PersistentStateService(localStorageService) {
                    _classCallCheck(this, PersistentStateService);

                    this.localStorageService = localStorageService;
                }

                _createClass(PersistentStateService, [{
                    key: 'get',
                    value: function get(name) {
                        var state = this.localStorageService.get(PERSISTENT_STATE_KEY) || {};
                        return state[name] || {};
                    }
                }, {
                    key: 'set',
                    value: function set(name, value) {
                        var state = this.localStorageService.get(PERSISTENT_STATE_KEY) || {};
                        state[name] = value;
                        this.localStorageService.set(PERSISTENT_STATE_KEY, state);
                    }
                }, {
                    key: 'remove',
                    value: function remove(name) {
                        var state = this.localStorageService.get(PERSISTENT_STATE_KEY) || {};
                        delete state[name];
                        this.localStorageService.set(PERSISTENT_STATE_KEY, state);
                    }
                }]);

                return PersistentStateService;
            })();

            _export('default', angular.module('tractor.persistentStateService', ['LocalStorageModule']).service('persistentStateService', PersistentStateService).config(function (localStorageServiceProvider) {
                localStorageServiceProvider.setPrefix('tractor');
            }));
        }
    };
});
System.register('app/features/ComponentEditor/Services/FilterParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/FilterModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, FilterModel, FilterParserService;

    function tryParse(filter, ast, parsers) {
        var parsed = parsers.some(function (parser) {
            try {
                return parser(filter, ast);
            } catch (e) {}
        });
        if (!parsed) {
            throw new Error();
        }
    }

    function parseFilter(filter, ast) {
        assert(ast.callee.property.name !== 'cssContainingText');

        var _ast$arguments = _slicedToArray(ast.arguments, 1);

        var locatorLiteral = _ast$arguments[0];

        filter.locator = locatorLiteral.value;
        filter.type = ast.callee.property.name;
        return true;
    }

    function parseCSSContainingTextFilter(filter, ast) {
        assert(ast.callee.property.name === 'cssContainingText');

        var _ast$arguments2 = _slicedToArray(ast.arguments, 1);

        var allSelectorLiteral = _ast$arguments2[0];

        assert(allSelectorLiteral.value === '*');
        var locatorLiteral = ast.arguments[1];
        filter.locator = locatorLiteral.value;
        filter.type = 'text';
        return true;
    }

    function parseOptionsRepeaterIndexFilter(filter, ast) {
        assert(angular.isNumber(ast.value));
        filter.locator = String(ast.value);
        filter.type = 'text';
        return true;
    }

    function parseOptionsRepeaterTextFilter(filter, ast) {
        var _ast$body$body = _slicedToArray(ast.body.body, 1);

        var getTextThenReturnStatement = _ast$body$body[0];

        var _getTextThenReturnStatement$argument$arguments = _slicedToArray(getTextThenReturnStatement.argument.arguments, 1);

        var checkFoundTextFunctionExpression = _getTextThenReturnStatement$argument$arguments[0];

        var _checkFoundTextFunctionExpression$body$body = _slicedToArray(checkFoundTextFunctionExpression.body.body, 1);

        var checkFoundTextReturnStatement = _checkFoundTextFunctionExpression$body$body[0];

        var _checkFoundTextReturnStatement$argument$left$arguments = _slicedToArray(checkFoundTextReturnStatement.argument.left.arguments, 1);

        var locatorLiteral = _checkFoundTextReturnStatement$argument$left$arguments[0];

        filter.locator = locatorLiteral.value;
        filter.type = 'text';
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsFilterModelJs) {
            FilterModel = _appFeaturesComponentEditorModelsFilterModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            FilterParserService = (function () {
                function FilterParserService(FilterModel) {
                    _classCallCheck(this, FilterParserService);

                    this.FilterModel = FilterModel;
                }

                _createClass(FilterParserService, [{
                    key: 'parse',
                    value: function parse(element, ast) {
                        try {
                            var filter = new this.FilterModel(element);

                            var parsers = [parseFilter, parseCSSContainingTextFilter, parseOptionsRepeaterIndexFilter, parseOptionsRepeaterTextFilter];
                            tryParse(filter, ast, parsers);

                            return filter;
                        } catch (e) {
                            console.warn('Invalid filter:', ast);
                            return null;
                        }
                    }
                }]);

                return FilterParserService;
            })();

            _export('default', angular.module('tractor.filterParserService', [FilterModel.name]).service('filterParserService', FilterParserService));
        }
    };
});
System.register('app/features/ComponentEditor/Services/ElementParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ElementModel.js', 'app/features/ComponentEditor/Services/FilterParserService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, ElementModel, FilterParserService, ElementParserService;

    function tryParse(component, element, parseState, parsers) {
        var _this = this;

        var parsed = parsers.some(function (parser) {
            try {
                return parser.call(_this, component, element, parseState);
            } catch (e) {}
        });
        if (!parsed) {
            throw new Error();
        }
    }

    function parseNestedElement(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.object.callee);

        try {
            assert(callee.object.callee.property.name === 'filter');
            parseState.callee = callee.object.callee;
            parseState.expression = expression.callee.object;
        } catch (e) {}

        return this.parse(component, {
            expression: {
                right: parseState.callee.object
            }
        }, element);
    }

    function parseFirstElement(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.name === 'element');

        var _expression$arguments = _slicedToArray(expression.arguments, 1);

        var filterAST = _expression$arguments[0];

        var filter = this.filterParserService.parse(element, filterAST);
        element.addFilter(filter);
        return true;
    }

    function parseFirstElementAll(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.object.name === 'element');
        assert(callee.property.name === 'all');

        var _expression$arguments2 = _slicedToArray(expression.arguments, 1);

        var filterAllAST = _expression$arguments2[0];

        var filter = this.filterParserService.parse(element, filterAllAST);
        element.addFilter(filter);
        return true;
    }

    function parseElement(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.property.name === 'element');

        var _expression$arguments3 = _slicedToArray(expression.arguments, 1);

        var filterAST = _expression$arguments3[0];

        var filter = this.filterParserService.parse(element, filterAST);
        element.addFilter(filter);
        return true;
    }

    function parseElementAll(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.property.name === 'all');

        var _expression$arguments4 = _slicedToArray(expression.arguments, 1);

        var filterAllAST = _expression$arguments4[0];

        var filter = this.filterParserService.parse(element, filterAllAST);
        element.addFilter(filter);
        return true;
    }

    function parseFilter(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.property.name === 'filter');

        var _expression$arguments5 = _slicedToArray(expression.arguments, 1);

        var filterAST = _expression$arguments5[0];

        var filter = this.filterParserService.parse(element, filterAST);
        element.addFilter(filter);
        return true;
    }

    function parseGet(component, element, parseState) {
        var callee = parseState.callee;
        var expression = parseState.expression;

        assert(callee.property.name === 'get');

        var _expression$arguments6 = _slicedToArray(expression.arguments, 1);

        var filterAST = _expression$arguments6[0];

        var filter = this.filterParserService.parse(element, filterAST);
        element.addFilter(filter);
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsElementModelJs) {
            ElementModel = _appFeaturesComponentEditorModelsElementModelJs['default'];
        }, function (_appFeaturesComponentEditorServicesFilterParserServiceJs) {
            FilterParserService = _appFeaturesComponentEditorServicesFilterParserServiceJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            ElementParserService = (function () {
                function ElementParserService(ElementModel, filterParserService) {
                    _classCallCheck(this, ElementParserService);

                    this.ElementModel = ElementModel;
                    this.filterParserService = filterParserService;
                }

                _createClass(ElementParserService, [{
                    key: 'parse',
                    value: function parse(component, ast, element) {
                        try {
                            if (!element) {
                                element = new this.ElementModel(component);
                            }

                            var parseState = {
                                callee: ast.expression.right.callee,
                                expression: ast.expression.right
                            };

                            var parsers = [parseNestedElement, parseFirstElement, parseFirstElementAll, parseElement, parseElementAll, parseFilter, parseGet];
                            tryParse.call(this, component, element, parseState, parsers);

                            return element;
                        } catch (e) {
                            console.warn('Invalid element:', ast);
                            return null;
                        }
                    }
                }]);

                return ElementParserService;
            })();

            _export('default', angular.module('tractor.elementParserService', [ElementModel.name, FilterParserService.name]).service('elementParserService', ElementParserService));
        }
    };
});
System.register('app/features/ComponentEditor/Models/FilterModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:phenomnomnominal/dedent@master', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/Core/Services/StringToLiteralService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, dedent, angular, ASTCreatorService, StringToLiteralService, element, types;

    function createFilterModelConstructor(astCreatorService, stringToLiteralService) {
        return (function () {
            function FilterModel(_element) {
                _classCallCheck(this, FilterModel);

                this[element] = _element;
                this[types] = ['model', 'binding', 'text', 'css', 'options', 'repeater'];

                this.locator = '';

                var _types = _slicedToArray(this.types, 1);

                var type = _types[0];

                this.type = type;
            }

            _createClass(FilterModel, [{
                key: 'element',
                get: function get() {
                    return this[element];
                }
            }, {
                key: 'types',
                get: function get() {
                    return this[types];
                }
            }, {
                key: 'isGroup',
                get: function get() {
                    return this.type === 'options' || this.type === 'repeater';
                }
            }, {
                key: 'isText',
                get: function get() {
                    return this.type === 'text';
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return FilterModel;
        })();

        function toAST() {
            if (this.isNested) {
                return toNestedAST.call(this);
            } else {
                return toSingleAST.call(this);
            }
        }

        function toNestedAST() {
            var locator = astCreatorService.literal(this.locator);

            var number = stringToLiteralService.toLiteral(locator.value);
            if (angular.isNumber(number)) {
                return astCreatorService.literal(number);
            } else {
                var template = dedent('\n                (function (element) {\n                    return element.getText().then(function (text) {\n                        return text.indexOf(<%= locator %>) !== -1;\n                    });\n                });\n            ');
                return astCreatorService.expression(template, { locator: locator });
            }
        }

        function toSingleAST() {
            var locator = astCreatorService.literal(this.locator);
            var type = astCreatorService.identifier(this.type);

            var template = '';
            if (this.isText) {
                template += 'by.cssContainingText(\'*\', <%= locator %>)';
                return astCreatorService.expression(template, { locator: locator });
            } else {
                template += 'by.<%= type %>(<%= locator %>)';
                return astCreatorService.expression(template, { type: type, locator: locator });
            }
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubPhenomnomnominalDedentMaster) {
            dedent = _githubPhenomnomnominalDedentMaster['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appCoreServicesStringToLiteralServiceJs) {
            StringToLiteralService = _appCoreServicesStringToLiteralServiceJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Utilities:
            'use strict';

            // Dependencies:
            element = _Symbol();
            types = _Symbol();

            _export('default', angular.module('tractor.filterModel', [ASTCreatorService.name, StringToLiteralService.name]).factory('FilterModel', createFilterModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Models/ElementMethods.js', [], function (_export) {
    'use strict';

    var CLICK, SEND_KEYS, GET_TEXT, IS_ENABLED, IS_SELECTED, SUBMIT, CLEAR, IS_DISPLAYED, GET_OUTER_HTML, GET_INNER_HTML;
    return {
        setters: [],
        execute: function () {
            CLICK = {
                name: 'click',
                description: 'Schedules a command to click on this element.',
                returns: 'promise'
            };
            SEND_KEYS = {
                name: 'sendKeys',
                description: 'Schedules a command to type a sequence on the DOM element represented by this instance.',
                arguments: [{
                    name: 'keys',
                    description: 'The sequence of keys to type.',
                    type: 'string',
                    required: true
                }],
                returns: 'promise'
            };
            GET_TEXT = {
                name: 'getText',
                description: 'Get the visible (i.e. not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing whitespace.',
                returns: 'promise',
                promise: {
                    name: 'text',
                    type: 'string',
                    required: true
                }
            };
            IS_ENABLED = {
                name: 'isEnabled',
                description: 'Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the `disabled` attribute.',
                returns: 'promise',
                promise: {
                    name: 'enabled',
                    type: 'boolean',
                    required: true
                }
            };
            IS_SELECTED = {
                name: 'isSelected',
                description: 'Schedules a command to query whether this element is selected.',
                returns: 'promise',
                promise: {
                    name: 'selected',
                    type: 'boolean',
                    required: true
                }
            };
            SUBMIT = {
                name: 'submit',
                description: 'Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form.',
                returns: 'promise'
            };
            CLEAR = {
                name: 'clear',
                description: 'Schedules a command to clear the {@code value} of this element. This command has no effect if the underlying DOM element is neither a text INPUT element nor a TEXTAREA element.',
                returns: 'promise'
            };
            IS_DISPLAYED = {
                name: 'isDisplayed',
                description: 'Schedules a command to test whether this element is currently displayed.',
                returns: 'promise',
                promise: {
                    name: 'displayed',
                    type: 'boolean',
                    required: true
                }
            };
            GET_OUTER_HTML = {
                name: 'getOuterHtml',
                description: 'Schedules a command to retrieve the outer HTML of this element.',
                returns: 'promise',
                promise: {
                    name: 'outerHtml',
                    type: 'string',
                    required: true
                }
            };
            GET_INNER_HTML = {
                name: 'getInnerHtml',
                description: 'Schedules a command to retrieve the inner HTML of this element.',
                returns: 'promise',
                promise: {
                    name: 'innerHtml',
                    type: 'string',
                    required: true
                }
            };

            _export('default', {
                CLICK: CLICK,
                SEND_KEYS: SEND_KEYS,
                GET_TEXT: GET_TEXT,
                IS_ENABLED: IS_ENABLED,
                IS_SELECTED: IS_SELECTED,
                SUBMIT: SUBMIT,
                CLEAR: CLEAR,
                IS_DISPLAYED: IS_DISPLAYED,
                GET_OUTER_HTML: GET_OUTER_HTML,
                GET_INNER_HTML: GET_INNER_HTML
            });
        }
    };
});
System.register('app/features/ComponentEditor/Models/ElementModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/features/ComponentEditor/Models/ElementMethods.js', 'app/features/ComponentEditor/Models/FilterModel.js', 'app/Core/Services/StringToLiteralService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, changecase, angular, ASTCreatorService, ElementMethods, FilterModel, StringToLiteralService, component, filters, sortableFilters;

    function createElementModelConstructor(astCreatorService, FilterModel, stringToLiteralService) {
        return (function () {
            function ElementModel(_component) {
                _classCallCheck(this, ElementModel);

                this[component] = _component;
                this[filters] = [];
                this[sortableFilters] = [];

                this.name = '';
                this.methods = [ElementMethods.CLICK, ElementMethods.SEND_KEYS, ElementMethods.GET_TEXT, ElementMethods.IS_ENABLED, ElementMethods.IS_SELECTED, ElementMethods.SUBMIT, ElementMethods.CLEAR, ElementMethods.IS_DISPLAYED, ElementMethods.GET_OUTER_HTML, ElementMethods.GET_INNER_HTML];
            }

            _createClass(ElementModel, [{
                key: 'addFilter',
                value: function addFilter() {
                    var filter = arguments.length <= 0 || arguments[0] === undefined ? new FilterModel(this) : arguments[0];

                    this.filters.push(filter);
                    if (this.filters.length > 1) {
                        this.sortableFilters.push(filter);
                    }
                }
            }, {
                key: 'removeFilter',
                value: function removeFilter(toRemove) {
                    this.filters.splice(this.filters.findIndex(function (filter) {
                        return filter === toRemove;
                    }), 1);
                    this.sortableFilters.splice(this.sortableFilters.findIndex(function (sortableFilter) {
                        return sortableFilter === toRemove;
                    }), 1);
                }
            }, {
                key: 'getAllVariableNames',
                value: function getAllVariableNames() {
                    return this.component.getAllVariableNames(this);
                }
            }, {
                key: 'component',
                get: function get() {
                    return this[component];
                }
            }, {
                key: 'filters',
                get: function get() {
                    return this[filters];
                }
            }, {
                key: 'selector',
                get: function get() {
                    var _filters = _slicedToArray(this.filters, 1);

                    var filter = _filters[0];

                    return filter;
                }
            }, {
                key: 'sortableFilters',
                get: function get() {
                    return this[sortableFilters];
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return changecase.camel(this.name);
                }
            }, {
                key: 'meta',
                get: function get() {
                    return {
                        name: this.name
                    };
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return ElementModel;
        })();

        function toAST() {
            var element = astCreatorService.identifier(this.variableName);
            var filters = filtersAST.call(this);

            var template = 'this.<%= element %> = <%= filters %>;';

            return astCreatorService.expression(template, { element: element, filters: filters });
        }

        function filtersAST() {
            var template = '';
            var fragments = {};
            this.filters.reduce(function (previousFilter, filter, index) {
                var filterTemplate = '<%= filter' + index + ' %>';
                if (template.length) {
                    template += filterAfterFilterAST(previousFilter, filter, filterTemplate);
                } else {
                    template += filterAST(filter, filterTemplate);
                }

                fragments['filter' + index] = filter.ast;

                return filter;
            }, {});

            return astCreatorService.expression(template, fragments);
        }

        function filterAST(filter, filterTemplate) {
            if (filter.isGroup) {
                return 'element.all(' + filterTemplate + ')';
            } else {
                return 'element(' + filterTemplate + ')';
            }
        }

        function filterAfterFilterAST(previousFilter, filter, filterTemplate) {
            if (previousFilter.isGroup) {
                filter.isNested = true;
                return filterAfterGroupFilter(filter, filterTemplate);
            } else {
                return filterAfterSingleFilter(filter, filterTemplate);
            }
        }

        function filterAfterGroupFilter(filter, filterTemplate) {
            var locatorLiteral = stringToLiteralService.toLiteral(filter.locator);
            if (angular.isNumber(locatorLiteral)) {
                return '.get(' + filterTemplate + ')';
            } else {
                return '.filter(' + filterTemplate + ').get(0)';
            }
        }

        function filterAfterSingleFilter(filter, filterTemplate) {
            if (filter.isGroup) {
                return '.all(' + filterTemplate + ')';
            } else {
                return '.element(' + filterTemplate + ')';
            }
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appFeaturesComponentEditorModelsElementMethodsJs) {
            ElementMethods = _appFeaturesComponentEditorModelsElementMethodsJs['default'];
        }, function (_appFeaturesComponentEditorModelsFilterModelJs) {
            FilterModel = _appFeaturesComponentEditorModelsFilterModelJs['default'];
        }, function (_appCoreServicesStringToLiteralServiceJs) {
            StringToLiteralService = _appCoreServicesStringToLiteralServiceJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Utilities:
            'use strict';

            // Dependencies:
            component = _Symbol();
            filters = _Symbol();
            sortableFilters = _Symbol();

            _export('default', angular.module('tractor.elementModel', [ASTCreatorService.name, FilterModel.name, StringToLiteralService.name]).factory('ElementModel', createElementModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Models/BrowserMethods.js', [], function (_export) {
    'use strict';

    var GET, REFRESH, SET_LOCATION, GET_LOCATION_ABS_URL, WAIT_FOR_ANGULAR;
    return {
        setters: [],
        execute: function () {
            GET = {
                name: 'get',
                description: 'Navigate to the given destination and loads mock modules before Angular.',
                arguments: [{
                    name: 'destination',
                    description: 'Destination URL',
                    type: 'string',
                    required: true
                }, {
                    name: 'timeout',
                    description: 'Number of milliseconds to wait for Angular to start.',
                    type: 'number'
                }]
            };
            REFRESH = {
                name: 'refresh',
                description: 'Makes a full reload of the current page and loads mock modules before Angular. Assumes that the page being loaded uses Angular.',
                arguments: [{
                    name: 'timeout',
                    description: 'Number of seconds to wait for Angular to start.',
                    type: 'number'
                }]
            };
            SET_LOCATION = {
                name: 'setLocation',
                description: 'Browse to another page using in-page navigation.',
                arguments: [{
                    name: 'url',
                    description: 'In page URL using the same syntax as $location.url()',
                    type: 'string',
                    required: true
                }],
                returns: 'promise'
            };
            GET_LOCATION_ABS_URL = {
                name: 'getLocationAbsUrl',
                description: 'Returns the current absolute url from AngularJS.',
                returns: 'string',
                string: {
                    name: 'absoluteUrl',
                    type: 'string',
                    required: true
                }
            };
            WAIT_FOR_ANGULAR = {
                name: 'waitForAngular',
                description: 'Instruct webdriver to wait until Angular has finished rendering and has no outstanding $http calls before continuing.',
                returns: 'promise'
            };

            _export('default', {
                GET: GET,
                REFRESH: REFRESH,
                SET_LOCATION: SET_LOCATION,
                GET_LOCATION_ABS_URL: GET_LOCATION_ABS_URL,
                WAIT_FOR_ANGULAR: WAIT_FOR_ANGULAR
            });
        }
    };
});
System.register('app/features/ComponentEditor/Models/BrowserModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/BrowserMethods.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, BrowserMethods, name;

    function createBrowserModelConstructor() {
        return (function () {
            function BrowserModel() {
                _classCallCheck(this, BrowserModel);

                this[name] = 'browser';

                this.methods = [BrowserMethods.GET, BrowserMethods.REFRESH, BrowserMethods.SET_LOCATION, BrowserMethods.GET_LOCATION_ABS_URL, BrowserMethods.WAIT_FOR_ANGULAR];
            }

            _createClass(BrowserModel, [{
                key: 'name',
                get: function get() {
                    return this[name];
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return this[name];
                }
            }]);

            return BrowserModel;
        })();
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsBrowserMethodsJs) {
            BrowserMethods = _appFeaturesComponentEditorModelsBrowserMethodsJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Dependencies:
            'use strict';name = _Symbol();

            _export('default', angular.module('tractor.browserModel', []).factory('BrowserModel', createBrowserModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Models/ComponentModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:change-case@2.3.0', 'github:phenomnomnominal/dedent@master', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ActionModel.js', 'app/Core/Services/ASTCreatorService.js', 'app/features/ComponentEditor/Models/BrowserModel.js', 'app/features/ComponentEditor/Models/ElementModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, changecase, dedent, angular, ActionModel, ASTCreatorService, BrowserModel, ElementModel, actions, browser, domElements, elements, options;

    function createComponentModelConstructor(astCreatorService, BrowserModel, ElementModel, ActionModel) {
        return (function () {
            function ComponentModel() {
                var _options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                _classCallCheck(this, ComponentModel);

                this[actions] = [];
                this[browser] = new BrowserModel();
                this[domElements] = [];
                this[elements] = [this[browser]];
                this[options] = _options;

                this.name = '';
            }

            _createClass(ComponentModel, [{
                key: 'addElement',
                value: function addElement() {
                    var element = new ElementModel(this);
                    element.addFilter();
                    this.elements.push(element);
                    this.domElements.push(element);
                }
            }, {
                key: 'removeElement',
                value: function removeElement(toRemove) {
                    this.elements.splice(this.elements.findIndex(function (element) {
                        return element === toRemove;
                    }), 1);
                    this.domElements.splice(this.domElements.findIndex(function (domElement) {
                        return domElement === toRemove;
                    }), 1);
                }
            }, {
                key: 'addAction',
                value: function addAction() {
                    var action = new ActionModel(this);
                    this.actions.push(action);
                    action.addInteraction();
                }
            }, {
                key: 'removeAction',
                value: function removeAction(toRemove) {
                    this.actions.splice(this.actions.findIndex(function (action) {
                        return action === toRemove;
                    }), 1);
                }
            }, {
                key: 'getAllVariableNames',
                value: function getAllVariableNames() {
                    var currentObject = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];

                    var objects = [this].concat(this.elements).concat(this.actions);
                    return objects.filter(function (object) {
                        return object !== currentObject;
                    }).map(function (object) {
                        return object.name;
                    });
                }
            }, {
                key: 'isSaved',
                get: function get() {
                    return !!this[options].isSaved;
                }
            }, {
                key: 'path',
                get: function get() {
                    return this[options].path;
                }
            }, {
                key: 'actions',
                get: function get() {
                    return this[actions];
                }
            }, {
                key: 'browser',
                get: function get() {
                    return this[browser];
                }
            }, {
                key: 'domElements',
                get: function get() {
                    return this[domElements];
                }
            }, {
                key: 'elements',
                get: function get() {
                    return this[elements];
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return changecase.pascal(this.name);
                }
            }, {
                key: 'meta',
                get: function get() {
                    return JSON.stringify({
                        name: this.name,
                        elements: this.domElements.map(function (element) {
                            return element.meta;
                        }),
                        actions: this.actions.map(function (action) {
                            return action.meta;
                        })
                    });
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }, {
                key: 'data',
                get: function get() {
                    return this.ast;
                }
            }]);

            return ComponentModel;
        })();

        function toAST() {
            var component = astCreatorService.identifier(this.variableName);
            var elements = this.domElements.map(function (element) {
                return astCreatorService.expressionStatement(element.ast);
            });
            var actions = this.actions.map(function (action) {
                return astCreatorService.expressionStatement(action.ast);
            });

            var template = dedent('\n            module.exports = (function () {\n                var <%= component %> = function <%= component %> () {\n                    %= elements %;\n                };\n                %= actions %;\n                return <%= component %>\n            })();\n        ');

            return astCreatorService.file(astCreatorService.expression(template, {
                component: component,
                elements: elements,
                actions: actions
            }), this.meta);
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubPhenomnomnominalDedentMaster) {
            dedent = _githubPhenomnomnominalDedentMaster['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsActionModelJs) {
            ActionModel = _appFeaturesComponentEditorModelsActionModelJs['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appFeaturesComponentEditorModelsBrowserModelJs) {
            BrowserModel = _appFeaturesComponentEditorModelsBrowserModelJs['default'];
        }, function (_appFeaturesComponentEditorModelsElementModelJs) {
            ElementModel = _appFeaturesComponentEditorModelsElementModelJs['default'];
        }],
        execute: function () {

            // Symbols:
            'use strict';

            // Utilities:

            // Dependencies:
            actions = _Symbol();
            browser = _Symbol();
            domElements = _Symbol();
            elements = _Symbol();
            options = _Symbol();

            _export('default', angular.module('tractor.componentModel', [ActionModel.name, ASTCreatorService.name, BrowserModel.name, ElementModel.name]).factory('ComponentModel', createComponentModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Services/ParameterParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ParameterModel.js'], function (_export) {
    var _createClass, _classCallCheck, angular, ParameterModel, ParameterParserService;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsParameterModelJs) {
            ParameterModel = _appFeaturesComponentEditorModelsParameterModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';
            ParameterParserService = (function () {
                function ParameterParserService(ParameterModel) {
                    _classCallCheck(this, ParameterParserService);

                    this.ParameterModel = ParameterModel;
                }

                _createClass(ParameterParserService, [{
                    key: 'parse',
                    value: function parse(action) {
                        return new this.ParameterModel(action);
                    }
                }]);

                return ParameterParserService;
            })();

            _export('default', angular.module('tractor.parameterParserService', [ParameterModel.name]).service('parameterParserService', ParameterParserService));
        }
    };
});
System.register('app/features/ComponentEditor/Services/ArgumentParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ArgumentModel.js'], function (_export) {
    var _createClass, _classCallCheck, assert, angular, ArgumentModel, ArgumentParserService;

    function parseValue(argument, ast) {
        argument.value = ast.name || ast.value;
        assert(argument.value !== undefined);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsArgumentModelJs) {
            ArgumentModel = _appFeaturesComponentEditorModelsArgumentModelJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            ArgumentParserService = (function () {
                function ArgumentParserService(ArgumentModel) {
                    _classCallCheck(this, ArgumentParserService);

                    this.ArgumentModel = ArgumentModel;
                }

                _createClass(ArgumentParserService, [{
                    key: 'parse',
                    value: function parse(method, argument, ast) {
                        try {
                            argument = new this.ArgumentModel(method, argument);
                            parseValue(argument, ast);

                            return argument;
                        } catch (e) {
                            console.warn('Invalid argument:', ast);
                            return null;
                        }
                    }
                }]);

                return ArgumentParserService;
            })();

            _export('default', angular.module('argumentParserService', [ArgumentModel.name]).service('argumentParserService', ArgumentParserService));
        }
    };
});
System.register('app/features/ComponentEditor/Services/InteractionParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Services/ArgumentParserService.js', 'app/features/ComponentEditor/Models/InteractionModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, ArgumentParserService, InteractionModel, InteractionParserService;

    function tryParse(action, interaction, parseState, parsers) {
        var _this = this;

        var parsed = parsers.some(function (parser) {
            try {
                return parser.call(_this, action, interaction, parseState);
            } catch (e) {}
        });
        if (!parsed) {
            throw new Error();
        }
    }

    function parseNestedInteraction(action, interaction, parseState) {
        assert(parseState.argument.callee.object.callee);
        this.parse(action, {
            argument: parseState.argument.callee.object
        });
    }

    function parseFirstOwnPromiseInteraction(action, interaction, parseState) {
        parseState.expression = parseState.argument;
        assert(!parseState.expression.callee.object.callee);
        parseInteraction.call(this, action, interaction, parseState);
        return true;
    }

    function parseFirstWrappedPromiseInteraction(action, interaction, parseState) {
        var _parseState$argument$arguments = _slicedToArray(parseState.argument.arguments, 1);

        var wrappedThenFunctionExpression = _parseState$argument$arguments[0];

        var _wrappedThenFunctionExpression$body$body = _slicedToArray(wrappedThenFunctionExpression.body.body, 1);

        var interactionResolveExpressionStatement = _wrappedThenFunctionExpression$body$body[0];

        var _interactionResolveExpressionStatement$expression$arguments = _slicedToArray(interactionResolveExpressionStatement.expression.arguments, 1);

        var expression = _interactionResolveExpressionStatement$expression$arguments[0];

        parseState.expression = expression;
        parseInteraction.call(this, action, interaction, parseState);
        return true;
    }

    function parseOwnPromiseInteraction(action, interaction, parseState) {
        var _parseState$argument$arguments2 = _slicedToArray(parseState.argument.arguments, 1);

        var wrappedThenFunctionExpression = _parseState$argument$arguments2[0];

        var _wrappedThenFunctionExpression$body$body2 = _slicedToArray(wrappedThenFunctionExpression.body.body, 1);

        var wrappedNewPromiseReturnStatement = _wrappedThenFunctionExpression$body$body2[0];

        var _wrappedNewPromiseReturnStatement$argument$arguments = _slicedToArray(wrappedNewPromiseReturnStatement.argument.arguments, 1);

        var wrappedResolveFunctionExpression = _wrappedNewPromiseReturnStatement$argument$arguments[0];

        var _wrappedResolveFunctionExpression$body$body = _slicedToArray(wrappedResolveFunctionExpression.body.body, 1);

        var interactionResolveExpressionStatement = _wrappedResolveFunctionExpression$body$body[0];

        var _interactionResolveExpressionStatement$expression$arguments2 = _slicedToArray(interactionResolveExpressionStatement.expression.arguments, 1);

        var expression = _interactionResolveExpressionStatement$expression$arguments2[0];

        parseState.expression = expression;
        parseInteraction.call(this, action, interaction, parseState);
        return true;
    }

    function parseWrappedPromiseInteraction(action, interaction, parseState) {
        var _parseState$argument$arguments3 = _slicedToArray(parseState.argument.arguments, 1);

        var wrappedThenFunctionExpression = _parseState$argument$arguments3[0];

        var _wrappedThenFunctionExpression$body$body3 = _slicedToArray(wrappedThenFunctionExpression.body.body, 1);

        var interactionReturnStatement = _wrappedThenFunctionExpression$body$body3[0];

        parseState.expression = interactionReturnStatement.argument;
        parseInteraction.call(this, action, interaction, parseState);
        return true;
    }

    function parseInteraction(action, interaction, parseState) {
        var _this2 = this;

        if (parseState.expression.callee.object.name === 'browser') {
            interaction.element = action.component.browser;
        } else {
            interaction.element = action.component.elements.find(function (element) {
                return element.variableName === parseState.expression.callee.object.property.name;
            });
        }
        assert(interaction.element);
        interaction.method = interaction.element.methods.find(function (elementAction) {
            return elementAction.name === parseState.expression.callee.property.name;
        });
        assert(interaction.method);
        var args = parseState.expression.arguments.map(function (argument, index) {
            var arg = _this2.argumentParserService.parse(interaction.methodInstance, interaction.method.arguments[index], argument);
            assert(arg);
            var parameter = action.parameters.find(function (parameter) {
                return parameter.variableName === arg.value;
            });
            if (parameter) {
                arg.value = parameter.name;
            }
            return arg;
        });
        interaction.methodInstance.arguments = args;
        action.interactions.push(interaction);
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorServicesArgumentParserServiceJs) {
            ArgumentParserService = _appFeaturesComponentEditorServicesArgumentParserServiceJs['default'];
        }, function (_appFeaturesComponentEditorModelsInteractionModelJs) {
            InteractionModel = _appFeaturesComponentEditorModelsInteractionModelJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            InteractionParserService = (function () {
                function InteractionParserService(argumentParserService, InteractionModel) {
                    _classCallCheck(this, InteractionParserService);

                    this.argumentParserService = argumentParserService;
                    this.InteractionModel = InteractionModel;
                }

                _createClass(InteractionParserService, [{
                    key: 'parse',
                    value: function parse(action, ast) {
                        try {
                            var interaction = new this.InteractionModel(action);

                            var argument = ast.argument;

                            var parseState = { argument: argument };

                            var parsers = [parseNestedInteraction, parseFirstOwnPromiseInteraction, parseFirstWrappedPromiseInteraction, parseOwnPromiseInteraction, parseWrappedPromiseInteraction];
                            tryParse.call(this, action, interaction, parseState, parsers);

                            return interaction;
                        } catch (e) {
                            console.warn('Invalid interaction:', ast);
                            return null;
                        }
                    }
                }]);

                return InteractionParserService;
            })();

            _export('default', angular.module('tractor.interactionParserService', [ArgumentParserService.name, InteractionModel.name]).service('interactionParserService', InteractionParserService));
        }
    };
});
System.register('app/features/ComponentEditor/Models/ParameterModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, changecase, angular, ASTCreatorService, action;

    function createParameterModelConstructor(astCreatorService) {
        return (function () {
            function ParameterModel(_action) {
                _classCallCheck(this, ParameterModel);

                this[action] = _action;

                this.name = '';
            }

            _createClass(ParameterModel, [{
                key: 'getAllVariableNames',
                value: function getAllVariableNames() {
                    var currentParameter = this;
                    return this.action.parameters.filter(function (parameter) {
                        return parameter !== currentParameter;
                    }).map(function (object) {
                        return object.name;
                    });
                }
            }, {
                key: 'action',
                get: function get() {
                    return this[action];
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return changecase.camel(this.name);
                }
            }, {
                key: 'meta',
                get: function get() {
                    return {
                        name: this.name
                    };
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return ParameterModel;
        })();

        function toAST() {
            return astCreatorService.identifier(this.variableName);
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Dependencies:
            'use strict';

            // Utilities:
            action = _Symbol();

            _export('default', angular.module('tractor.parameterModel', [ASTCreatorService.name]).factory('ParameterModel', createParameterModelConstructor));
        }
    };
});
System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.number.is-nan", ["npm:core-js@1.2.3/library/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/library/modules/$.def');
  $def($def.S, 'Number', {isNaN: function isNaN(number) {
      return number != number;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/number/is-nan", ["npm:core-js@1.2.3/library/modules/es6.number.is-nan", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.number.is-nan');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').Number.isNaN;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/number/is-nan", ["npm:core-js@1.2.3/library/fn/number/is-nan"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/number/is-nan'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Services/StringToLiteralService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/number/is-nan', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _createClass, _classCallCheck, _Number$isNaN, angular, StringToLiteralService;

    function toBoolean(value) {
        if (value === 'true') {
            return true;
        } else if (value === 'false') {
            return false;
        }
    }

    function toNumber(value) {
        var number = parseFloat(value);
        if (value === 'NaN') {
            return NaN;
        } else if (value && angular.isNumber(number) && !_Number$isNaN(number)) {
            return number;
        }
    }

    function toNull(value) {
        if (value === 'null') {
            return null;
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsNumberIsNan) {
            _Number$isNaN = _npmBabelRuntime5825CoreJsNumberIsNan['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            StringToLiteralService = (function () {
                function StringToLiteralService() {
                    _classCallCheck(this, StringToLiteralService);
                }

                _createClass(StringToLiteralService, [{
                    key: 'toLiteral',
                    value: function toLiteral(value) {
                        var boolean = toBoolean(value);
                        var number = toNumber(value);
                        var nil = toNull(value);
                        if (boolean != null) {
                            return boolean;
                        } else if (number != null) {
                            return number;
                        } else if (nil === null) {
                            return nil;
                        } else {
                            return value;
                        }
                    }
                }]);

                return StringToLiteralService;
            })();

            _export('default', angular.module('tractor.stringToLiteralService', []).service('stringToLiteralService', StringToLiteralService));
        }
    };
});
System.register('app/features/ComponentEditor/Models/ArgumentModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/Core/Services/StringToLiteralService.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, ASTCreatorService, StringToLiteralService, argument, method;

    function createArgumentModelConstructor(astCreatorService, stringToLiteralService) {
        return (function () {
            function ArgumentModel(_method, _argument) {
                _classCallCheck(this, ArgumentModel);

                this[argument] = _argument;
                this[method] = _method;

                this.value = '';
            }

            _createClass(ArgumentModel, [{
                key: 'method',
                get: function get() {
                    return this[method] || null;
                }
            }, {
                key: 'name',
                get: function get() {
                    return this[argument] ? this[argument].name : false;
                }
            }, {
                key: 'description',
                get: function get() {
                    return this[argument] ? this[argument].description : false;
                }
            }, {
                key: 'type',
                get: function get() {
                    return this[argument] ? this[argument].type : false;
                }
            }, {
                key: 'required',
                get: function get() {
                    return this[argument] ? this[argument].required : false;
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return ArgumentModel;
        })();

        function toAST() {
            var literal = stringToLiteralService.toLiteral(this.value);
            var parameter = findParameter.call(this);
            var result = findResult.call(this);

            if (!angular.isUndefined(literal) && literal !== this.value) {
                return astCreatorService.literal(literal);
            } else if (parameter) {
                return astCreatorService.identifier(parameter.variableName);
            } else if (result) {
                return astCreatorService.identifier(this.value);
            } else if (this.value) {
                return astCreatorService.literal(this.value);
            } else {
                return astCreatorService.literal(null);
            }
        }

        function findParameter() {
            var _this = this;

            return this.method && this.method.interaction.action.parameters.find(function (parameter) {
                return parameter.name === _this.value;
            });
        }

        function findResult() {
            var _this2 = this;

            return this.method && this.method.interaction.action.interactions.find(function (interaction) {
                var returns = interaction.method[interaction.method.returns];
                return returns ? returns.name === _this2.value : false;
            });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appCoreServicesStringToLiteralServiceJs) {
            StringToLiteralService = _appCoreServicesStringToLiteralServiceJs['default'];
        }],
        execute: function () {

            // Symbols;
            'use strict';

            // Dependencies:
            argument = _Symbol();
            method = _Symbol();

            _export('default', angular.module('tractor.argumentModel', [ASTCreatorService.name, StringToLiteralService.name]).factory('ArgumentModel', createArgumentModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Models/MethodModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ArgumentModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, angular, ArgumentModel, interaction, method;

    function createMethodModelConstructor(ArgumentModel) {
        return (function () {
            function MethodModel(_interaction, _method) {
                _classCallCheck(this, MethodModel);

                this[interaction] = _interaction;
                this[method] = _method;

                this.arguments = getArguments.call(this);

                if (this.returns) {
                    this[this.returns] = this.method[this.returns];
                }
            }

            _createClass(MethodModel, [{
                key: 'interaction',
                get: function get() {
                    return this[interaction];
                }
            }, {
                key: 'method',
                get: function get() {
                    return this[method];
                }
            }, {
                key: 'name',
                get: function get() {
                    return this.method.name;
                }
            }, {
                key: 'description',
                get: function get() {
                    return this.method.description;
                }
            }, {
                key: 'returns',
                get: function get() {
                    return this.method.returns;
                }
            }]);

            return MethodModel;
        })();

        function getArguments() {
            var _this = this;

            if (this.method.arguments) {
                return this.method.arguments.map(function (argument) {
                    return new ArgumentModel(_this, argument);
                });
            } else {
                return [];
            }
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsArgumentModelJs) {
            ArgumentModel = _appFeaturesComponentEditorModelsArgumentModelJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Dependencies:
            'use strict';interaction = _Symbol();
            method = _Symbol();

            _export('default', angular.module('tractor.methodModel', [ArgumentModel.name]).factory('MethodModel', createMethodModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Models/InteractionModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:babel-runtime@5.8.25/core-js/symbol', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/features/ComponentEditor/Models/MethodModel.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, _Symbol, angular, ASTCreatorService, MethodModel, action, element, method, methodInstance;

    function createInteractionModelConstructor(astCreatorService, MethodModel) {
        return (function () {
            function InteractionModel(_action) {
                _classCallCheck(this, InteractionModel);

                this[action] = _action;
            }

            _createClass(InteractionModel, [{
                key: 'action',
                get: function get() {
                    return this[action];
                }
            }, {
                key: 'element',
                get: function get() {
                    return this[element];
                },
                set: function set(newElement) {
                    this[element] = newElement;

                    var _element$methods = _slicedToArray(this.element.methods, 1);

                    var method = _element$methods[0];

                    this.method = method;
                }
            }, {
                key: 'method',
                get: function get() {
                    return this[method];
                },
                set: function set(newMethod) {
                    this[method] = newMethod;
                    this[methodInstance] = new MethodModel(this, this.method);
                }
            }, {
                key: 'methodInstance',
                get: function get() {
                    return this[methodInstance];
                }
            }, {
                key: 'arguments',
                get: function get() {
                    return this.methodInstance.arguments;
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return InteractionModel;
        })();

        function toAST() {
            var template = '<%= interaction %>';
            if (this.methodInstance.returns !== 'promise') {
                template = 'new Promise(function (resolve) { resolve(' + template + '); });';
            }

            var interaction = interactionAST.call(this);
            return astCreatorService.expression(template, { interaction: interaction });
        }

        function interactionAST() {
            var template = '<%= element %>';
            if (this.element.variableName !== 'browser') {
                template = 'self.' + template;
            }
            template += '.<%= method %>(%= argumentValues %);';

            var element = astCreatorService.identifier(this.element.variableName);
            var method = astCreatorService.identifier(this.methodInstance.name);
            var argumentValues = this.methodInstance.arguments.map(function (argument) {
                return argument.ast;
            });

            return astCreatorService.expression(template, { element: element, method: method, argumentValues: argumentValues });
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appFeaturesComponentEditorModelsMethodModelJs) {
            MethodModel = _appFeaturesComponentEditorModelsMethodModelJs['default'];
        }],
        execute: function () {

            // Symbols:
            'use strict';

            // Dependencies:
            action = _Symbol();
            element = _Symbol();
            method = _Symbol();
            methodInstance = _Symbol();

            _export('default', angular.module('tractor.interactionModel', [ASTCreatorService.name, MethodModel.name]).factory('InteractionModel', createInteractionModelConstructor));
        }
    };
});
System.registerDynamic("npm:estraverse@1.9.3/estraverse", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
      define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
      factory(exports);
    } else {
      factory((root.estraverse = {}));
    }
  }(this, function clone(exports) {
    'use strict';
    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;
    function ignoreJSHintError() {}
    isArray = Array.isArray;
    if (!isArray) {
      isArray = function isArray(array) {
        return Object.prototype.toString.call(array) === '[object Array]';
      };
    }
    function deepCopy(obj) {
      var ret = {},
          key,
          val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === 'object' && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function shallowCopy(obj) {
      var ret = {},
          key;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    ignoreJSHintError(shallowCopy);
    function upperBound(array, func) {
      var diff,
          len,
          i,
          current;
      len = array.length;
      i = 0;
      while (len) {
        diff = len >>> 1;
        current = i + diff;
        if (func(array[current])) {
          len = diff;
        } else {
          i = current + 1;
          len -= diff + 1;
        }
      }
      return i;
    }
    function lowerBound(array, func) {
      var diff,
          len,
          i,
          current;
      len = array.length;
      i = 0;
      while (len) {
        diff = len >>> 1;
        current = i + diff;
        if (func(array[current])) {
          i = current + 1;
          len -= diff + 1;
        } else {
          len = diff;
        }
      }
      return i;
    }
    ignoreJSHintError(lowerBound);
    objectCreate = Object.create || (function() {
      function F() {}
      return function(o) {
        F.prototype = o;
        return new F();
      };
    })();
    objectKeys = Object.keys || function(o) {
      var keys = [],
          key;
      for (key in o) {
        keys.push(key);
      }
      return keys;
    };
    function extend(to, from) {
      var keys = objectKeys(from),
          key,
          i,
          len;
      for (i = 0, len = keys.length; i < len; i += 1) {
        key = keys[i];
        to[key] = from[key];
      }
      return to;
    }
    Syntax = {
      AssignmentExpression: 'AssignmentExpression',
      ArrayExpression: 'ArrayExpression',
      ArrayPattern: 'ArrayPattern',
      ArrowFunctionExpression: 'ArrowFunctionExpression',
      AwaitExpression: 'AwaitExpression',
      BlockStatement: 'BlockStatement',
      BinaryExpression: 'BinaryExpression',
      BreakStatement: 'BreakStatement',
      CallExpression: 'CallExpression',
      CatchClause: 'CatchClause',
      ClassBody: 'ClassBody',
      ClassDeclaration: 'ClassDeclaration',
      ClassExpression: 'ClassExpression',
      ComprehensionBlock: 'ComprehensionBlock',
      ComprehensionExpression: 'ComprehensionExpression',
      ConditionalExpression: 'ConditionalExpression',
      ContinueStatement: 'ContinueStatement',
      DebuggerStatement: 'DebuggerStatement',
      DirectiveStatement: 'DirectiveStatement',
      DoWhileStatement: 'DoWhileStatement',
      EmptyStatement: 'EmptyStatement',
      ExportBatchSpecifier: 'ExportBatchSpecifier',
      ExportDeclaration: 'ExportDeclaration',
      ExportSpecifier: 'ExportSpecifier',
      ExpressionStatement: 'ExpressionStatement',
      ForStatement: 'ForStatement',
      ForInStatement: 'ForInStatement',
      ForOfStatement: 'ForOfStatement',
      FunctionDeclaration: 'FunctionDeclaration',
      FunctionExpression: 'FunctionExpression',
      GeneratorExpression: 'GeneratorExpression',
      Identifier: 'Identifier',
      IfStatement: 'IfStatement',
      ImportDeclaration: 'ImportDeclaration',
      ImportDefaultSpecifier: 'ImportDefaultSpecifier',
      ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
      ImportSpecifier: 'ImportSpecifier',
      Literal: 'Literal',
      LabeledStatement: 'LabeledStatement',
      LogicalExpression: 'LogicalExpression',
      MemberExpression: 'MemberExpression',
      MethodDefinition: 'MethodDefinition',
      ModuleSpecifier: 'ModuleSpecifier',
      NewExpression: 'NewExpression',
      ObjectExpression: 'ObjectExpression',
      ObjectPattern: 'ObjectPattern',
      Program: 'Program',
      Property: 'Property',
      ReturnStatement: 'ReturnStatement',
      SequenceExpression: 'SequenceExpression',
      SpreadElement: 'SpreadElement',
      SwitchStatement: 'SwitchStatement',
      SwitchCase: 'SwitchCase',
      TaggedTemplateExpression: 'TaggedTemplateExpression',
      TemplateElement: 'TemplateElement',
      TemplateLiteral: 'TemplateLiteral',
      ThisExpression: 'ThisExpression',
      ThrowStatement: 'ThrowStatement',
      TryStatement: 'TryStatement',
      UnaryExpression: 'UnaryExpression',
      UpdateExpression: 'UpdateExpression',
      VariableDeclaration: 'VariableDeclaration',
      VariableDeclarator: 'VariableDeclarator',
      WhileStatement: 'WhileStatement',
      WithStatement: 'WithStatement',
      YieldExpression: 'YieldExpression'
    };
    VisitorKeys = {
      AssignmentExpression: ['left', 'right'],
      ArrayExpression: ['elements'],
      ArrayPattern: ['elements'],
      ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
      AwaitExpression: ['argument'],
      BlockStatement: ['body'],
      BinaryExpression: ['left', 'right'],
      BreakStatement: ['label'],
      CallExpression: ['callee', 'arguments'],
      CatchClause: ['param', 'body'],
      ClassBody: ['body'],
      ClassDeclaration: ['id', 'body', 'superClass'],
      ClassExpression: ['id', 'body', 'superClass'],
      ComprehensionBlock: ['left', 'right'],
      ComprehensionExpression: ['blocks', 'filter', 'body'],
      ConditionalExpression: ['test', 'consequent', 'alternate'],
      ContinueStatement: ['label'],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ['body', 'test'],
      EmptyStatement: [],
      ExportBatchSpecifier: [],
      ExportDeclaration: ['declaration', 'specifiers', 'source'],
      ExportSpecifier: ['id', 'name'],
      ExpressionStatement: ['expression'],
      ForStatement: ['init', 'test', 'update', 'body'],
      ForInStatement: ['left', 'right', 'body'],
      ForOfStatement: ['left', 'right', 'body'],
      FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
      FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
      GeneratorExpression: ['blocks', 'filter', 'body'],
      Identifier: [],
      IfStatement: ['test', 'consequent', 'alternate'],
      ImportDeclaration: ['specifiers', 'source'],
      ImportDefaultSpecifier: ['id'],
      ImportNamespaceSpecifier: ['id'],
      ImportSpecifier: ['id', 'name'],
      Literal: [],
      LabeledStatement: ['label', 'body'],
      LogicalExpression: ['left', 'right'],
      MemberExpression: ['object', 'property'],
      MethodDefinition: ['key', 'value'],
      ModuleSpecifier: [],
      NewExpression: ['callee', 'arguments'],
      ObjectExpression: ['properties'],
      ObjectPattern: ['properties'],
      Program: ['body'],
      Property: ['key', 'value'],
      ReturnStatement: ['argument'],
      SequenceExpression: ['expressions'],
      SpreadElement: ['argument'],
      SwitchStatement: ['discriminant', 'cases'],
      SwitchCase: ['test', 'consequent'],
      TaggedTemplateExpression: ['tag', 'quasi'],
      TemplateElement: [],
      TemplateLiteral: ['quasis', 'expressions'],
      ThisExpression: [],
      ThrowStatement: ['argument'],
      TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
      UnaryExpression: ['argument'],
      UpdateExpression: ['argument'],
      VariableDeclaration: ['declarations'],
      VariableDeclarator: ['id', 'init'],
      WhileStatement: ['test', 'body'],
      WithStatement: ['object', 'body'],
      YieldExpression: ['argument']
    };
    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace(node) {
      this.parent[this.key] = node;
    };
    Reference.prototype.remove = function remove() {
      if (isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element(node, path, wrap, ref) {
      this.node = node;
      this.path = path;
      this.wrap = wrap;
      this.ref = ref;
    }
    function Controller() {}
    Controller.prototype.path = function path() {
      var i,
          iz,
          j,
          jz,
          result,
          element;
      function addToPath(result, path) {
        if (isArray(path)) {
          for (j = 0, jz = path.length; j < jz; ++j) {
            result.push(path[j]);
          }
        } else {
          result.push(path);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function() {
      var node = this.current();
      return node.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i,
          iz,
          result;
      result = [];
      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
        result.push(this.__leavelist[i].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element) {
      var previous,
          result;
      result = undefined;
      previous = this.__current;
      this.__current = element;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function() {
      this.notify(SKIP);
    };
    Controller.prototype['break'] = function() {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function() {
      this.notify(REMOVE);
    };
    Controller.prototype.__initialize = function(root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = visitor.fallback === 'iteration';
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = extend(objectCreate(this.__keys), visitor.keys);
      }
    };
    function isNode(node) {
      if (node == null) {
        return false;
      }
      return typeof node === 'object' && typeof node.type === 'string';
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }
    Controller.prototype.traverse = function traverse(root, visitor) {
      var worklist,
          leavelist,
          element,
          node,
          nodeType,
          ret,
          key,
          current,
          current2,
          candidates,
          candidate,
          sentinel;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element(root, null, null, null));
      leavelist.push(new Element(null, null, null, null));
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element.node) {
          ret = this.__execute(visitor.enter, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node = element.node;
          nodeType = element.wrap || node.type;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = objectKeys(node);
            } else {
              throw new Error('Unknown node type ' + nodeType + '.');
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], 'Property', null);
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, null);
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace(root, visitor) {
      function removeElem(element) {
        var i,
            key,
            nextElem,
            parent;
        if (element.ref.remove()) {
          key = element.ref.key;
          parent = element.ref.parent;
          i = worklist.length;
          while (i--) {
            nextElem = worklist[i];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      var worklist,
          leavelist,
          node,
          nodeType,
          target,
          element,
          current,
          current2,
          candidates,
          candidate,
          sentinel,
          outer,
          key;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = {root: root};
      element = new Element(root, null, null, new Reference(outer, 'root'));
      worklist.push(element);
      leavelist.push(element);
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element);
          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element);
        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          element.ref.replace(target);
          element.node = target;
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node = element.node;
        if (!node) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = element.wrap || node.type;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = objectKeys(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, new Reference(node, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root, visitor) {
      var controller = new Controller();
      return controller.traverse(root, visitor);
    }
    function replace(root, visitor) {
      var controller = new Controller();
      return controller.replace(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [],
          comment,
          len,
          i,
          cursor;
      if (!tree.range) {
        throw new Error('attachComments needs range information');
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comment = deepCopy(providedComments[i]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i = 0, len = providedComments.length; i < len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      }
      cursor = 0;
      traverse(tree, {enter: function(node) {
          var comment;
          while (cursor < comments.length) {
            comment = comments[cursor];
            if (comment.extendedRange[1] > node.range[0]) {
              break;
            }
            if (comment.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                node.leadingComments = [];
              }
              node.leadingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }});
      cursor = 0;
      traverse(tree, {leave: function(node) {
          var comment;
          while (cursor < comments.length) {
            comment = comments[cursor];
            if (node.range[1] < comment.extendedRange[0]) {
              break;
            }
            if (node.range[1] === comment.extendedRange[0]) {
              if (!node.trailingComments) {
                node.trailingComments = [];
              }
              node.trailingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }});
      return tree;
    }
    exports.version = '1.8.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function() {
      return clone({});
    };
    return exports;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:estraverse@1.9.3", ["npm:estraverse@1.9.3/estraverse"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:estraverse@1.9.3/estraverse');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:esprima@1.2.5/esprima", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function(root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory((root.esprima = {}));
      }
    }(this, function(exports) {
      'use strict';
      var Token,
          TokenName,
          FnExprTokens,
          Syntax,
          PropertyKind,
          Messages,
          Regex,
          SyntaxTreeDelegate,
          source,
          strict,
          index,
          lineNumber,
          lineStart,
          length,
          delegate,
          lookahead,
          state,
          extra;
      Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
      };
      TokenName = {};
      TokenName[Token.BooleanLiteral] = 'Boolean';
      TokenName[Token.EOF] = '<end>';
      TokenName[Token.Identifier] = 'Identifier';
      TokenName[Token.Keyword] = 'Keyword';
      TokenName[Token.NullLiteral] = 'Null';
      TokenName[Token.NumericLiteral] = 'Numeric';
      TokenName[Token.Punctuator] = 'Punctuator';
      TokenName[Token.StringLiteral] = 'String';
      TokenName[Token.RegularExpression] = 'RegularExpression';
      FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
      };
      PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
      };
      Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode'
      };
      Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
      };
      function assert(condition, message) {
        if (!condition) {
          throw new Error('ASSERT: ' + message);
        }
      }
      function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);
      }
      function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
      }
      function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
      }
      function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) || (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
      }
      function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
      }
      function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) || (ch >= 0x41 && ch <= 0x5A) || (ch >= 0x61 && ch <= 0x7A) || (ch === 0x5C) || ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
      }
      function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) || (ch >= 0x41 && ch <= 0x5A) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x30 && ch <= 0x39) || (ch === 0x5C) || ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
      }
      function isFutureReservedWord(id) {
        switch (id) {
          case 'class':
          case 'enum':
          case 'export':
          case 'extends':
          case 'import':
          case 'super':
            return true;
          default:
            return false;
        }
      }
      function isStrictModeReservedWord(id) {
        switch (id) {
          case 'implements':
          case 'interface':
          case 'package':
          case 'private':
          case 'protected':
          case 'public':
          case 'static':
          case 'yield':
          case 'let':
            return true;
          default:
            return false;
        }
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
          case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try') || (id === 'let');
          case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with') || (id === 'enum');
          case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super');
          case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') || (id === 'import');
          case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
          case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
          case 10:
            return (id === 'instanceof');
          default:
            return false;
        }
      }
      function addComment(type, value, start, end, loc) {
        var comment,
            attacher;
        assert(typeof start === 'number', 'Comment must have valid position');
        if (state.lastCommentStart >= start) {
          return;
        }
        state.lastCommentStart = start;
        comment = {
          type: type,
          value: value
        };
        if (extra.range) {
          comment.range = [start, end];
        }
        if (extra.loc) {
          comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
          extra.leadingComments.push(comment);
          extra.trailingComments.push(comment);
        }
      }
      function skipSingleLineComment(offset) {
        var start,
            loc,
            ch,
            comment;
        start = index - offset;
        loc = {start: {
            line: lineNumber,
            column: index - lineStart - offset
          }};
        while (index < length) {
          ch = source.charCodeAt(index);
          ++index;
          if (isLineTerminator(ch)) {
            if (extra.comments) {
              comment = source.slice(start + offset, index - 1);
              loc.end = {
                line: lineNumber,
                column: index - lineStart - 1
              };
              addComment('Line', comment, start, index - 1, loc);
            }
            if (ch === 13 && source.charCodeAt(index) === 10) {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
            return;
          }
        }
        if (extra.comments) {
          comment = source.slice(start + offset, index);
          loc.end = {
            line: lineNumber,
            column: index - lineStart
          };
          addComment('Line', comment, start, index, loc);
        }
      }
      function skipMultiLineComment() {
        var start,
            loc,
            ch,
            comment;
        if (extra.comments) {
          start = index - 2;
          loc = {start: {
              line: lineNumber,
              column: index - lineStart - 2
            }};
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (isLineTerminator(ch)) {
            if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
              ++index;
            }
            ++lineNumber;
            ++index;
            lineStart = index;
            if (index >= length) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
          } else if (ch === 0x2A) {
            if (source.charCodeAt(index + 1) === 0x2F) {
              ++index;
              ++index;
              if (extra.comments) {
                comment = source.slice(start + 2, index - 2);
                loc.end = {
                  line: lineNumber,
                  column: index - lineStart
                };
                addComment('Block', comment, start, index, loc);
              }
              return;
            }
            ++index;
          } else {
            ++index;
          }
        }
        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }
      function skipComment() {
        var ch,
            start;
        start = (index === 0);
        while (index < length) {
          ch = source.charCodeAt(index);
          if (isWhiteSpace(ch)) {
            ++index;
          } else if (isLineTerminator(ch)) {
            ++index;
            if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
            start = true;
          } else if (ch === 0x2F) {
            ch = source.charCodeAt(index + 1);
            if (ch === 0x2F) {
              ++index;
              ++index;
              skipSingleLineComment(2);
              start = true;
            } else if (ch === 0x2A) {
              ++index;
              ++index;
              skipMultiLineComment();
            } else {
              break;
            }
          } else if (start && ch === 0x2D) {
            if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
              index += 3;
              skipSingleLineComment(3);
            } else {
              break;
            }
          } else if (ch === 0x3C) {
            if (source.slice(index + 1, index + 4) === '!--') {
              ++index;
              ++index;
              ++index;
              ++index;
              skipSingleLineComment(4);
            } else {
              break;
            }
          } else {
            break;
          }
        }
      }
      function scanHexEscape(prefix) {
        var i,
            len,
            ch,
            code = 0;
        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
          if (index < length && isHexDigit(source[index])) {
            ch = source[index++];
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
          } else {
            return '';
          }
        }
        return String.fromCharCode(code);
      }
      function getEscapedIdentifier() {
        var ch,
            id;
        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);
        if (ch === 0x5C) {
          if (source.charCodeAt(index) !== 0x75) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
          ++index;
          ch = scanHexEscape('u');
          if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
          id = ch;
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (!isIdentifierPart(ch)) {
            break;
          }
          ++index;
          id += String.fromCharCode(ch);
          if (ch === 0x5C) {
            id = id.substr(0, id.length - 1);
            if (source.charCodeAt(index) !== 0x75) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id += ch;
          }
        }
        return id;
      }
      function getIdentifier() {
        var start,
            ch;
        start = index++;
        while (index < length) {
          ch = source.charCodeAt(index);
          if (ch === 0x5C) {
            index = start;
            return getEscapedIdentifier();
          }
          if (isIdentifierPart(ch)) {
            ++index;
          } else {
            break;
          }
        }
        return source.slice(start, index);
      }
      function scanIdentifier() {
        var start,
            id,
            type;
        start = index;
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();
        if (id.length === 1) {
          type = Token.Identifier;
        } else if (isKeyword(id)) {
          type = Token.Keyword;
        } else if (id === 'null') {
          type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
          type = Token.BooleanLiteral;
        } else {
          type = Token.Identifier;
        }
        return {
          type: type,
          value: id,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;
        switch (code) {
          case 0x2E:
          case 0x28:
          case 0x29:
          case 0x3B:
          case 0x2C:
          case 0x7B:
          case 0x7D:
          case 0x5B:
          case 0x5D:
          case 0x3A:
          case 0x3F:
          case 0x7E:
            ++index;
            if (extra.tokenize) {
              if (code === 0x28) {
                extra.openParenToken = extra.tokens.length;
              } else if (code === 0x7B) {
                extra.openCurlyToken = extra.tokens.length;
              }
            }
            return {
              type: Token.Punctuator,
              value: String.fromCharCode(code),
              lineNumber: lineNumber,
              lineStart: lineStart,
              start: start,
              end: index
            };
          default:
            code2 = source.charCodeAt(index + 1);
            if (code2 === 0x3D) {
              switch (code) {
                case 0x2B:
                case 0x2D:
                case 0x2F:
                case 0x3C:
                case 0x3E:
                case 0x5E:
                case 0x7C:
                case 0x25:
                case 0x26:
                case 0x2A:
                  index += 2;
                  return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code) + String.fromCharCode(code2),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                  };
                case 0x21:
                case 0x3D:
                  index += 2;
                  if (source.charCodeAt(index) === 0x3D) {
                    ++index;
                  }
                  return {
                    type: Token.Punctuator,
                    value: source.slice(start, index),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    start: start,
                    end: index
                  };
              }
            }
        }
        ch4 = source.substr(index, 4);
        if (ch4 === '>>>=') {
          index += 4;
          return {
            type: Token.Punctuator,
            value: ch4,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        ch3 = ch4.substr(0, 3);
        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: ch3,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        ch2 = ch3.substr(0, 2);
        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
          index += 2;
          return {
            type: Token.Punctuator,
            value: ch2,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
          ++index;
          return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }
      function scanHexLiteral(start) {
        var number = '';
        while (index < length) {
          if (!isHexDigit(source[index])) {
            break;
          }
          number += source[index++];
        }
        if (number.length === 0) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt('0x' + number, 16),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
          if (!isOctalDigit(source[index])) {
            break;
          }
          number += source[index++];
        }
        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt(number, 8),
          octal: true,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function isImplicitOctalLiteral() {
        var i,
            ch;
        for (i = index + 1; i < length; ++i) {
          ch = source[i];
          if (ch === '8' || ch === '9') {
            return false;
          }
          if (!isOctalDigit(ch)) {
            return true;
          }
        }
        return true;
      }
      function scanNumericLiteral() {
        var number,
            start,
            ch;
        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
        start = index;
        number = '';
        if (ch !== '.') {
          number = source[index++];
          ch = source[index];
          if (number === '0') {
            if (ch === 'x' || ch === 'X') {
              ++index;
              return scanHexLiteral(start);
            }
            if (isOctalDigit(ch)) {
              if (isImplicitOctalLiteral()) {
                return scanOctalLiteral(start);
              }
            }
          }
          while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
          }
          ch = source[index];
        }
        if (ch === '.') {
          number += source[index++];
          while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
          }
          ch = source[index];
        }
        if (ch === 'e' || ch === 'E') {
          number += source[index++];
          ch = source[index];
          if (ch === '+' || ch === '-') {
            number += source[index++];
          }
          if (isDecimalDigit(source.charCodeAt(index))) {
            while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
            }
          } else {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
          type: Token.NumericLiteral,
          value: parseFloat(number),
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function scanStringLiteral() {
        var str = '',
            quote,
            start,
            ch,
            code,
            unescaped,
            restore,
            octal = false,
            startLineNumber,
            startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        quote = source[index];
        assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
        start = index;
        ++index;
        while (index < length) {
          ch = source[index++];
          if (ch === quote) {
            quote = '';
            break;
          } else if (ch === '\\') {
            ch = source[index++];
            if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
              switch (ch) {
                case 'u':
                case 'x':
                  restore = index;
                  unescaped = scanHexEscape(ch);
                  if (unescaped) {
                    str += unescaped;
                  } else {
                    index = restore;
                    str += ch;
                  }
                  break;
                case 'n':
                  str += '\n';
                  break;
                case 'r':
                  str += '\r';
                  break;
                case 't':
                  str += '\t';
                  break;
                case 'b':
                  str += '\b';
                  break;
                case 'f':
                  str += '\f';
                  break;
                case 'v':
                  str += '\x0B';
                  break;
                default:
                  if (isOctalDigit(ch)) {
                    code = '01234567'.indexOf(ch);
                    if (code !== 0) {
                      octal = true;
                    }
                    if (index < length && isOctalDigit(source[index])) {
                      octal = true;
                      code = code * 8 + '01234567'.indexOf(source[index++]);
                      if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                        code = code * 8 + '01234567'.indexOf(source[index++]);
                      }
                    }
                    str += String.fromCharCode(code);
                  } else {
                    str += ch;
                  }
                  break;
              }
            } else {
              ++lineNumber;
              if (ch === '\r' && source[index] === '\n') {
                ++index;
              }
              lineStart = index;
            }
          } else if (isLineTerminator(ch.charCodeAt(0))) {
            break;
          } else {
            str += ch;
          }
        }
        if (quote !== '') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
          type: Token.StringLiteral,
          value: str,
          octal: octal,
          startLineNumber: startLineNumber,
          startLineStart: startLineStart,
          lineNumber: lineNumber,
          lineStart: lineStart,
          start: start,
          end: index
        };
      }
      function testRegExp(pattern, flags) {
        var value;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
          throwError({}, Messages.InvalidRegExp);
        }
        return value;
      }
      function scanRegExpBody() {
        var ch,
            str,
            classMarker,
            terminated,
            body;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];
        classMarker = false;
        terminated = false;
        while (index < length) {
          ch = source[index++];
          str += ch;
          if (ch === '\\') {
            ch = source[index++];
            if (isLineTerminator(ch.charCodeAt(0))) {
              throwError({}, Messages.UnterminatedRegExp);
            }
            str += ch;
          } else if (isLineTerminator(ch.charCodeAt(0))) {
            throwError({}, Messages.UnterminatedRegExp);
          } else if (classMarker) {
            if (ch === ']') {
              classMarker = false;
            }
          } else {
            if (ch === '/') {
              terminated = true;
              break;
            } else if (ch === '[') {
              classMarker = true;
            }
          }
        }
        if (!terminated) {
          throwError({}, Messages.UnterminatedRegExp);
        }
        body = str.substr(1, str.length - 2);
        return {
          value: body,
          literal: str
        };
      }
      function scanRegExpFlags() {
        var ch,
            str,
            flags,
            restore;
        str = '';
        flags = '';
        while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch.charCodeAt(0))) {
            break;
          }
          ++index;
          if (ch === '\\' && index < length) {
            ch = source[index];
            if (ch === 'u') {
              ++index;
              restore = index;
              ch = scanHexEscape('u');
              if (ch) {
                flags += ch;
                for (str += '\\u'; restore < index; ++restore) {
                  str += source[restore];
                }
              } else {
                index = restore;
                flags += 'u';
                str += '\\u';
              }
              throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
            } else {
              str += '\\';
              throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
          } else {
            flags += ch;
            str += ch;
          }
        }
        return {
          value: flags,
          literal: str
        };
      }
      function scanRegExp() {
        var start,
            body,
            flags,
            pattern,
            value;
        lookahead = null;
        skipComment();
        start = index;
        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        if (extra.tokenize) {
          return {
            type: Token.RegularExpression,
            value: value,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
          };
        }
        return {
          literal: body.literal + flags.literal,
          value: value,
          start: start,
          end: index
        };
      }
      function collectRegex() {
        var pos,
            loc,
            regex,
            token;
        skipComment();
        pos = index;
        loc = {start: {
            line: lineNumber,
            column: index - lineStart
          }};
        regex = scanRegExp();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (!extra.tokenize) {
          if (extra.tokens.length > 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos && token.type === 'Punctuator') {
              if (token.value === '/' || token.value === '/=') {
                extra.tokens.pop();
              }
            }
          }
          extra.tokens.push({
            type: 'RegularExpression',
            value: regex.literal,
            range: [pos, index],
            loc: loc
          });
        }
        return regex;
      }
      function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
      }
      function advanceSlash() {
        var prevToken,
            checkToken;
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
          return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
          if (prevToken.value === ']') {
            return scanPunctuator();
          }
          if (prevToken.value === ')') {
            checkToken = extra.tokens[extra.openParenToken - 1];
            if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
              return collectRegex();
            }
            return scanPunctuator();
          }
          if (prevToken.value === '}') {
            if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
              checkToken = extra.tokens[extra.openCurlyToken - 4];
              if (!checkToken) {
                return scanPunctuator();
              }
            } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
              checkToken = extra.tokens[extra.openCurlyToken - 5];
              if (!checkToken) {
                return collectRegex();
              }
            } else {
              return scanPunctuator();
            }
            if (FnExprTokens.indexOf(checkToken.value) >= 0) {
              return scanPunctuator();
            }
            return collectRegex();
          }
          return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
          return collectRegex();
        }
        return scanPunctuator();
      }
      function advance() {
        var ch;
        skipComment();
        if (index >= length) {
          return {
            type: Token.EOF,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
          };
        }
        ch = source.charCodeAt(index);
        if (isIdentifierStart(ch)) {
          return scanIdentifier();
        }
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
          return scanPunctuator();
        }
        if (ch === 0x27 || ch === 0x22) {
          return scanStringLiteral();
        }
        if (ch === 0x2E) {
          if (isDecimalDigit(source.charCodeAt(index + 1))) {
            return scanNumericLiteral();
          }
          return scanPunctuator();
        }
        if (isDecimalDigit(ch)) {
          return scanNumericLiteral();
        }
        if (extra.tokenize && ch === 0x2F) {
          return advanceSlash();
        }
        return scanPunctuator();
      }
      function collectToken() {
        var loc,
            token,
            range,
            value;
        skipComment();
        loc = {start: {
            line: lineNumber,
            column: index - lineStart
          }};
        token = advance();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (token.type !== Token.EOF) {
          value = source.slice(token.start, token.end);
          extra.tokens.push({
            type: TokenName[token.type],
            value: value,
            range: [token.start, token.end],
            loc: loc
          });
        }
        return token;
      }
      function lex() {
        var token;
        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        return token;
      }
      function peek() {
        var pos,
            line,
            start;
        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
      }
      function Position(line, column) {
        this.line = line;
        this.column = column;
      }
      function SourceLocation(startLine, startColumn, line, column) {
        this.start = new Position(startLine, startColumn);
        this.end = new Position(line, column);
      }
      SyntaxTreeDelegate = {
        name: 'SyntaxTree',
        processComment: function(node) {
          var lastChild,
              trailingComments;
          if (node.type === Syntax.Program) {
            if (node.body.length > 0) {
              return;
            }
          }
          if (extra.trailingComments.length > 0) {
            if (extra.trailingComments[0].range[0] >= node.range[1]) {
              trailingComments = extra.trailingComments;
              extra.trailingComments = [];
            } else {
              extra.trailingComments.length = 0;
            }
          } else {
            if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
              trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
              delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
            }
          }
          while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
            lastChild = extra.bottomRightStack.pop();
          }
          if (lastChild) {
            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
              node.leadingComments = lastChild.leadingComments;
              delete lastChild.leadingComments;
            }
          } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
            node.leadingComments = extra.leadingComments;
            extra.leadingComments = [];
          }
          if (trailingComments) {
            node.trailingComments = trailingComments;
          }
          extra.bottomRightStack.push(node);
        },
        markEnd: function(node, startToken) {
          if (extra.range) {
            node.range = [startToken.start, index];
          }
          if (extra.loc) {
            node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);
            this.postProcess(node);
          }
          if (extra.attachComment) {
            this.processComment(node);
          }
          return node;
        },
        postProcess: function(node) {
          if (extra.source) {
            node.loc.source = extra.source;
          }
          return node;
        },
        createArrayExpression: function(elements) {
          return {
            type: Syntax.ArrayExpression,
            elements: elements
          };
        },
        createAssignmentExpression: function(operator, left, right) {
          return {
            type: Syntax.AssignmentExpression,
            operator: operator,
            left: left,
            right: right
          };
        },
        createBinaryExpression: function(operator, left, right) {
          var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
          return {
            type: type,
            operator: operator,
            left: left,
            right: right
          };
        },
        createBlockStatement: function(body) {
          return {
            type: Syntax.BlockStatement,
            body: body
          };
        },
        createBreakStatement: function(label) {
          return {
            type: Syntax.BreakStatement,
            label: label
          };
        },
        createCallExpression: function(callee, args) {
          return {
            type: Syntax.CallExpression,
            callee: callee,
            'arguments': args
          };
        },
        createCatchClause: function(param, body) {
          return {
            type: Syntax.CatchClause,
            param: param,
            body: body
          };
        },
        createConditionalExpression: function(test, consequent, alternate) {
          return {
            type: Syntax.ConditionalExpression,
            test: test,
            consequent: consequent,
            alternate: alternate
          };
        },
        createContinueStatement: function(label) {
          return {
            type: Syntax.ContinueStatement,
            label: label
          };
        },
        createDebuggerStatement: function() {
          return {type: Syntax.DebuggerStatement};
        },
        createDoWhileStatement: function(body, test) {
          return {
            type: Syntax.DoWhileStatement,
            body: body,
            test: test
          };
        },
        createEmptyStatement: function() {
          return {type: Syntax.EmptyStatement};
        },
        createExpressionStatement: function(expression) {
          return {
            type: Syntax.ExpressionStatement,
            expression: expression
          };
        },
        createForStatement: function(init, test, update, body) {
          return {
            type: Syntax.ForStatement,
            init: init,
            test: test,
            update: update,
            body: body
          };
        },
        createForInStatement: function(left, right, body) {
          return {
            type: Syntax.ForInStatement,
            left: left,
            right: right,
            body: body,
            each: false
          };
        },
        createFunctionDeclaration: function(id, params, defaults, body) {
          return {
            type: Syntax.FunctionDeclaration,
            id: id,
            params: params,
            defaults: defaults,
            body: body,
            rest: null,
            generator: false,
            expression: false
          };
        },
        createFunctionExpression: function(id, params, defaults, body) {
          return {
            type: Syntax.FunctionExpression,
            id: id,
            params: params,
            defaults: defaults,
            body: body,
            rest: null,
            generator: false,
            expression: false
          };
        },
        createIdentifier: function(name) {
          return {
            type: Syntax.Identifier,
            name: name
          };
        },
        createIfStatement: function(test, consequent, alternate) {
          return {
            type: Syntax.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate
          };
        },
        createLabeledStatement: function(label, body) {
          return {
            type: Syntax.LabeledStatement,
            label: label,
            body: body
          };
        },
        createLiteral: function(token) {
          return {
            type: Syntax.Literal,
            value: token.value,
            raw: source.slice(token.start, token.end)
          };
        },
        createMemberExpression: function(accessor, object, property) {
          return {
            type: Syntax.MemberExpression,
            computed: accessor === '[',
            object: object,
            property: property
          };
        },
        createNewExpression: function(callee, args) {
          return {
            type: Syntax.NewExpression,
            callee: callee,
            'arguments': args
          };
        },
        createObjectExpression: function(properties) {
          return {
            type: Syntax.ObjectExpression,
            properties: properties
          };
        },
        createPostfixExpression: function(operator, argument) {
          return {
            type: Syntax.UpdateExpression,
            operator: operator,
            argument: argument,
            prefix: false
          };
        },
        createProgram: function(body) {
          return {
            type: Syntax.Program,
            body: body
          };
        },
        createProperty: function(kind, key, value) {
          return {
            type: Syntax.Property,
            key: key,
            value: value,
            kind: kind
          };
        },
        createReturnStatement: function(argument) {
          return {
            type: Syntax.ReturnStatement,
            argument: argument
          };
        },
        createSequenceExpression: function(expressions) {
          return {
            type: Syntax.SequenceExpression,
            expressions: expressions
          };
        },
        createSwitchCase: function(test, consequent) {
          return {
            type: Syntax.SwitchCase,
            test: test,
            consequent: consequent
          };
        },
        createSwitchStatement: function(discriminant, cases) {
          return {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
          };
        },
        createThisExpression: function() {
          return {type: Syntax.ThisExpression};
        },
        createThrowStatement: function(argument) {
          return {
            type: Syntax.ThrowStatement,
            argument: argument
          };
        },
        createTryStatement: function(block, guardedHandlers, handlers, finalizer) {
          return {
            type: Syntax.TryStatement,
            block: block,
            guardedHandlers: guardedHandlers,
            handlers: handlers,
            finalizer: finalizer
          };
        },
        createUnaryExpression: function(operator, argument) {
          if (operator === '++' || operator === '--') {
            return {
              type: Syntax.UpdateExpression,
              operator: operator,
              argument: argument,
              prefix: true
            };
          }
          return {
            type: Syntax.UnaryExpression,
            operator: operator,
            argument: argument,
            prefix: true
          };
        },
        createVariableDeclaration: function(declarations, kind) {
          return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: kind
          };
        },
        createVariableDeclarator: function(id, init) {
          return {
            type: Syntax.VariableDeclarator,
            id: id,
            init: init
          };
        },
        createWhileStatement: function(test, body) {
          return {
            type: Syntax.WhileStatement,
            test: test,
            body: body
          };
        },
        createWithStatement: function(object, body) {
          return {
            type: Syntax.WithStatement,
            object: object,
            body: body
          };
        }
      };
      function peekLineTerminator() {
        var pos,
            line,
            start,
            found;
        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;
        return found;
      }
      function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(/%(\d)/g, function(whole, index) {
              assert(index < args.length, 'Message reference must be in range');
              return args[index];
            });
        if (typeof token.lineNumber === 'number') {
          error = new Error('Line ' + token.lineNumber + ': ' + msg);
          error.index = token.start;
          error.lineNumber = token.lineNumber;
          error.column = token.start - lineStart + 1;
        } else {
          error = new Error('Line ' + lineNumber + ': ' + msg);
          error.index = index;
          error.lineNumber = lineNumber;
          error.column = index - lineStart + 1;
        }
        error.description = msg;
        throw error;
      }
      function throwErrorTolerant() {
        try {
          throwError.apply(null, arguments);
        } catch (e) {
          if (extra.errors) {
            extra.errors.push(e);
          } else {
            throw e;
          }
        }
      }
      function throwUnexpected(token) {
        if (token.type === Token.EOF) {
          throwError(token, Messages.UnexpectedEOS);
        }
        if (token.type === Token.NumericLiteral) {
          throwError(token, Messages.UnexpectedNumber);
        }
        if (token.type === Token.StringLiteral) {
          throwError(token, Messages.UnexpectedString);
        }
        if (token.type === Token.Identifier) {
          throwError(token, Messages.UnexpectedIdentifier);
        }
        if (token.type === Token.Keyword) {
          if (isFutureReservedWord(token.value)) {
            throwError(token, Messages.UnexpectedReserved);
          } else if (strict && isStrictModeReservedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictReservedWord);
            return;
          }
          throwError(token, Messages.UnexpectedToken, token.value);
        }
        throwError(token, Messages.UnexpectedToken, token.value);
      }
      function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
          throwUnexpected(token);
        }
      }
      function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
          throwUnexpected(token);
        }
      }
      function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
      }
      function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
      }
      function matchAssign() {
        var op;
        if (lookahead.type !== Token.Punctuator) {
          return false;
        }
        op = lookahead.value;
        return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
      }
      function consumeSemicolon() {
        var line,
            oldIndex = index,
            oldLineNumber = lineNumber,
            oldLineStart = lineStart,
            oldLookahead = lookahead;
        if (source.charCodeAt(index) === 0x3B || match(';')) {
          lex();
          return;
        }
        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
          index = oldIndex;
          lineNumber = oldLineNumber;
          lineStart = oldLineStart;
          lookahead = oldLookahead;
          return;
        }
        if (lookahead.type !== Token.EOF && !match('}')) {
          throwUnexpected(lookahead);
        }
      }
      function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
      }
      function parseArrayInitialiser() {
        var elements = [],
            startToken;
        startToken = lookahead;
        expect('[');
        while (!match(']')) {
          if (match(',')) {
            lex();
            elements.push(null);
          } else {
            elements.push(parseAssignmentExpression());
            if (!match(']')) {
              expect(',');
            }
          }
        }
        lex();
        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
      }
      function parsePropertyFunction(param, first) {
        var previousStrict,
            body,
            startToken;
        previousStrict = strict;
        startToken = lookahead;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
          throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
      }
      function parseObjectPropertyKey() {
        var token,
            startToken;
        startToken = lookahead;
        token = lex();
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
          if (strict && token.octal) {
            throwErrorTolerant(token, Messages.StrictOctalLiteral);
          }
          return delegate.markEnd(delegate.createLiteral(token), startToken);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
      }
      function parseObjectProperty() {
        var token,
            key,
            id,
            value,
            param,
            startToken;
        token = lookahead;
        startToken = lookahead;
        if (token.type === Token.Identifier) {
          id = parseObjectPropertyKey();
          if (token.value === 'get' && !match(':')) {
            key = parseObjectPropertyKey();
            expect('(');
            expect(')');
            value = parsePropertyFunction([]);
            return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
          }
          if (token.value === 'set' && !match(':')) {
            key = parseObjectPropertyKey();
            expect('(');
            token = lookahead;
            if (token.type !== Token.Identifier) {
              expect(')');
              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
              value = parsePropertyFunction([]);
            } else {
              param = [parseVariableIdentifier()];
              expect(')');
              value = parsePropertyFunction(param, token);
            }
            return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
          }
          expect(':');
          value = parseAssignmentExpression();
          return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
          throwUnexpected(token);
        } else {
          key = parseObjectPropertyKey();
          expect(':');
          value = parseAssignmentExpression();
          return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
        }
      }
      function parseObjectInitialiser() {
        var properties = [],
            property,
            name,
            key,
            kind,
            map = {},
            toString = String,
            startToken;
        startToken = lookahead;
        expect('{');
        while (!match('}')) {
          property = parseObjectProperty();
          if (property.key.type === Syntax.Identifier) {
            name = property.key.name;
          } else {
            name = toString(property.key.value);
          }
          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
          key = '$' + name;
          if (Object.prototype.hasOwnProperty.call(map, key)) {
            if (map[key] === PropertyKind.Data) {
              if (strict && kind === PropertyKind.Data) {
                throwErrorTolerant({}, Messages.StrictDuplicateProperty);
              } else if (kind !== PropertyKind.Data) {
                throwErrorTolerant({}, Messages.AccessorDataProperty);
              }
            } else {
              if (kind === PropertyKind.Data) {
                throwErrorTolerant({}, Messages.AccessorDataProperty);
              } else if (map[key] & kind) {
                throwErrorTolerant({}, Messages.AccessorGetSet);
              }
            }
            map[key] |= kind;
          } else {
            map[key] = kind;
          }
          properties.push(property);
          if (!match('}')) {
            expect(',');
          }
        }
        expect('}');
        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
      }
      function parseGroupExpression() {
        var expr;
        expect('(');
        expr = parseExpression();
        expect(')');
        return expr;
      }
      function parsePrimaryExpression() {
        var type,
            token,
            expr,
            startToken;
        if (match('(')) {
          return parseGroupExpression();
        }
        if (match('[')) {
          return parseArrayInitialiser();
        }
        if (match('{')) {
          return parseObjectInitialiser();
        }
        type = lookahead.type;
        startToken = lookahead;
        if (type === Token.Identifier) {
          expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
          if (strict && lookahead.octal) {
            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
          }
          expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
          if (matchKeyword('function')) {
            return parseFunctionExpression();
          }
          if (matchKeyword('this')) {
            lex();
            expr = delegate.createThisExpression();
          } else {
            throwUnexpected(lex());
          }
        } else if (type === Token.BooleanLiteral) {
          token = lex();
          token.value = (token.value === 'true');
          expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
          token = lex();
          token.value = null;
          expr = delegate.createLiteral(token);
        } else if (match('/') || match('/=')) {
          if (typeof extra.tokens !== 'undefined') {
            expr = delegate.createLiteral(collectRegex());
          } else {
            expr = delegate.createLiteral(scanRegExp());
          }
          peek();
        } else {
          throwUnexpected(lex());
        }
        return delegate.markEnd(expr, startToken);
      }
      function parseArguments() {
        var args = [];
        expect('(');
        if (!match(')')) {
          while (index < length) {
            args.push(parseAssignmentExpression());
            if (match(')')) {
              break;
            }
            expect(',');
          }
        }
        expect(')');
        return args;
      }
      function parseNonComputedProperty() {
        var token,
            startToken;
        startToken = lookahead;
        token = lex();
        if (!isIdentifierName(token)) {
          throwUnexpected(token);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
      }
      function parseNonComputedMember() {
        expect('.');
        return parseNonComputedProperty();
      }
      function parseComputedMember() {
        var expr;
        expect('[');
        expr = parseExpression();
        expect(']');
        return expr;
      }
      function parseNewExpression() {
        var callee,
            args,
            startToken;
        startToken = lookahead;
        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];
        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
      }
      function parseLeftHandSideExpressionAllowCall() {
        var expr,
            args,
            property,
            startToken,
            previousAllowIn = state.allowIn;
        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        for (; ; ) {
          if (match('.')) {
            property = parseNonComputedMember();
            expr = delegate.createMemberExpression('.', expr, property);
          } else if (match('(')) {
            args = parseArguments();
            expr = delegate.createCallExpression(expr, args);
          } else if (match('[')) {
            property = parseComputedMember();
            expr = delegate.createMemberExpression('[', expr, property);
          } else {
            break;
          }
          delegate.markEnd(expr, startToken);
        }
        state.allowIn = previousAllowIn;
        return expr;
      }
      function parseLeftHandSideExpression() {
        var expr,
            property,
            startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');
        startToken = lookahead;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        while (match('.') || match('[')) {
          if (match('[')) {
            property = parseComputedMember();
            expr = delegate.createMemberExpression('[', expr, property);
          } else {
            property = parseNonComputedMember();
            expr = delegate.createMemberExpression('.', expr, property);
          }
          delegate.markEnd(expr, startToken);
        }
        return expr;
      }
      function parsePostfixExpression() {
        var expr,
            token,
            startToken = lookahead;
        expr = parseLeftHandSideExpressionAllowCall();
        if (lookahead.type === Token.Punctuator) {
          if ((match('++') || match('--')) && !peekLineTerminator()) {
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
              throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }
            if (!isLeftHandSide(expr)) {
              throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }
            token = lex();
            expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
          }
        }
        return expr;
      }
      function parseUnaryExpression() {
        var token,
            expr,
            startToken;
        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
          expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            throwErrorTolerant({}, Messages.StrictLHSPrefix);
          }
          if (!isLeftHandSide(expr)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          expr = delegate.createUnaryExpression(token.value, expr);
          expr = delegate.markEnd(expr, startToken);
        } else if (match('+') || match('-') || match('~') || match('!')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = delegate.createUnaryExpression(token.value, expr);
          expr = delegate.markEnd(expr, startToken);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = delegate.createUnaryExpression(token.value, expr);
          expr = delegate.markEnd(expr, startToken);
          if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
            throwErrorTolerant({}, Messages.StrictDelete);
          }
        } else {
          expr = parsePostfixExpression();
        }
        return expr;
      }
      function binaryPrecedence(token, allowIn) {
        var prec = 0;
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
          return 0;
        }
        switch (token.value) {
          case '||':
            prec = 1;
            break;
          case '&&':
            prec = 2;
            break;
          case '|':
            prec = 3;
            break;
          case '^':
            prec = 4;
            break;
          case '&':
            prec = 5;
            break;
          case '==':
          case '!=':
          case '===':
          case '!==':
            prec = 6;
            break;
          case '<':
          case '>':
          case '<=':
          case '>=':
          case 'instanceof':
            prec = 7;
            break;
          case 'in':
            prec = allowIn ? 7 : 0;
            break;
          case '<<':
          case '>>':
          case '>>>':
            prec = 8;
            break;
          case '+':
          case '-':
            prec = 9;
            break;
          case '*':
          case '/':
          case '%':
            prec = 11;
            break;
          default:
            break;
        }
        return prec;
      }
      function parseBinaryExpression() {
        var marker,
            markers,
            expr,
            token,
            prec,
            stack,
            right,
            operator,
            left,
            i;
        marker = lookahead;
        left = parseUnaryExpression();
        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
          return left;
        }
        token.prec = prec;
        lex();
        markers = [marker, lookahead];
        right = parseUnaryExpression();
        stack = [left, token, right];
        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
            right = stack.pop();
            operator = stack.pop().value;
            left = stack.pop();
            expr = delegate.createBinaryExpression(operator, left, right);
            markers.pop();
            marker = markers[markers.length - 1];
            delegate.markEnd(expr, marker);
            stack.push(expr);
          }
          token = lex();
          token.prec = prec;
          stack.push(token);
          markers.push(lookahead);
          expr = parseUnaryExpression();
          stack.push(expr);
        }
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
          expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
          i -= 2;
          marker = markers.pop();
          delegate.markEnd(expr, marker);
        }
        return expr;
      }
      function parseConditionalExpression() {
        var expr,
            previousAllowIn,
            consequent,
            alternate,
            startToken;
        startToken = lookahead;
        expr = parseBinaryExpression();
        if (match('?')) {
          lex();
          previousAllowIn = state.allowIn;
          state.allowIn = true;
          consequent = parseAssignmentExpression();
          state.allowIn = previousAllowIn;
          expect(':');
          alternate = parseAssignmentExpression();
          expr = delegate.createConditionalExpression(expr, consequent, alternate);
          delegate.markEnd(expr, startToken);
        }
        return expr;
      }
      function parseAssignmentExpression() {
        var token,
            left,
            right,
            node,
            startToken;
        token = lookahead;
        startToken = lookahead;
        node = left = parseConditionalExpression();
        if (matchAssign()) {
          if (!isLeftHandSide(left)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
            throwErrorTolerant(token, Messages.StrictLHSAssignment);
          }
          token = lex();
          right = parseAssignmentExpression();
          node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
        }
        return node;
      }
      function parseExpression() {
        var expr,
            startToken = lookahead;
        expr = parseAssignmentExpression();
        if (match(',')) {
          expr = delegate.createSequenceExpression([expr]);
          while (index < length) {
            if (!match(',')) {
              break;
            }
            lex();
            expr.expressions.push(parseAssignmentExpression());
          }
          delegate.markEnd(expr, startToken);
        }
        return expr;
      }
      function parseStatementList() {
        var list = [],
            statement;
        while (index < length) {
          if (match('}')) {
            break;
          }
          statement = parseSourceElement();
          if (typeof statement === 'undefined') {
            break;
          }
          list.push(statement);
        }
        return list;
      }
      function parseBlock() {
        var block,
            startToken;
        startToken = lookahead;
        expect('{');
        block = parseStatementList();
        expect('}');
        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
      }
      function parseVariableIdentifier() {
        var token,
            startToken;
        startToken = lookahead;
        token = lex();
        if (token.type !== Token.Identifier) {
          throwUnexpected(token);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
      }
      function parseVariableDeclaration(kind) {
        var init = null,
            id,
            startToken;
        startToken = lookahead;
        id = parseVariableIdentifier();
        if (strict && isRestrictedWord(id.name)) {
          throwErrorTolerant({}, Messages.StrictVarName);
        }
        if (kind === 'const') {
          expect('=');
          init = parseAssignmentExpression();
        } else if (match('=')) {
          lex();
          init = parseAssignmentExpression();
        }
        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
      }
      function parseVariableDeclarationList(kind) {
        var list = [];
        do {
          list.push(parseVariableDeclaration(kind));
          if (!match(',')) {
            break;
          }
          lex();
        } while (index < length);
        return list;
      }
      function parseVariableStatement() {
        var declarations;
        expectKeyword('var');
        declarations = parseVariableDeclarationList();
        consumeSemicolon();
        return delegate.createVariableDeclaration(declarations, 'var');
      }
      function parseConstLetDeclaration(kind) {
        var declarations,
            startToken;
        startToken = lookahead;
        expectKeyword(kind);
        declarations = parseVariableDeclarationList(kind);
        consumeSemicolon();
        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
      }
      function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
      }
      function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
      }
      function parseIfStatement() {
        var test,
            consequent,
            alternate;
        expectKeyword('if');
        expect('(');
        test = parseExpression();
        expect(')');
        consequent = parseStatement();
        if (matchKeyword('else')) {
          lex();
          alternate = parseStatement();
        } else {
          alternate = null;
        }
        return delegate.createIfStatement(test, consequent, alternate);
      }
      function parseDoWhileStatement() {
        var body,
            test,
            oldInIteration;
        expectKeyword('do');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        if (match(';')) {
          lex();
        }
        return delegate.createDoWhileStatement(body, test);
      }
      function parseWhileStatement() {
        var test,
            body,
            oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return delegate.createWhileStatement(test, body);
      }
      function parseForVariableDeclaration() {
        var token,
            declarations,
            startToken;
        startToken = lookahead;
        token = lex();
        declarations = parseVariableDeclarationList();
        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
      }
      function parseForStatement() {
        var init,
            test,
            update,
            left,
            right,
            body,
            oldInIteration,
            previousAllowIn = state.allowIn;
        init = test = update = null;
        expectKeyword('for');
        expect('(');
        if (match(';')) {
          lex();
        } else {
          if (matchKeyword('var') || matchKeyword('let')) {
            state.allowIn = false;
            init = parseForVariableDeclaration();
            state.allowIn = previousAllowIn;
            if (init.declarations.length === 1 && matchKeyword('in')) {
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          } else {
            state.allowIn = false;
            init = parseExpression();
            state.allowIn = previousAllowIn;
            if (matchKeyword('in')) {
              if (!isLeftHandSide(init)) {
                throwErrorTolerant({}, Messages.InvalidLHSInForIn);
              }
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          }
          if (typeof left === 'undefined') {
            expect(';');
          }
        }
        if (typeof left === 'undefined') {
          if (!match(';')) {
            test = parseExpression();
          }
          expect(';');
          if (!match(')')) {
            update = parseExpression();
          }
        }
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return (typeof left === 'undefined') ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
      }
      function parseContinueStatement() {
        var label = null,
            key;
        expectKeyword('continue');
        if (source.charCodeAt(index) === 0x3B) {
          lex();
          if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
          }
          return delegate.createContinueStatement(null);
        }
        if (peekLineTerminator()) {
          if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
          }
          return delegate.createContinueStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
          label = parseVariableIdentifier();
          key = '$' + label.name;
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !state.inIteration) {
          throwError({}, Messages.IllegalContinue);
        }
        return delegate.createContinueStatement(label);
      }
      function parseBreakStatement() {
        var label = null,
            key;
        expectKeyword('break');
        if (source.charCodeAt(index) === 0x3B) {
          lex();
          if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
          }
          return delegate.createBreakStatement(null);
        }
        if (peekLineTerminator()) {
          if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
          }
          return delegate.createBreakStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
          label = parseVariableIdentifier();
          key = '$' + label.name;
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !(state.inIteration || state.inSwitch)) {
          throwError({}, Messages.IllegalBreak);
        }
        return delegate.createBreakStatement(label);
      }
      function parseReturnStatement() {
        var argument = null;
        expectKeyword('return');
        if (!state.inFunctionBody) {
          throwErrorTolerant({}, Messages.IllegalReturn);
        }
        if (source.charCodeAt(index) === 0x20) {
          if (isIdentifierStart(source.charCodeAt(index + 1))) {
            argument = parseExpression();
            consumeSemicolon();
            return delegate.createReturnStatement(argument);
          }
        }
        if (peekLineTerminator()) {
          return delegate.createReturnStatement(null);
        }
        if (!match(';')) {
          if (!match('}') && lookahead.type !== Token.EOF) {
            argument = parseExpression();
          }
        }
        consumeSemicolon();
        return delegate.createReturnStatement(argument);
      }
      function parseWithStatement() {
        var object,
            body;
        if (strict) {
          skipComment();
          throwErrorTolerant({}, Messages.StrictModeWith);
        }
        expectKeyword('with');
        expect('(');
        object = parseExpression();
        expect(')');
        body = parseStatement();
        return delegate.createWithStatement(object, body);
      }
      function parseSwitchCase() {
        var test,
            consequent = [],
            statement,
            startToken;
        startToken = lookahead;
        if (matchKeyword('default')) {
          lex();
          test = null;
        } else {
          expectKeyword('case');
          test = parseExpression();
        }
        expect(':');
        while (index < length) {
          if (match('}') || matchKeyword('default') || matchKeyword('case')) {
            break;
          }
          statement = parseStatement();
          consequent.push(statement);
        }
        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
      }
      function parseSwitchStatement() {
        var discriminant,
            cases,
            clause,
            oldInSwitch,
            defaultFound;
        expectKeyword('switch');
        expect('(');
        discriminant = parseExpression();
        expect(')');
        expect('{');
        cases = [];
        if (match('}')) {
          lex();
          return delegate.createSwitchStatement(discriminant, cases);
        }
        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while (index < length) {
          if (match('}')) {
            break;
          }
          clause = parseSwitchCase();
          if (clause.test === null) {
            if (defaultFound) {
              throwError({}, Messages.MultipleDefaultsInSwitch);
            }
            defaultFound = true;
          }
          cases.push(clause);
        }
        state.inSwitch = oldInSwitch;
        expect('}');
        return delegate.createSwitchStatement(discriminant, cases);
      }
      function parseThrowStatement() {
        var argument;
        expectKeyword('throw');
        if (peekLineTerminator()) {
          throwError({}, Messages.NewlineAfterThrow);
        }
        argument = parseExpression();
        consumeSemicolon();
        return delegate.createThrowStatement(argument);
      }
      function parseCatchClause() {
        var param,
            body,
            startToken;
        startToken = lookahead;
        expectKeyword('catch');
        expect('(');
        if (match(')')) {
          throwUnexpected(lookahead);
        }
        param = parseVariableIdentifier();
        if (strict && isRestrictedWord(param.name)) {
          throwErrorTolerant({}, Messages.StrictCatchVariable);
        }
        expect(')');
        body = parseBlock();
        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
      }
      function parseTryStatement() {
        var block,
            handlers = [],
            finalizer = null;
        expectKeyword('try');
        block = parseBlock();
        if (matchKeyword('catch')) {
          handlers.push(parseCatchClause());
        }
        if (matchKeyword('finally')) {
          lex();
          finalizer = parseBlock();
        }
        if (handlers.length === 0 && !finalizer) {
          throwError({}, Messages.NoCatchOrFinally);
        }
        return delegate.createTryStatement(block, [], handlers, finalizer);
      }
      function parseDebuggerStatement() {
        expectKeyword('debugger');
        consumeSemicolon();
        return delegate.createDebuggerStatement();
      }
      function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            startToken;
        if (type === Token.EOF) {
          throwUnexpected(lookahead);
        }
        if (type === Token.Punctuator && lookahead.value === '{') {
          return parseBlock();
        }
        startToken = lookahead;
        if (type === Token.Punctuator) {
          switch (lookahead.value) {
            case ';':
              return delegate.markEnd(parseEmptyStatement(), startToken);
            case '(':
              return delegate.markEnd(parseExpressionStatement(), startToken);
            default:
              break;
          }
        }
        if (type === Token.Keyword) {
          switch (lookahead.value) {
            case 'break':
              return delegate.markEnd(parseBreakStatement(), startToken);
            case 'continue':
              return delegate.markEnd(parseContinueStatement(), startToken);
            case 'debugger':
              return delegate.markEnd(parseDebuggerStatement(), startToken);
            case 'do':
              return delegate.markEnd(parseDoWhileStatement(), startToken);
            case 'for':
              return delegate.markEnd(parseForStatement(), startToken);
            case 'function':
              return delegate.markEnd(parseFunctionDeclaration(), startToken);
            case 'if':
              return delegate.markEnd(parseIfStatement(), startToken);
            case 'return':
              return delegate.markEnd(parseReturnStatement(), startToken);
            case 'switch':
              return delegate.markEnd(parseSwitchStatement(), startToken);
            case 'throw':
              return delegate.markEnd(parseThrowStatement(), startToken);
            case 'try':
              return delegate.markEnd(parseTryStatement(), startToken);
            case 'var':
              return delegate.markEnd(parseVariableStatement(), startToken);
            case 'while':
              return delegate.markEnd(parseWhileStatement(), startToken);
            case 'with':
              return delegate.markEnd(parseWithStatement(), startToken);
            default:
              break;
          }
        }
        expr = parseExpression();
        if ((expr.type === Syntax.Identifier) && match(':')) {
          lex();
          key = '$' + expr.name;
          if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.Redeclaration, 'Label', expr.name);
          }
          state.labelSet[key] = true;
          labeledBody = parseStatement();
          delete state.labelSet[key];
          return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
        }
        consumeSemicolon();
        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
      }
      function parseFunctionSourceElements() {
        var sourceElement,
            sourceElements = [],
            token,
            directive,
            firstRestricted,
            oldLabelSet,
            oldInIteration,
            oldInSwitch,
            oldInFunctionBody,
            startToken;
        startToken = lookahead;
        expect('{');
        while (index < length) {
          if (lookahead.type !== Token.StringLiteral) {
            break;
          }
          token = lookahead;
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === 'use strict') {
            strict = true;
            if (firstRestricted) {
              throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        while (index < length) {
          if (match('}')) {
            break;
          }
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
            break;
          }
          sourceElements.push(sourceElement);
        }
        expect('}');
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
      }
      function parseParams(firstRestricted) {
        var param,
            params = [],
            token,
            stricted,
            paramSet,
            key,
            message;
        expect('(');
        if (!match(')')) {
          paramSet = {};
          while (index < length) {
            token = lookahead;
            param = parseVariableIdentifier();
            key = '$' + token.value;
            if (strict) {
              if (isRestrictedWord(token.value)) {
                stricted = token;
                message = Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                stricted = token;
                message = Messages.StrictParamDupe;
              }
            } else if (!firstRestricted) {
              if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictParamName;
              } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                firstRestricted = token;
                message = Messages.StrictParamDupe;
              }
            }
            params.push(param);
            paramSet[key] = true;
            if (match(')')) {
              break;
            }
            expect(',');
          }
        }
        expect(')');
        return {
          params: params,
          stricted: stricted,
          firstRestricted: firstRestricted,
          message: message
        };
      }
      function parseFunctionDeclaration() {
        var id,
            params = [],
            body,
            token,
            stricted,
            tmp,
            firstRestricted,
            message,
            previousStrict,
            startToken;
        startToken = lookahead;
        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
          if (isRestrictedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictFunctionName);
          }
        } else {
          if (isRestrictedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictFunctionName;
          } else if (isStrictModeReservedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictReservedWord;
          }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
          message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwError(firstRestricted, message);
        }
        if (strict && stricted) {
          throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
      }
      function parseFunctionExpression() {
        var token,
            id = null,
            stricted,
            firstRestricted,
            message,
            tmp,
            params = [],
            body,
            previousStrict,
            startToken;
        startToken = lookahead;
        expectKeyword('function');
        if (!match('(')) {
          token = lookahead;
          id = parseVariableIdentifier();
          if (strict) {
            if (isRestrictedWord(token.value)) {
              throwErrorTolerant(token, Messages.StrictFunctionName);
            }
          } else {
            if (isRestrictedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictReservedWord;
            }
          }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
          message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwError(firstRestricted, message);
        }
        if (strict && stricted) {
          throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
      }
      function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
          switch (lookahead.value) {
            case 'const':
            case 'let':
              return parseConstLetDeclaration(lookahead.value);
            case 'function':
              return parseFunctionDeclaration();
            default:
              return parseStatement();
          }
        }
        if (lookahead.type !== Token.EOF) {
          return parseStatement();
        }
      }
      function parseSourceElements() {
        var sourceElement,
            sourceElements = [],
            token,
            directive,
            firstRestricted;
        while (index < length) {
          token = lookahead;
          if (token.type !== Token.StringLiteral) {
            break;
          }
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === 'use strict') {
            strict = true;
            if (firstRestricted) {
              throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        while (index < length) {
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
            break;
          }
          sourceElements.push(sourceElement);
        }
        return sourceElements;
      }
      function parseProgram() {
        var body,
            startToken;
        skipComment();
        peek();
        startToken = lookahead;
        strict = false;
        body = parseSourceElements();
        return delegate.markEnd(delegate.createProgram(body), startToken);
      }
      function filterTokenLocation() {
        var i,
            entry,
            token,
            tokens = [];
        for (i = 0; i < extra.tokens.length; ++i) {
          entry = extra.tokens[i];
          token = {
            type: entry.type,
            value: entry.value
          };
          if (extra.range) {
            token.range = entry.range;
          }
          if (extra.loc) {
            token.loc = entry.loc;
          }
          tokens.push(token);
        }
        extra.tokens = tokens;
      }
      function tokenize(code, options) {
        var toString,
            token,
            tokens;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
        }
        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
        };
        extra = {};
        options = options || {};
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;
        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;
        if (typeof options.comment === 'boolean' && options.comment) {
          extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
          extra.errors = [];
        }
        try {
          peek();
          if (lookahead.type === Token.EOF) {
            return extra.tokens;
          }
          token = lex();
          while (lookahead.type !== Token.EOF) {
            try {
              token = lex();
            } catch (lexError) {
              token = lookahead;
              if (extra.errors) {
                extra.errors.push(lexError);
                break;
              } else {
                throw lexError;
              }
            }
          }
          filterTokenLocation();
          tokens = extra.tokens;
          if (typeof extra.comments !== 'undefined') {
            tokens.comments = extra.comments;
          }
          if (typeof extra.errors !== 'undefined') {
            tokens.errors = extra.errors;
          }
        } catch (e) {
          throw e;
        } finally {
          extra = {};
        }
        return tokens;
      }
      function parse(code, options) {
        var program,
            toString;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
        }
        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
        };
        extra = {};
        if (typeof options !== 'undefined') {
          extra.range = (typeof options.range === 'boolean') && options.range;
          extra.loc = (typeof options.loc === 'boolean') && options.loc;
          extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;
          if (extra.loc && options.source !== null && options.source !== undefined) {
            extra.source = toString(options.source);
          }
          if (typeof options.tokens === 'boolean' && options.tokens) {
            extra.tokens = [];
          }
          if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
          }
          if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
          }
          if (extra.attachComment) {
            extra.range = true;
            extra.comments = [];
            extra.bottomRightStack = [];
            extra.trailingComments = [];
            extra.leadingComments = [];
          }
        }
        try {
          program = parseProgram();
          if (typeof extra.comments !== 'undefined') {
            program.comments = extra.comments;
          }
          if (typeof extra.tokens !== 'undefined') {
            filterTokenLocation();
            program.tokens = extra.tokens;
          }
          if (typeof extra.errors !== 'undefined') {
            program.errors = extra.errors;
          }
        } catch (e) {
          throw e;
        } finally {
          extra = {};
        }
        return program;
      }
      exports.version = '1.2.5';
      exports.tokenize = tokenize;
      exports.parse = parse;
      exports.Syntax = (function() {
        var name,
            types = {};
        if (typeof Object.create === 'function') {
          types = Object.create(null);
        }
        for (name in Syntax) {
          if (Syntax.hasOwnProperty(name)) {
            types[name] = Syntax[name];
          }
        }
        if (typeof Object.freeze === 'function') {
          Object.freeze(types);
        }
        return types;
      }());
    }));
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:esprima@1.2.5", ["npm:esprima@1.2.5/esprima"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:esprima@1.2.5/esprima');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:estemplate@0.4.0/lib/estemplate", ["npm:esprima@1.2.5", "npm:estraverse@1.9.3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var parse = $__require('npm:esprima@1.2.5').parse;
  var estraverse = $__require('npm:estraverse@1.9.3');
  var reCode = /([^\s,;]?)\s*?%(=?)\s*([\s\S]+?)\s*%\s*?([^\s,;]?)/g;
  var reInternalVar = /^__ASTER_DATA_\d+$/;
  var reInternalMarker = /\"(__ASTER_DATA_\d+)\"/g;
  function tmpl(str, options, data) {
    if (!data) {
      data = options;
      options = undefined;
    }
    return tmpl.compile(str, options)(data);
  }
  function isInternalVar(node) {
    return node.type === 'Identifier' && reInternalVar.test(node.name);
  }
  function isInternalStmt(node) {
    return node.type === 'ExpressionStatement' && typeof node.expression === 'string';
  }
  var brackets = {
    '<': '>',
    '[': ']',
    '(': ')',
    '{': '}',
    "'": "'",
    '"': '"'
  };
  var spread = {
    'ArrayExpression': 'elements',
    'CallExpression': 'arguments',
    'BlockStatement': 'body',
    'FunctionExpression': 'params',
    'FunctionDeclaration': 'params'
  };
  tmpl.fixAST = function(ast) {
    estraverse.traverse(ast, {
      leave: function(node, parent) {
        if (node.type !== '...') {
          return;
        }
        var itemsKey = spread[parent.type];
        if (!itemsKey) {
          throw new TypeError('Unknown substitution in ' + parent.type);
        }
        parent[itemsKey] = parent[itemsKey].reduce(function(items, item) {
          if (item.type === '...') {
            return items.concat(item.argument);
          }
          items.push(item);
          return items;
        }, []);
      },
      keys: {'...': ['argument']}
    });
    return ast;
  };
  tmpl.compile = function(str, options) {
    var code = [],
        index = 0;
    str = str.replace(reCode, function(match, open, isEval, codePart, close) {
      if (open) {
        var expectedClose = brackets[open];
        if (!expectedClose || close && expectedClose !== close) {
          return match;
        }
      }
      if (isEval) {
        var varName = '__ASTER_DATA_' + (index++);
        var isSpread = open !== '<' && open !== "'" && open !== '"';
        if (isSpread) {
          codePart = '{type: "...", argument: ' + codePart + '}';
        } else if (open === "'" || open === '"') {
          codePart = '{type: "Literal", value: ' + codePart + '}';
        }
        code.push('\t\tvar ' + varName + ' = ' + codePart);
        return isSpread ? (open + varName + close) : varName;
      } else {
        if (open !== '<') {
          return match;
        }
        code.push(codePart);
        return '';
      }
    });
    var ast = parse(str, options);
    ast = estraverse.replace(ast, {leave: function(node) {
        if (isInternalVar(node)) {
          return node.name;
        }
        if (isInternalStmt(node)) {
          return node.expression;
        }
      }});
    if (!(options && options.fast)) {
      code.unshift('\twith (it) {');
      code.push('\t}');
    }
    code.unshift('return function template(it) {');
    code.push('\treturn estemplate.fixAST(' + JSON.stringify(ast).replace(reInternalMarker, '$1') + ')', '}');
    return new Function('estemplate', code.join('\n'))(tmpl);
  };
  module.exports = tmpl;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:estemplate@0.4.0", ["npm:estemplate@0.4.0/lib/estemplate"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:estemplate@0.4.0/lib/estemplate');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isregexp@3.0.3/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var regexpTag = '[object RegExp]';
  var objectProto = Object.prototype;
  var objToString = objectProto.toString;
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isRegExp(value) {
    return isObject(value) && objToString.call(value) == regexpTag;
  }
  module.exports = isRegExp;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash.isregexp@3.0.3", ["npm:lodash.isregexp@3.0.3/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash.isregexp@3.0.3/index');
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Services/ASTCreatorService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:lodash.isregexp@3.0.3', 'github:angular/bower-angular@1.4.7', 'npm:estemplate@0.4.0'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, isRegExp, angular, estemplate, ASTCreatorService;

    function program() {
        var body = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
        var comments = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        return {
            type: 'Program',
            body: body,
            comments: comments
        };
    }

    function blockComment(value) {
        return {
            type: 'Block',
            value: value
        };
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmLodashIsregexp303) {
            isRegExp = _npmLodashIsregexp303['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_npmEstemplate040) {
            estemplate = _npmEstemplate040['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            ASTCreatorService = (function () {
                function ASTCreatorService() {
                    _classCallCheck(this, ASTCreatorService);
                }

                _createClass(ASTCreatorService, [{
                    key: 'file',
                    value: function file(expression, meta) {
                        return program([this.expressionStatement(expression)], [blockComment(meta)]);
                    }
                }, {
                    key: 'expression',
                    value: function expression(template) {
                        var objects = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var _estemplate$body = _slicedToArray(estemplate(template, objects).body, 1);

                        var ast = _estemplate$body[0];

                        return ast ? ast.expression || ast.value || ast : null;
                    }
                }, {
                    key: 'template',
                    value: function template(_template) {
                        var objects = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var _estemplate$body2 = _slicedToArray(estemplate(_template, objects).body, 1);

                        var statement = _estemplate$body2[0];

                        return statement;
                    }
                }, {
                    key: 'expressionStatement',
                    value: function expressionStatement(expression) {
                        return {
                            type: 'ExpressionStatement',
                            expression: expression
                        };
                    }
                }, {
                    key: 'identifier',
                    value: function identifier(name) {
                        return {
                            type: 'Identifier',
                            name: name
                        };
                    }
                }, {
                    key: 'literal',
                    value: function literal(value) {
                        var lit = {
                            type: 'Literal',
                            value: value
                        };
                        if (isRegExp(value)) {
                            lit.raw = '' + value;
                        }
                        return lit;
                    }
                }]);

                return ASTCreatorService;
            })();

            _export('default', angular.module('tractor.astCreatorService', []).service('astCreatorService', ASTCreatorService));
        }
    };
});
System.registerDynamic("github:phenomnomnominal/dedent@master/dist/dedent", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function dedent(strings) {
    var raw = undefined;
    if (typeof strings === "string") {
      raw = [strings];
    } else {
      raw = strings.raw;
    }
    var result = "";
    for (var _len = arguments.length,
        values = Array(_len > 1 ? _len - 1 : 0),
        _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    for (var i = 0; i < raw.length; i++) {
      result += raw[i].replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`");
      if (i < values.length) {
        result += values[i];
      }
    }
    var lines = result.split("\n");
    var mindent = null;
    lines.forEach(function(l) {
      var m = l.match(/^(\s+)\S+/);
      if (m) {
        var indent = m[1].length;
        if (!mindent) {
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    });
    if (mindent !== null) {
      result = lines.map(function(l) {
        return l[0] === " " ? l.slice(mindent) : l;
      }).join("\n");
    }
    result = result.trim();
    return result.replace(/\\n/g, "\n");
  }
  if (typeof module !== "undefined") {
    module.exports = dedent;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:phenomnomnominal/dedent@master", ["github:phenomnomnominal/dedent@master/dist/dedent"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:phenomnomnominal/dedent@master/dist/dedent');
  global.define = __define;
  return module.exports;
});

System.register('app/features/ComponentEditor/Models/ActionModel.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/core-js/symbol', 'npm:change-case@2.3.0', 'github:phenomnomnominal/dedent@master', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/ASTCreatorService.js', 'app/features/ComponentEditor/Models/InteractionModel.js', 'app/features/ComponentEditor/Models/ParameterModel.js'], function (_export) {
    var _createClass, _classCallCheck, _Symbol, changecase, dedent, angular, ASTCreatorService, InteractionModel, ParameterModel, component, interactions, parameters;

    function createActionModelConstructor(astCreatorService, InteractionModel, ParameterModel) {
        return (function () {
            function ActionModel(_component) {
                _classCallCheck(this, ActionModel);

                this[component] = _component;
                this[interactions] = [];
                this[parameters] = [];

                this.name = '';
            }

            _createClass(ActionModel, [{
                key: 'addParameter',
                value: function addParameter() {
                    var parameter = arguments.length <= 0 || arguments[0] === undefined ? new ParameterModel(this) : arguments[0];

                    this.parameters.push(parameter);
                }
            }, {
                key: 'removeParameter',
                value: function removeParameter(toRemove) {
                    this.parameters.splice(this.parameters.findIndex(function (parameter) {
                        return parameter === toRemove;
                    }), 1);
                }
            }, {
                key: 'addInteraction',
                value: function addInteraction() {
                    var interaction = arguments.length <= 0 || arguments[0] === undefined ? new InteractionModel(this) : arguments[0];

                    interaction.element = interaction.element || this[component].browser;
                    this.interactions.push(interaction);
                }
            }, {
                key: 'removeInteraction',
                value: function removeInteraction(toRemove) {
                    this.interactions.splice(this.interactions.findIndex(function (interaction) {
                        return interaction === toRemove;
                    }), 1);
                }
            }, {
                key: 'getAllVariableNames',
                value: function getAllVariableNames() {
                    return this[component].getAllVariableNames(this);
                }
            }, {
                key: 'component',
                get: function get() {
                    return this[component];
                }
            }, {
                key: 'interactions',
                get: function get() {
                    return this[interactions];
                }
            }, {
                key: 'parameters',
                get: function get() {
                    return this[parameters];
                }
            }, {
                key: 'variableName',
                get: function get() {
                    return changecase.camel(this.name);
                }
            }, {
                key: 'meta',
                get: function get() {
                    return {
                        name: this.name,
                        parameters: this.parameters.map(function (parameter) {
                            return parameter.meta;
                        })
                    };
                }
            }, {
                key: 'ast',
                get: function get() {
                    return toAST.call(this);
                }
            }]);

            return ActionModel;
        })();

        function toAST() {
            var component = astCreatorService.identifier(this.component.variableName);
            var action = astCreatorService.identifier(this.variableName);
            var parameters = this.parameters.map(function (parameter) {
                return parameter.ast;
            });
            var interactions = interactionsAST.call(this);

            var template = '<%= component %>.prototype.<%= action %> = function (%= parameters %) {';
            if (interactions) {
                template += dedent('\n                var self = this;\n                return <%= interactions %>;\n            ');
            }
            template += '};';

            return astCreatorService.expression(template, { component: component, action: action, parameters: parameters, interactions: interactions });
        }

        function interactionsAST() {
            var template = '';
            var fragments = {};
            this.interactions.reduce(function (previousInteraction, interaction, index) {
                var interactionTemplate = '<%= interaction' + index + ' %>';

                if (template.length) {
                    template += dedent('\n                    .then(function (%= parameter' + index + ' %) {\n                        return ' + interactionTemplate + ';\n                    })\n                ');
                } else {
                    template += interactionTemplate;
                }

                fragments['interaction' + index] = interaction.ast;
                fragments['parameter' + index] = [];

                var previousResult = previousInteractionResult(previousInteraction);
                if (previousResult) {
                    var parameter = astCreatorService.identifier(previousResult);
                    fragments['parameter' + index].push(parameter);
                }

                return interaction;
            }, {});

            return astCreatorService.expression(template, fragments);
        }

        function previousInteractionResult(previous) {
            var returns = previous && previous.method && previous.method.returns;
            if (returns && previous.method[returns]) {
                return previous.method[returns].name;
            }
        }
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825CoreJsSymbol) {
            _Symbol = _npmBabelRuntime5825CoreJsSymbol['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubPhenomnomnominalDedentMaster) {
            dedent = _githubPhenomnomnominalDedentMaster['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesASTCreatorServiceJs) {
            ASTCreatorService = _appCoreServicesASTCreatorServiceJs['default'];
        }, function (_appFeaturesComponentEditorModelsInteractionModelJs) {
            InteractionModel = _appFeaturesComponentEditorModelsInteractionModelJs['default'];
        }, function (_appFeaturesComponentEditorModelsParameterModelJs) {
            ParameterModel = _appFeaturesComponentEditorModelsParameterModelJs['default'];
        }],
        execute: function () {

            // Symbols:

            // Dependencies:

            // Utilities:
            'use strict';component = _Symbol();
            interactions = _Symbol();
            parameters = _Symbol();

            _export('default', angular.module('tractor.actionModel', [ASTCreatorService.name, InteractionModel.name, ParameterModel.name]).factory('ActionModel', createActionModelConstructor));
        }
    };
});
System.register('app/features/ComponentEditor/Services/ActionParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Models/ActionModel.js', 'app/features/ComponentEditor/Services/InteractionParserService.js', 'app/features/ComponentEditor/Services/ParameterParserService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, ActionModel, InteractionParserService, ParameterParserService, ActionParserService;

    function parseParameters(action, params, meta) {
        var _this = this;

        params.forEach(function () {
            var parameter = _this.parameterParserService.parse(action);
            assert(parameter);
            parameter.name = meta.parameters[action.parameters.length].name;
            action.addParameter(parameter);
        });
    }

    function tryParse(action, statements, parsers) {
        var _this2 = this;

        statements.forEach(function (statement) {
            var parsed = parsers.some(function (parser) {
                try {
                    return parser.call(_this2, action, statement);
                } catch (e) {}
            });
            if (!parsed) {
                throw new Error();
            }
        });
    }

    function parseSelfThis(action, statement) {
        var _statement$declarations = _slicedToArray(statement.declarations, 1);

        var selfVariableDeclarator = _statement$declarations[0];

        assert(selfVariableDeclarator.id.name === 'self');
        assert(selfVariableDeclarator.init.type === 'ThisExpression');
        return true;
    }

    function parseInteraction(action, statement) {
        this.interactionParserService.parse(action, statement);
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorModelsActionModelJs) {
            ActionModel = _appFeaturesComponentEditorModelsActionModelJs['default'];
        }, function (_appFeaturesComponentEditorServicesInteractionParserServiceJs) {
            InteractionParserService = _appFeaturesComponentEditorServicesInteractionParserServiceJs['default'];
        }, function (_appFeaturesComponentEditorServicesParameterParserServiceJs) {
            ParameterParserService = _appFeaturesComponentEditorServicesParameterParserServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            ActionParserService = (function () {
                function ActionParserService(ActionModel, interactionParserService, parameterParserService) {
                    _classCallCheck(this, ActionParserService);

                    this.ActionModel = ActionModel;
                    this.interactionParserService = interactionParserService;
                    this.parameterParserService = parameterParserService;
                }

                _createClass(ActionParserService, [{
                    key: 'parse',
                    value: function parse(component, ast, meta) {
                        try {
                            var action = new this.ActionModel(component);

                            var params = ast.expression.right.params;

                            parseParameters.call(this, action, params, meta);

                            var statements = ast.expression.right.body.body;
                            var parsers = [parseSelfThis, parseInteraction];
                            tryParse.call(this, action, statements, parsers);

                            return action;
                        } catch (e) {
                            console.warn('Invalid action:', ast);
                            return null;
                        }
                    }
                }]);

                return ActionParserService;
            })();

            _export('default', angular.module('tractor.actionParserService', [ActionModel.name, InteractionParserService.name, ParameterParserService.name]).service('actionParserService', ActionParserService));
        }
    };
});
System.registerDynamic("npm:inherits@2.0.1/inherits_browser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:inherits@2.0.1", ["npm:inherits@2.0.1/inherits_browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:inherits@2.0.1/inherits_browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3/support/isBufferBrowser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3/util", ["npm:util@0.10.3/support/isBufferBrowser", "npm:inherits@2.0.1", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%')
          return '%';
        if (i >= len)
          return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0,
          l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name,
          str,
          desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = $__require('npm:util@0.10.3/support/isBufferBrowser');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = $__require('npm:inherits@2.0.1');
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:util@0.10.3", ["npm:util@0.10.3/util"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:util@0.10.3/util');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:assert@1.3.0/assert", ["npm:util@0.10.3"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = $__require('npm:util@0.10.3');
  var pSlice = Array.prototype.slice;
  var hasOwn = Object.prototype.hasOwnProperty;
  var assert = module.exports = ok;
  assert.AssertionError = function AssertionError(options) {
    this.name = 'AssertionError';
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = options.operator;
    if (options.message) {
      this.message = options.message;
      this.generatedMessage = false;
    } else {
      this.message = getMessage(this);
      this.generatedMessage = true;
    }
    var stackStartFunction = options.stackStartFunction || fail;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, stackStartFunction);
    } else {
      var err = new Error();
      if (err.stack) {
        var out = err.stack;
        var fn_name = stackStartFunction.name;
        var idx = out.indexOf('\n' + fn_name);
        if (idx >= 0) {
          var next_line = out.indexOf('\n', idx + 1);
          out = out.substring(next_line + 1);
        }
        this.stack = out;
      }
    }
  };
  util.inherits(assert.AssertionError, Error);
  function replacer(key, value) {
    if (util.isUndefined(value)) {
      return '' + value;
    }
    if (util.isNumber(value) && !isFinite(value)) {
      return value.toString();
    }
    if (util.isFunction(value) || util.isRegExp(value)) {
      return value.toString();
    }
    return value;
  }
  function truncate(s, n) {
    if (util.isString(s)) {
      return s.length < n ? s : s.slice(0, n);
    } else {
      return s;
    }
  }
  function getMessage(self) {
    return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' + self.operator + ' ' + truncate(JSON.stringify(self.expected, replacer), 128);
  }
  function fail(actual, expected, message, operator, stackStartFunction) {
    throw new assert.AssertionError({
      message: message,
      actual: actual,
      expected: expected,
      operator: operator,
      stackStartFunction: stackStartFunction
    });
  }
  assert.fail = fail;
  function ok(value, message) {
    if (!value)
      fail(value, true, message, '==', assert.ok);
  }
  assert.ok = ok;
  assert.equal = function equal(actual, expected, message) {
    if (actual != expected)
      fail(actual, expected, message, '==', assert.equal);
  };
  assert.notEqual = function notEqual(actual, expected, message) {
    if (actual == expected) {
      fail(actual, expected, message, '!=', assert.notEqual);
    }
  };
  assert.deepEqual = function deepEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected)) {
      fail(actual, expected, message, 'deepEqual', assert.deepEqual);
    }
  };
  function _deepEqual(actual, expected) {
    if (actual === expected) {
      return true;
    } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
      if (actual.length != expected.length)
        return false;
      for (var i = 0; i < actual.length; i++) {
        if (actual[i] !== expected[i])
          return false;
      }
      return true;
    } else if (util.isDate(actual) && util.isDate(expected)) {
      return actual.getTime() === expected.getTime();
    } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
    } else if (!util.isObject(actual) && !util.isObject(expected)) {
      return actual == expected;
    } else {
      return objEquiv(actual, expected);
    }
  }
  function isArguments(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }
  function objEquiv(a, b) {
    if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
      return false;
    if (a.prototype !== b.prototype)
      return false;
    if (util.isPrimitive(a) || util.isPrimitive(b)) {
      return a === b;
    }
    var aIsArgs = isArguments(a),
        bIsArgs = isArguments(b);
    if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
      return false;
    if (aIsArgs) {
      a = pSlice.call(a);
      b = pSlice.call(b);
      return _deepEqual(a, b);
    }
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key,
        i;
    if (ka.length != kb.length)
      return false;
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i])
        return false;
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!_deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (_deepEqual(actual, expected)) {
      fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
    }
  };
  assert.strictEqual = function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      fail(actual, expected, message, '===', assert.strictEqual);
    }
  };
  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      fail(actual, expected, message, '!==', assert.notStrictEqual);
    }
  };
  function expectedException(actual, expected) {
    if (!actual || !expected) {
      return false;
    }
    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
      return expected.test(actual);
    } else if (actual instanceof expected) {
      return true;
    } else if (expected.call({}, actual) === true) {
      return true;
    }
    return false;
  }
  function _throws(shouldThrow, block, expected, message) {
    var actual;
    if (util.isString(expected)) {
      message = expected;
      expected = null;
    }
    try {
      block();
    } catch (e) {
      actual = e;
    }
    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
    if (shouldThrow && !actual) {
      fail(actual, expected, 'Missing expected exception' + message);
    }
    if (!shouldThrow && expectedException(actual, expected)) {
      fail(actual, expected, 'Got unwanted exception' + message);
    }
    if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
      throw actual;
    }
  }
  assert.throws = function(block, error, message) {
    _throws.apply(this, [true].concat(pSlice.call(arguments)));
  };
  assert.doesNotThrow = function(block, message) {
    _throws.apply(this, [false].concat(pSlice.call(arguments)));
  };
  assert.ifError = function(err) {
    if (err) {
      throw err;
    }
  };
  var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for (var key in obj) {
      if (hasOwn.call(obj, key))
        keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:assert@1.3.0", ["npm:assert@1.3.0/assert"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:assert@1.3.0/assert');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-assert@0.1.0/index", ["npm:assert@1.3.0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('assert') : $__require('npm:assert@1.3.0');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-assert@0.1.0", ["github:jspm/nodelibs-assert@0.1.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-assert@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.register('app/features/ComponentEditor/Services/ComponentParserService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:jspm/nodelibs-assert@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Services/ActionParserService.js', 'app/features/ComponentEditor/Models/ComponentModel.js', 'app/features/ComponentEditor/Services/ElementParserService.js', 'app/Core/Services/PersistentStateService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, assert, angular, ActionParserService, ComponentModel, ElementParserService, PersistentStateService, ComponentParserService;

    function tryParse(component, statements, meta, state, parsers) {
        var _this = this;

        statements.forEach(function (statement) {
            var parsed = parsers.some(function (parser) {
                try {
                    return parser.call(_this, component, statement, meta, state);
                } catch (e) {}
            });
            if (!parsed) {
                throw new Error();
            }
        });
    }

    function parseElements(component, statement, meta, state) {
        var _this2 = this;

        var _statement$declarations = _slicedToArray(statement.declarations, 1);

        var constructorDeclarator = _statement$declarations[0];

        var constructorBlockStatement = constructorDeclarator.init.body;
        constructorBlockStatement.body.forEach(function (statement) {
            parseElement.call(_this2, component, statement, meta, state);
        });
        return true;
    }

    function parseElement(component, statement, meta, state) {
        var domElement = this.elementParserService.parse(component, statement);
        assert(domElement);
        domElement.name = meta.elements[component.domElements.length].name;
        domElement.minimised = !!state[domElement.name];
        component.elements.push(domElement);
        component.domElements.push(domElement);
    }

    function parseAction(component, statement, meta, state) {
        var actionMeta = meta.actions[component.actions.length];
        assert(statement.expression);
        var action = this.actionParserService.parse(component, statement, actionMeta);
        assert(action);
        action.name = actionMeta.name;
        action.minimised = !!state[action.name];
        component.actions.push(action);
        return true;
    }

    function parseReturnStatement(component, statement) {
        assert(statement.argument.name === component.variableName);
        return true;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubJspmNodelibsAssert010) {
            assert = _githubJspmNodelibsAssert010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorServicesActionParserServiceJs) {
            ActionParserService = _appFeaturesComponentEditorServicesActionParserServiceJs['default'];
        }, function (_appFeaturesComponentEditorModelsComponentModelJs) {
            ComponentModel = _appFeaturesComponentEditorModelsComponentModelJs['default'];
        }, function (_appFeaturesComponentEditorServicesElementParserServiceJs) {
            ElementParserService = _appFeaturesComponentEditorServicesElementParserServiceJs['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }],
        execute: function () {

            // Utilities:
            'use strict';

            // Dependencies:
            ComponentParserService = (function () {
                function ComponentParserService(actionParserService, ComponentModel, elementParserService, persistentStateService) {
                    _classCallCheck(this, ComponentParserService);

                    this.actionParserService = actionParserService;
                    this.ComponentModel = ComponentModel;
                    this.elementParserService = elementParserService;
                    this.persistentStateService = persistentStateService;
                }

                _createClass(ComponentParserService, [{
                    key: 'parse',
                    value: function parse(componentFile) {
                        var ast = componentFile.ast;

                        try {
                            var _ast$comments = _slicedToArray(ast.comments, 1);

                            var metaComment = _ast$comments[0];

                            var meta = JSON.parse(metaComment.value);

                            var component = new this.ComponentModel({
                                isSaved: true,
                                path: componentFile.path
                            });
                            component.name = meta.name;

                            var state = this.persistentStateService.get(component.name);

                            var _ast$body = _slicedToArray(ast.body, 1);

                            var componentModuleExpressionStatement = _ast$body[0];

                            var moduleBlockStatement = componentModuleExpressionStatement.expression.right.callee.body;

                            var statements = moduleBlockStatement.body;
                            var parsers = [parseElements, parseAction, parseReturnStatement];
                            tryParse.call(this, component, statements, meta, state, parsers);

                            return component;
                        } catch (e) {
                            console.warn('Invalid component:', ast);
                            return null;
                        }
                    }
                }]);

                return ComponentParserService;
            })();

            _export('default', angular.module('tractor.componentParserService', [ActionParserService.name, ComponentModel.name, ElementParserService.name, PersistentStateService.name]).service('componentParserService', ComponentParserService));
        }
    };
});
System.register('app/Core/Services/FileStructureService.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/features/ComponentEditor/Services/ComponentParserService.js', 'app/features/MockDataEditor/Services/MockDataParserService.js', 'app/Core/Services/PersistentStateService.js'], function (_export) {
    var _createClass, _classCallCheck, angular, ComponentParserService, MockDataParserService, PersistentStateService, OPEN_DIRECTORIES, FileStructureService;

    function parseComponentsAndMockData(fileStructure) {
        var _this = this;

        var availableComponents = fileStructure.availableComponents;
        var availableMockData = fileStructure.availableMockData;

        if (availableComponents && availableMockData) {
            fileStructure.availableComponents = availableComponents.map(function (component) {
                return _this.componentParserService.parse(component);
            });
            fileStructure.availableMockData = availableMockData.map(function (mockData) {
                return _this.mockDataParserService.parse(mockData);
            });
        }
        return fileStructure;
    }

    function updateFileStructure(fileStructure) {
        fileStructure.directory = restoreOpenDirectories.call(this, fileStructure.directory);
        fileStructure.directory.allFiles = getAllFiles.call(this, fileStructure.directory);
        fileStructure.directory.open = true;
        return fileStructure;
    }

    function getOpenDirectories() {
        return this.persistentStateService.get(OPEN_DIRECTORIES);
    }

    function restoreOpenDirectories(directory) {
        var _this2 = this;

        directory.directories.forEach(function (directory) {
            restoreOpenDirectories.call(_this2, directory);
        });
        directory.open = !!getOpenDirectories.call(this)[directory.path];
        return directory;
    }

    function getAllFiles(directory) {
        var _this3 = this;

        var allFiles = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        directory.directories.forEach(function (directory) {
            allFiles = getAllFiles.call(_this3, directory, allFiles);
        });
        allFiles = allFiles.concat(directory.files);
        return allFiles;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appFeaturesComponentEditorServicesComponentParserServiceJs) {
            ComponentParserService = _appFeaturesComponentEditorServicesComponentParserServiceJs['default'];
        }, function (_appFeaturesMockDataEditorServicesMockDataParserServiceJs) {
            MockDataParserService = _appFeaturesMockDataEditorServicesMockDataParserServiceJs['default'];
        }, function (_appCoreServicesPersistentStateServiceJs) {
            PersistentStateService = _appCoreServicesPersistentStateServiceJs['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Constants:
            OPEN_DIRECTORIES = 'OpenDirectories';

            FileStructureService = (function () {
                function FileStructureService($http, componentParserService, mockDataParserService, persistentStateService) {
                    _classCallCheck(this, FileStructureService);

                    this.$http = $http;
                    this.componentParserService = componentParserService;
                    this.mockDataParserService = mockDataParserService;
                    this.persistentStateService = persistentStateService;
                }

                _createClass(FileStructureService, [{
                    key: 'getFileStructure',
                    value: function getFileStructure(type) {
                        return this.$http.get('/' + type + '/file-structure').then(parseComponentsAndMockData.bind(this)).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'addDirectory',
                    value: function addDirectory(type, options) {
                        return this.$http.post('/' + type + '/directory', options).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'copyFile',
                    value: function copyFile(type, options) {
                        return this.$http.post('/' + type + '/file/copy', options).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'deleteDirectory',
                    value: function deleteDirectory(type, params) {
                        return this.$http['delete']('/' + type + '/directory', { params: params }).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'deleteFile',
                    value: function deleteFile(type, params) {
                        return this.$http['delete']('/' + type + '/file', { params: params }).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'editDirectoryPath',
                    value: function editDirectoryPath(type, options) {
                        options.isDirectory = true;
                        return this.$http.patch('/' + type + '/directory/path', options).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'editFilePath',
                    value: function editFilePath(type, options) {
                        return this.$http.patch('/' + type + '/file/path', options).then(updateFileStructure.bind(this));
                    }
                }, {
                    key: 'toggleOpenDirectory',
                    value: function toggleOpenDirectory(directoryPath) {
                        var openDirectories = getOpenDirectories.call(this);
                        if (openDirectories[directoryPath]) {
                            delete openDirectories[directoryPath];
                        } else {
                            openDirectories[directoryPath] = true;
                        }
                        this.persistentStateService.set(OPEN_DIRECTORIES, openDirectories);
                    }
                }]);

                return FileStructureService;
            })();

            _export('default', angular.module('tractor.fileStructureService', [ComponentParserService.name, MockDataParserService.name, PersistentStateService.name]).service('fileStructureService', FileStructureService));
        }
    };
});
System.registerDynamic("npm:path-browserify@0.0.0/index", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
      return parts;
    }
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    exports.resolve = function() {
      var resolvedPath = '',
          resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };
    exports.normalize = function(path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isAbsolute).join('/');
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
      return (isAbsolute ? '/' : '') + path;
    };
    exports.isAbsolute = function(path) {
      return path.charAt(0) === '/';
    };
    exports.join = function() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };
    exports.relative = function(from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '')
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '')
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join('/');
    };
    exports.sep = '/';
    exports.delimiter = ':';
    exports.dirname = function(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];
      if (!root && !dir) {
        return '.';
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    exports.basename = function(path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    exports.extname = function(path) {
      return splitPath(path)[3];
    };
    function filter(xs, f) {
      if (xs.filter)
        return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs))
          res.push(xs[i]);
      }
      return res;
    }
    var substr = 'ab'.substr(-1) === 'b' ? function(str, start, len) {
      return str.substr(start, len);
    } : function(str, start, len) {
      if (start < 0)
        start = str.length + start;
      return str.substr(start, len);
    };
    ;
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:path-browserify@0.0.0", ["npm:path-browserify@0.0.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:path-browserify@0.0.0/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-path@0.1.0/index", ["npm:path-browserify@0.0.0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('path') : $__require('npm:path-browserify@0.0.0');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-path@0.1.0", ["github:jspm/nodelibs-path@0.1.0/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-path@0.1.0/index');
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/FileTree/FileTreeController.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'npm:change-case@2.3.0', 'github:jspm/nodelibs-path@0.1.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Services/FileStructureService.js', 'app/Core/Components/Notifier/NotifierService.js'], function (_export) {
    var _createClass, _classCallCheck, _slicedToArray, changecase, path, angular, FileStructureService, NotifierService, ENTER_KEY_CODE, FileTreeController;

    function setFileStructure(fileStructure) {
        this.model.fileStructure = fileStructure;
    }

    function getDirname(filePath) {
        // Sw33t hax()rz to get around the node "path" shim not working on Windows.
        var haxedFilePath = filePath.replace(/\\/g, '/');
        var dirname = path.dirname(haxedFilePath);
        if (haxedFilePath !== filePath) {
            dirname = dirname.replace(/\//g, '\\');
        }
        return dirname;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubJspmNodelibsPath010) {
            path = _githubJspmNodelibsPath010['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreServicesFileStructureServiceJs) {
            FileStructureService = _appCoreServicesFileStructureServiceJs['default'];
        }, function (_appCoreComponentsNotifierNotifierServiceJs) {
            NotifierService = _appCoreComponentsNotifierNotifierServiceJs['default'];
        }],
        execute: function () {
            'use strict';

            // Constants:

            // Dependencies:

            // Utilities:
            ENTER_KEY_CODE = 13;

            FileTreeController = (function () {
                function FileTreeController($state, $interval, $window, notifierService, fileStructureService) {
                    _classCallCheck(this, FileTreeController);

                    this.$state = $state;
                    this.$interval = $interval;
                    this.$window = $window;
                    this.notifierService = notifierService;
                    this.fileStructureService = fileStructureService;

                    this.headerName = changecase.title(this.type);
                    this.canModify = this.type !== 'step-definitions';

                    this.editFilePath = this.editFilePath.bind(this);
                }

                _createClass(FileTreeController, [{
                    key: 'getName',
                    value: function getName(item) {
                        if (item.ast) {
                            var _item$ast$comments = _slicedToArray(item.ast.comments, 1);

                            var metaComment = _item$ast$comments[0];

                            var meta = JSON.parse(metaComment.value);
                            return meta.name;
                        }
                        return item.name;
                    }
                }, {
                    key: 'addDirectory',
                    value: function addDirectory(directory) {
                        var path = directory.path;

                        this.fileStructureService.addDirectory(this.type, { path: path }).then(setFileStructure.bind(this));
                    }
                }, {
                    key: 'editName',
                    value: function editName(item) {
                        if (this.canModify || item.isDirectory) {
                            item.editingName = true;
                            item.previousName = item.name;
                            this.hideOptions(item);
                        }
                    }
                }, {
                    key: 'saveNewName',
                    value: function saveNewName(item) {
                        item.editingName = false;

                        var valid = true;
                        if (item.name.includes('_')) {
                            this.notifierService.error('Invalid character: "_"');
                            valid = false;
                        }
                        if (item.name.includes('/')) {
                            this.notifierService.error('Invalid character: "/"');
                            valid = false;
                        }
                        if (item.name.includes('\\')) {
                            this.notifierService.error('Invalid character: "\\"');
                            valid = false;
                        }
                        if (!item.name.trim().length) {
                            valid = false;
                        }

                        if (!valid) {
                            item.name = item.previousName;
                        }

                        if (item.name !== item.previousName) {
                            var directoryPath = getDirname(item.path);
                            var oldName = item.previousName;
                            var newName = item.name;

                            var options = { directoryPath: directoryPath, oldName: oldName, newName: newName };

                            var isDirectory = !!item.isDirectory;
                            if (isDirectory) {
                                this.fileStructureService.editDirectoryPath(this.type, options).then(setFileStructure.bind(this));
                            } else {
                                this.fileStructureService.editFilePath(this.type, options).then(setFileStructure.bind(this));
                            }
                        }
                    }
                }, {
                    key: 'renameOnEnter',
                    value: function renameOnEnter($event, item) {
                        if ($event.keyCode === ENTER_KEY_CODE) {
                            this.saveNewName(item);
                        }
                    }
                }, {
                    key: 'openFile',
                    value: function openFile(file) {
                        var directoryPath = this.model.fileStructure.directory.path.replace(/\\/g, '/');
                        var filePath = file.path.replace(/\\/g, '/');
                        var name = path.relative(directoryPath, filePath);
                        name = name.substring(0, name.indexOf('.'));
                        var params = {
                            file: { name: name }
                        };
                        this.$state.go('tractor.' + this.type, params);
                    }
                }, {
                    key: 'editFilePath',
                    value: function editFilePath(file, directory) {
                        var name = file.name;

                        var oldDirectoryPath = getDirname(file.path);
                        var newDirectoryPath = directory.path;
                        if (oldDirectoryPath !== newDirectoryPath) {
                            var options = { oldDirectoryPath: oldDirectoryPath, newDirectoryPath: newDirectoryPath, name: name };
                            this.fileStructureService.editFilePath(this.type, options).then(setFileStructure.bind(this));
                        }
                    }
                }, {
                    key: 'toggleOpenDirectory',
                    value: function toggleOpenDirectory(item) {
                        item.open = !item.open;
                        this.fileStructureService.toggleOpenDirectory(item.path);
                    }
                }, {
                    key: 'showOptions',
                    value: function showOptions(item) {
                        item.showOptions = true;
                    }
                }, {
                    key: 'hideOptions',
                    value: function hideOptions(item) {
                        item.showOptions = false;
                    }
                }, {
                    key: 'delete',
                    value: function _delete(item) {
                        this.hideOptions(item);

                        var hasChildren = item.files && item.files.length || item.directories && item.directories.length;

                        if (!hasChildren || this.$window.confirm('All directory contents will be deleted as well. Continue?')) {
                            var _name = item.name;
                            var _path = item.path;

                            var deleteOptions = { path: _path, name: _name };
                            if (item.isDirectory) {
                                this.fileStructureService.deleteDirectory(this.type, deleteOptions).then(setFileStructure.bind(this));
                            } else {
                                this.fileStructureService.deleteFile(this.type, deleteOptions).then(setFileStructure.bind(this));
                            }
                        }
                    }
                }, {
                    key: 'copy',
                    value: function copy(item) {
                        var path = item.path;

                        this.fileStructureService.copyFile(this.type, { path: path }).then(setFileStructure.bind(this));
                    }
                }]);

                return FileTreeController;
            })();

            _export('default', angular.module('fileTreeController', [FileStructureService.name, NotifierService.name]).controller('FileTreeController', FileTreeController));
        }
    };
});
System.register('app/Core/Components/FileTree/FileTreeDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/FileTree/FileTreeController.js', 'app/Core/Components/FileTree/FileTree.html'], function (_export) {
    var _classCallCheck, angular, FileTreeController, template, FileTreeDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsFileTreeFileTreeControllerJs) {
            FileTreeController = _appCoreComponentsFileTreeFileTreeControllerJs['default'];
        }, function (_appCoreComponentsFileTreeFileTreeHtml) {
            template = _appCoreComponentsFileTreeFileTreeHtml['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            FileTreeDirective = function FileTreeDirective() {
                _classCallCheck(this, FileTreeDirective);

                this.restrict = 'E';

                this.scope = {
                    model: '=',
                    type: '@'
                };

                this.template = template;

                this.controller = 'FileTreeController';
                this.controllerAs = 'fileTree';
                this.bindToController = true;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.fileTree.model)) {
                        throw new Error('The <tractor-file-tree> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.fileTree.type)) {
                        throw new Error('The <tractor-file-tree> directive requires a "type" attribute.');
                    }
                };
            };

            _export('default', angular.module('tractor.fileTree', [FileTreeController.name]).directive('tractorFileTree', function () {
                return new FileTreeDirective();
            }));
        }
    };
});
System.register('app/Core/Components/DropFile/DropFileDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _classCallCheck, _slicedToArray, angular, DropFileDirective;

    function dragover(event) {
        event.dataTransfer.dropEffect = 'move';
        event.preventDefault();
        event.stopPropagation();
        [].forEach.call(document.querySelectorAll('.dragover'), function (element) {
            element.classList.remove('dragover');
        });
        this.classList.add('dragover');
        return false;
    }

    function dragenter() {
        [].forEach.call(document.querySelectorAll('.dragover'), function (element) {
            element.classList.remove('dragover');
        });
        this.classList.add('dragover');
        return false;
    }

    function dragleave() {
        this.classList.remove('dragover');
        return false;
    }

    function drop($scope, event) {
        event.preventDefault();
        event.stopPropagation();
        this.classList.remove('dragover');
        var file = JSON.parse(event.dataTransfer.getData('file'));
        var directory = $scope.dropDirectory;
        var dropHandler = $scope.onDrop();
        dropHandler(file, directory);
        return false;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            DropFileDirective = function DropFileDirective() {
                _classCallCheck(this, DropFileDirective);

                this.restrict = 'A';

                this.scope = {
                    onDrop: '&',
                    dropDirectory: '='
                };

                this.link = function ($scope, $element) {
                    var _$element = _slicedToArray($element, 1);

                    var element = _$element[0];

                    element.addEventListener('dragover', dragover);
                    element.addEventListener('dragenter', dragenter);
                    element.addEventListener('dragleave', dragleave);
                    element.addEventListener('drop', drop.bind(element, $scope));
                };
            };

            _export('default', angular.module('tractor.dropFile', []).directive('tractorDropFile', function () {
                return new DropFileDirective();
            }));
        }
    };
});
System.registerDynamic("npm:core-js@1.2.3/library/modules/core.is-iterable", ["npm:core-js@1.2.3/library/modules/$.classof", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.iterators", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.3/library/modules/$.classof'),
      ITERATOR = $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.3/library/modules/$.iterators');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').isIterable = function(it) {
    var O = Object(it);
    return ITERATOR in O || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/is-iterable", ["npm:core-js@1.2.3/library/modules/web.dom.iterable", "npm:core-js@1.2.3/library/modules/es6.string.iterator", "npm:core-js@1.2.3/library/modules/core.is-iterable"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/web.dom.iterable');
  $__require('npm:core-js@1.2.3/library/modules/es6.string.iterator');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/core.is-iterable');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/is-iterable", ["npm:core-js@1.2.3/library/fn/is-iterable"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/is-iterable'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/core.get-iterator", ["npm:core-js@1.2.3/library/modules/$.an-object", "npm:core-js@1.2.3/library/modules/core.get-iterator-method", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object'),
      get = $__require('npm:core-js@1.2.3/library/modules/core.get-iterator-method');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/get-iterator", ["npm:core-js@1.2.3/library/modules/web.dom.iterable", "npm:core-js@1.2.3/library/modules/es6.string.iterator", "npm:core-js@1.2.3/library/modules/core.get-iterator"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/web.dom.iterable');
  $__require('npm:core-js@1.2.3/library/modules/es6.string.iterator');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/core.get-iterator');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/get-iterator", ["npm:core-js@1.2.3/library/fn/get-iterator"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/get-iterator'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/helpers/sliced-to-array", ["npm:babel-runtime@5.8.25/core-js/get-iterator", "npm:babel-runtime@5.8.25/core-js/is-iterable"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _getIterator = $__require('npm:babel-runtime@5.8.25/core-js/get-iterator')["default"];
  var _isIterable = $__require('npm:babel-runtime@5.8.25/core-js/is-iterable')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/DragFile/DragFileDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:babel-runtime@5.8.25/helpers/sliced-to-array', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _classCallCheck, _slicedToArray, angular, DragFileDirective;

    function dragstart($scope, event) {
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('file', JSON.stringify($scope.item));
        this.classList.add('drag');
        return false;
    }

    function dragend() {
        this.classList.remove('drag');
        return false;
    }

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5825HelpersSlicedToArray) {
            _slicedToArray = _npmBabelRuntime5825HelpersSlicedToArray['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            DragFileDirective = function DragFileDirective() {
                _classCallCheck(this, DragFileDirective);

                this.restrict = 'A';

                this.link = function ($scope, $element) {
                    var _$element = _slicedToArray($element, 1);

                    var element = _$element[0];

                    element.draggable = true;
                    element.addEventListener('dragstart', dragstart.bind(element, $scope));
                    element.addEventListener('dragend', dragend);
                };
            };

            _export('default', angular.module('tractor.dragFile', []).directive('tractorDragFile', function () {
                return new DragFileDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/ConfirmDialog/ConfirmDialog.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<div class=\"dialog__wrapper\" ng-if=\"confirmDialog.trigger\">\n    <div class=\"dialog__outer\">\n        <div class=\"dialog__inner\">\n            <div class=\"dialog__content\" ng-transclude></div>\n            <div class=\"dialog__actions\">\n                <tractor-action\n                    model=\"confirmDialog\"\n                    action=\"Ok\">\n                </tractor-action>\n                <tractor-action\n                    model=\"confirmDialog\"\n                    action=\"Cancel\">\n                </tractor-action>\n            </div>\n        </div>\n    </div>\n</div>\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/object/define-property", ["npm:core-js@1.2.3/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/define-property", ["npm:core-js@1.2.3/library/fn/object/define-property"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/object/define-property'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/helpers/create-class", ["npm:babel-runtime@5.8.25/core-js/object/define-property"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('npm:babel-runtime@5.8.25/core-js/object/define-property')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/ConfirmDialog/ConfirmDialogController.js', ['npm:babel-runtime@5.8.25/helpers/create-class', 'npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7'], function (_export) {
    var _createClass, _classCallCheck, angular, ConfirmDialogController;

    return {
        setters: [function (_npmBabelRuntime5825HelpersCreateClass) {
            _createClass = _npmBabelRuntime5825HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            ConfirmDialogController = (function () {
                function ConfirmDialogController() {
                    _classCallCheck(this, ConfirmDialogController);
                }

                _createClass(ConfirmDialogController, [{
                    key: 'ok',
                    value: function ok() {
                        this.trigger.resolve();
                    }
                }, {
                    key: 'cancel',
                    value: function cancel() {
                        this.trigger.reject();
                    }
                }]);

                return ConfirmDialogController;
            })();

            _export('default', angular.module('confirmDialogController', []).controller('ConfirmDialogController', ConfirmDialogController));
        }
    };
});
System.register('app/Core/Components/ConfirmDialog/ConfirmDialogDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/ConfirmDialog/ConfirmDialogController.js', 'app/Core/Components/ConfirmDialog/ConfirmDialog.html'], function (_export) {
    var _classCallCheck, angular, ConfirmDialogController, template, ConfirmDialogDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsConfirmDialogConfirmDialogControllerJs) {
            ConfirmDialogController = _appCoreComponentsConfirmDialogConfirmDialogControllerJs['default'];
        }, function (_appCoreComponentsConfirmDialogConfirmDialogHtml) {
            template = _appCoreComponentsConfirmDialogConfirmDialogHtml['default'];
        }],
        execute: function () {
            'use strict';

            // Dependencies:
            ConfirmDialogDirective = function ConfirmDialogDirective() {
                _classCallCheck(this, ConfirmDialogDirective);

                this.restrict = 'E';
                this.transclude = true;

                this.scope = {
                    trigger: '='
                };

                this.template = template;

                this.controller = 'ConfirmDialogController';
                this.controllerAs = 'confirmDialog';
                this.bindToController = true;
            };

            _export('default', angular.module('tractor.confirmDialog', [ConfirmDialogController.name]).directive('tractorConfirmDialog', function () {
                return new ConfirmDialogDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/Checkbox/Checkbox.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<label>{{ label }}: </label>\r\n<input type=\"checkbox\"\r\n    ng-model=\"model[property]\" />\r\n";
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/Checkbox/CheckboxDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Checkbox/Checkbox.html'], function (_export) {
    var _classCallCheck, changecase, angular, template, CheckboxDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsCheckboxCheckboxHtml) {
            template = _appCoreComponentsCheckboxCheckboxHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            CheckboxDirective = function CheckboxDirective() {
                _classCallCheck(this, CheckboxDirective);

                this.restrict = 'E';

                this.scope = {
                    model: '=',
                    label: '@'
                };

                this.template = template;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-checkbox> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.label)) {
                        throw new Error('The <tractor-checkbox> directive requires an "label" attribute.');
                    }

                    $scope.property = changecase.camel($scope.label);
                };
            };

            _export('default', angular.module('tractor.checkbox', []).directive('tractorCheckbox', function () {
                return new CheckboxDirective();
            }));
        }
    };
});
System.registerDynamic("app/Core/Components/Action/Action.html", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = "<button ng-click=\"model[method](argument)\" type=\"button\" title=\"{{ action }}\">\r\n    <span ng-class=\"{ true: 'hidden' }[icon != null]\">{{ action }}</span>\r\n</button>\r\n";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lower-case-first@1.0.0/lower-case-first", ["npm:lower-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lowerCase = $__require('npm:lower-case@1.1.2');
  module.exports = function(str, locale) {
    if (str == null) {
      return '';
    }
    str = String(str);
    return lowerCase(str.charAt(0), locale) + str.substr(1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lower-case-first@1.0.0", ["npm:lower-case-first@1.0.0/lower-case-first"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lower-case-first@1.0.0/lower-case-first');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-lower-case@1.1.1/is-lower-case", ["npm:lower-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lowerCase = $__require('npm:lower-case@1.1.2');
  module.exports = function(string, locale) {
    return lowerCase(string, locale) === string;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-lower-case@1.1.1", ["npm:is-lower-case@1.1.1/is-lower-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:is-lower-case@1.1.1/is-lower-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-upper-case@1.1.1/is-upper-case", ["npm:upper-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var upperCase = $__require('npm:upper-case@1.1.2');
  module.exports = function(string, locale) {
    return upperCase(string, locale) === string;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:is-upper-case@1.1.1", ["npm:is-upper-case@1.1.1/is-upper-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:is-upper-case@1.1.1/is-upper-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:constant-case@1.1.1/constant-case", ["npm:upper-case@1.1.2", "npm:snake-case@1.1.1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var upperCase = $__require('npm:upper-case@1.1.2');
  var snakeCase = $__require('npm:snake-case@1.1.1');
  module.exports = function(string, locale) {
    return upperCase(snakeCase(string, locale), locale);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:constant-case@1.1.1", ["npm:constant-case@1.1.1/constant-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:constant-case@1.1.1/constant-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:upper-case-first@1.1.1/upper-case-first", ["npm:upper-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var upperCase = $__require('npm:upper-case@1.1.2');
  module.exports = function(str, locale) {
    if (str == null) {
      return '';
    }
    str = String(str);
    return upperCase(str.charAt(0), locale) + str.substr(1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:upper-case-first@1.1.1", ["npm:upper-case-first@1.1.1/upper-case-first"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:upper-case-first@1.1.1/upper-case-first');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pascal-case@1.1.1/pascal-case", ["npm:camel-case@1.2.0", "npm:upper-case-first@1.1.1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var camelCase = $__require('npm:camel-case@1.2.0');
  var upperCaseFirst = $__require('npm:upper-case-first@1.1.1');
  module.exports = function(string, locale) {
    return upperCaseFirst(camelCase(string, locale), locale);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:pascal-case@1.1.1", ["npm:pascal-case@1.1.1/pascal-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:pascal-case@1.1.1/pascal-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:param-case@1.1.1/param-case", ["npm:sentence-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var sentenceCase = $__require('npm:sentence-case@1.1.2');
  module.exports = function(string, locale) {
    return sentenceCase(string, locale, '-');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:param-case@1.1.1", ["npm:param-case@1.1.1/param-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:param-case@1.1.1/param-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:title-case@1.1.1/title-case", ["npm:upper-case@1.1.2", "npm:sentence-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var upperCase = $__require('npm:upper-case@1.1.2');
  var sentenceCase = $__require('npm:sentence-case@1.1.2');
  module.exports = function(str, locale) {
    return sentenceCase(str, locale).replace(/^.| ./g, function(m) {
      return upperCase(m, locale);
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:title-case@1.1.1", ["npm:title-case@1.1.1/title-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:title-case@1.1.1/title-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:snake-case@1.1.1/snake-case", ["npm:sentence-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var sentenceCase = $__require('npm:sentence-case@1.1.2');
  module.exports = function(str, locale) {
    return sentenceCase(str, locale, '_');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:snake-case@1.1.1", ["npm:snake-case@1.1.1/snake-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:snake-case@1.1.1/snake-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:camel-case@1.2.0/camel-case", ["npm:upper-case@1.1.2", "npm:sentence-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var upperCase = $__require('npm:upper-case@1.1.2');
  var sentenceCase = $__require('npm:sentence-case@1.1.2');
  module.exports = function(string, locale, mergeNumbers) {
    var result = sentenceCase(string, locale);
    if (!mergeNumbers) {
      result = result.replace(/(\d) (?=\d)/g, '$1_');
    }
    return result.replace(/ (.)/g, function(m, $1) {
      return upperCase($1, locale);
    });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:camel-case@1.2.0", ["npm:camel-case@1.2.0/camel-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:camel-case@1.2.0/camel-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:path-case@1.1.1/path-case", ["npm:sentence-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var sentenceCase = $__require('npm:sentence-case@1.1.2');
  module.exports = function(string, locale) {
    return sentenceCase(string, locale, '/');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:path-case@1.1.1", ["npm:path-case@1.1.1/path-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:path-case@1.1.1/path-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:upper-case@1.1.2/upper-case", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LANGUAGES = {
    tr: {
      regexp: /[\u0069]/g,
      map: {'\u0069': '\u0130'}
    },
    az: {
      regexp: /[\u0069]/g,
      map: {'\u0069': '\u0130'}
    },
    lt: {
      regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
      map: {
        '\u0069\u0307': '\u0049',
        '\u006A\u0307': '\u004A',
        '\u012F\u0307': '\u012E',
        '\u0069\u0307\u0300': '\u00CC',
        '\u0069\u0307\u0301': '\u00CD',
        '\u0069\u0307\u0303': '\u0128'
      }
    }
  };
  module.exports = function(str, locale) {
    var lang = LANGUAGES[locale];
    str = str == null ? '' : String(str);
    if (lang) {
      str = str.replace(lang.regexp, function(m) {
        return lang.map[m];
      });
    }
    return str.toUpperCase();
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:upper-case@1.1.2", ["npm:upper-case@1.1.2/upper-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:upper-case@1.1.2/upper-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:swap-case@1.1.1/swap-case", ["npm:upper-case@1.1.2", "npm:lower-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var upperCase = $__require('npm:upper-case@1.1.2');
  var lowerCase = $__require('npm:lower-case@1.1.2');
  module.exports = function(str, locale) {
    if (str == null) {
      return '';
    }
    var result = '';
    for (var i = 0; i < str.length; i++) {
      var c = str[i];
      var u = upperCase(c, locale);
      result += u === c ? lowerCase(c, locale) : u;
    }
    return result;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:swap-case@1.1.1", ["npm:swap-case@1.1.1/swap-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:swap-case@1.1.1/swap-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sentence-case@1.1.2/vendor/trailing-digit-regexp", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = /([\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([^\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sentence-case@1.1.2/vendor/camel-case-regexp", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = /([\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])([\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sentence-case@1.1.2/vendor/non-word-regexp", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = /[^\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lower-case@1.1.2/lower-case", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LANGUAGES = {
    tr: {
      regexp: /\u0130|\u0049|\u0049\u0307/g,
      map: {
        '\u0130': '\u0069',
        '\u0049': '\u0131',
        '\u0049\u0307': '\u0069'
      }
    },
    az: {
      regexp: /[\u0130]/g,
      map: {
        '\u0130': '\u0069',
        '\u0049': '\u0131',
        '\u0049\u0307': '\u0069'
      }
    },
    lt: {
      regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
      map: {
        '\u0049': '\u0069\u0307',
        '\u004A': '\u006A\u0307',
        '\u012E': '\u012F\u0307',
        '\u00CC': '\u0069\u0307\u0300',
        '\u00CD': '\u0069\u0307\u0301',
        '\u0128': '\u0069\u0307\u0303'
      }
    }
  };
  module.exports = function(str, locale) {
    var lang = LANGUAGES[locale];
    str = str == null ? '' : String(str);
    if (lang) {
      str = str.replace(lang.regexp, function(m) {
        return lang.map[m];
      });
    }
    return str.toLowerCase();
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lower-case@1.1.2", ["npm:lower-case@1.1.2/lower-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lower-case@1.1.2/lower-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sentence-case@1.1.2/sentence-case", ["npm:lower-case@1.1.2", "npm:sentence-case@1.1.2/vendor/non-word-regexp", "npm:sentence-case@1.1.2/vendor/camel-case-regexp", "npm:sentence-case@1.1.2/vendor/trailing-digit-regexp"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lowerCase = $__require('npm:lower-case@1.1.2');
  var NON_WORD_REGEXP = $__require('npm:sentence-case@1.1.2/vendor/non-word-regexp');
  var CAMEL_CASE_REGEXP = $__require('npm:sentence-case@1.1.2/vendor/camel-case-regexp');
  var TRAILING_DIGIT_REGEXP = $__require('npm:sentence-case@1.1.2/vendor/trailing-digit-regexp');
  module.exports = function(str, locale, replacement) {
    if (str == null) {
      return '';
    }
    replacement = replacement || ' ';
    function replace(match, index, string) {
      if (index === 0 || index === (string.length - match.length)) {
        return '';
      }
      return replacement;
    }
    str = String(str).replace(CAMEL_CASE_REGEXP, '$1 $2').replace(TRAILING_DIGIT_REGEXP, '$1 $2').replace(NON_WORD_REGEXP, replace);
    return lowerCase(str, locale);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:sentence-case@1.1.2", ["npm:sentence-case@1.1.2/sentence-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:sentence-case@1.1.2/sentence-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:dot-case@1.1.1/dot-case", ["npm:sentence-case@1.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var sentenceCase = $__require('npm:sentence-case@1.1.2');
  module.exports = function(string, locale) {
    return sentenceCase(string, locale, '.');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:dot-case@1.1.1", ["npm:dot-case@1.1.1/dot-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:dot-case@1.1.1/dot-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:change-case@2.3.0/change-case", ["npm:dot-case@1.1.1", "npm:swap-case@1.1.1", "npm:path-case@1.1.1", "npm:upper-case@1.1.2", "npm:lower-case@1.1.2", "npm:camel-case@1.2.0", "npm:snake-case@1.1.1", "npm:title-case@1.1.1", "npm:param-case@1.1.1", "npm:pascal-case@1.1.1", "npm:constant-case@1.1.1", "npm:sentence-case@1.1.2", "npm:is-upper-case@1.1.1", "npm:is-lower-case@1.1.1", "npm:upper-case-first@1.1.1", "npm:lower-case-first@1.0.0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.dot = exports.dotCase = $__require('npm:dot-case@1.1.1');
  exports.swap = exports.swapCase = $__require('npm:swap-case@1.1.1');
  exports.path = exports.pathCase = $__require('npm:path-case@1.1.1');
  exports.upper = exports.upperCase = $__require('npm:upper-case@1.1.2');
  exports.lower = exports.lowerCase = $__require('npm:lower-case@1.1.2');
  exports.camel = exports.camelCase = $__require('npm:camel-case@1.2.0');
  exports.snake = exports.snakeCase = $__require('npm:snake-case@1.1.1');
  exports.title = exports.titleCase = $__require('npm:title-case@1.1.1');
  exports.param = exports.paramCase = $__require('npm:param-case@1.1.1');
  exports.pascal = exports.pascalCase = $__require('npm:pascal-case@1.1.1');
  exports.constant = exports.constantCase = $__require('npm:constant-case@1.1.1');
  exports.sentence = exports.sentenceCase = $__require('npm:sentence-case@1.1.2');
  exports.isUpper = exports.isUpperCase = $__require('npm:is-upper-case@1.1.1');
  exports.isLower = exports.isLowerCase = $__require('npm:is-lower-case@1.1.1');
  exports.ucFirst = exports.upperCaseFirst = $__require('npm:upper-case-first@1.1.1');
  exports.lcFirst = exports.lowerCaseFirst = $__require('npm:lower-case-first@1.0.0');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:change-case@2.3.0", ["npm:change-case@2.3.0/change-case"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:change-case@2.3.0/change-case');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/helpers/class-call-check", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('app/Core/Components/Action/ActionDirective.js', ['npm:babel-runtime@5.8.25/helpers/class-call-check', 'npm:change-case@2.3.0', 'github:angular/bower-angular@1.4.7', 'app/Core/Components/Action/Action.html'], function (_export) {
    var _classCallCheck, changecase, angular, template, ActionDirective;

    return {
        setters: [function (_npmBabelRuntime5825HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5825HelpersClassCallCheck['default'];
        }, function (_npmChangeCase230) {
            changecase = _npmChangeCase230['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_appCoreComponentsActionActionHtml) {
            template = _appCoreComponentsActionActionHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:
            ActionDirective = function ActionDirective() {
                _classCallCheck(this, ActionDirective);

                this.restrict = 'E';

                this.scope = {
                    model: '=',
                    action: '@',
                    argument: '=',
                    icon: '@'
                };

                this.template = template;

                this.link = function ($scope) {
                    if (angular.isUndefined($scope.model)) {
                        throw new Error('The <tractor-action> directive requires a "model" attribute.');
                    }

                    if (angular.isUndefined($scope.action)) {
                        throw new Error('The <tractor-action> directive requires an "action" attribute.');
                    }

                    $scope.method = changecase.camel($scope.action);
                };
            };

            _export('default', angular.module('tractor.action', []).directive('tractorAction', function () {
                return new ActionDirective();
            }));
        }
    };
});
System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iter-detect", ["npm:core-js@1.2.3/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SYMBOL_ITERATOR = $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][SYMBOL_ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[SYMBOL_ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[SYMBOL_ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.mix", ["npm:core-js@1.2.3/library/modules/$.redef"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $redef = $__require('npm:core-js@1.2.3/library/modules/$.redef');
  module.exports = function(target, src) {
    for (var key in src)
      $redef(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.dom-create", ["npm:core-js@1.2.3/library/modules/$.is-object", "npm:core-js@1.2.3/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/library/modules/$.is-object'),
      document = $__require('npm:core-js@1.2.3/library/modules/$.global').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.html", ["npm:core-js@1.2.3/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.global').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.invoke", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.task", ["npm:core-js@1.2.3/library/modules/$.ctx", "npm:core-js@1.2.3/library/modules/$.invoke", "npm:core-js@1.2.3/library/modules/$.html", "npm:core-js@1.2.3/library/modules/$.dom-create", "npm:core-js@1.2.3/library/modules/$.global", "npm:core-js@1.2.3/library/modules/$.cof", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ctx = $__require('npm:core-js@1.2.3/library/modules/$.ctx'),
        invoke = $__require('npm:core-js@1.2.3/library/modules/$.invoke'),
        html = $__require('npm:core-js@1.2.3/library/modules/$.html'),
        cel = $__require('npm:core-js@1.2.3/library/modules/$.dom-create'),
        global = $__require('npm:core-js@1.2.3/library/modules/$.global'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('npm:core-js@1.2.3/library/modules/$.cof')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.microtask", ["npm:core-js@1.2.3/library/modules/$.global", "npm:core-js@1.2.3/library/modules/$.task", "npm:core-js@1.2.3/library/modules/$.cof", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('npm:core-js@1.2.3/library/modules/$.global'),
        macrotask = $__require('npm:core-js@1.2.3/library/modules/$.task').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        isNode = $__require('npm:core-js@1.2.3/library/modules/$.cof')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        if (domain)
          domain.enter();
        head.fn.call();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.species-constructor", ["npm:core-js@1.2.3/library/modules/$.an-object", "npm:core-js@1.2.3/library/modules/$.a-function", "npm:core-js@1.2.3/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object'),
      aFunction = $__require('npm:core-js@1.2.3/library/modules/$.a-function'),
      SPECIES = $__require('npm:core-js@1.2.3/library/modules/$.wks')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.species", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.support-desc"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
      SPECIES = $__require('npm:core-js@1.2.3/library/modules/$.wks')('species');
  module.exports = function(C) {
    if ($__require('npm:core-js@1.2.3/library/modules/$.support-desc') && !(SPECIES in C))
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.same", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.set-proto", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.is-object", "npm:core-js@1.2.3/library/modules/$.an-object", "npm:core-js@1.2.3/library/modules/$.ctx"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('npm:core-js@1.2.3/library/modules/$').getDesc,
      isObject = $__require('npm:core-js@1.2.3/library/modules/$.is-object'),
      anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.3/library/modules/$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/core.get-iterator-method", ["npm:core-js@1.2.3/library/modules/$.classof", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.iterators", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.3/library/modules/$.classof'),
      ITERATOR = $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.3/library/modules/$.iterators');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.to-length", ["npm:core-js@1.2.3/library/modules/$.to-integer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.3/library/modules/$.to-integer'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.is-array-iter", ["npm:core-js@1.2.3/library/modules/$.iterators", "npm:core-js@1.2.3/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('npm:core-js@1.2.3/library/modules/$.iterators'),
      ITERATOR = $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator');
  module.exports = function(it) {
    return (Iterators.Array || Array.prototype[ITERATOR]) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iter-call", ["npm:core-js@1.2.3/library/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.for-of", ["npm:core-js@1.2.3/library/modules/$.ctx", "npm:core-js@1.2.3/library/modules/$.iter-call", "npm:core-js@1.2.3/library/modules/$.is-array-iter", "npm:core-js@1.2.3/library/modules/$.an-object", "npm:core-js@1.2.3/library/modules/$.to-length", "npm:core-js@1.2.3/library/modules/core.get-iterator-method"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.2.3/library/modules/$.ctx'),
      call = $__require('npm:core-js@1.2.3/library/modules/$.iter-call'),
      isArrayIter = $__require('npm:core-js@1.2.3/library/modules/$.is-array-iter'),
      anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object'),
      toLength = $__require('npm:core-js@1.2.3/library/modules/$.to-length'),
      getIterFn = $__require('npm:core-js@1.2.3/library/modules/core.get-iterator-method');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.strict-new", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.classof", ["npm:core-js@1.2.3/library/modules/$.cof", "npm:core-js@1.2.3/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.3/library/modules/$.cof'),
      TAG = $__require('npm:core-js@1.2.3/library/modules/$.wks')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.a-function", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.ctx", ["npm:core-js@1.2.3/library/modules/$.a-function"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.2.3/library/modules/$.a-function');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.promise", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.library", "npm:core-js@1.2.3/library/modules/$.global", "npm:core-js@1.2.3/library/modules/$.ctx", "npm:core-js@1.2.3/library/modules/$.classof", "npm:core-js@1.2.3/library/modules/$.def", "npm:core-js@1.2.3/library/modules/$.is-object", "npm:core-js@1.2.3/library/modules/$.an-object", "npm:core-js@1.2.3/library/modules/$.a-function", "npm:core-js@1.2.3/library/modules/$.strict-new", "npm:core-js@1.2.3/library/modules/$.for-of", "npm:core-js@1.2.3/library/modules/$.set-proto", "npm:core-js@1.2.3/library/modules/$.same", "npm:core-js@1.2.3/library/modules/$.species", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.species-constructor", "npm:core-js@1.2.3/library/modules/$.uid", "npm:core-js@1.2.3/library/modules/$.microtask", "npm:core-js@1.2.3/library/modules/$.support-desc", "npm:core-js@1.2.3/library/modules/$.mix", "npm:core-js@1.2.3/library/modules/$.tag", "npm:core-js@1.2.3/library/modules/$.core", "npm:core-js@1.2.3/library/modules/$.iter-detect", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
        LIBRARY = $__require('npm:core-js@1.2.3/library/modules/$.library'),
        global = $__require('npm:core-js@1.2.3/library/modules/$.global'),
        ctx = $__require('npm:core-js@1.2.3/library/modules/$.ctx'),
        classof = $__require('npm:core-js@1.2.3/library/modules/$.classof'),
        $def = $__require('npm:core-js@1.2.3/library/modules/$.def'),
        isObject = $__require('npm:core-js@1.2.3/library/modules/$.is-object'),
        anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object'),
        aFunction = $__require('npm:core-js@1.2.3/library/modules/$.a-function'),
        strictNew = $__require('npm:core-js@1.2.3/library/modules/$.strict-new'),
        forOf = $__require('npm:core-js@1.2.3/library/modules/$.for-of'),
        setProto = $__require('npm:core-js@1.2.3/library/modules/$.set-proto').set,
        same = $__require('npm:core-js@1.2.3/library/modules/$.same'),
        species = $__require('npm:core-js@1.2.3/library/modules/$.species'),
        SPECIES = $__require('npm:core-js@1.2.3/library/modules/$.wks')('species'),
        speciesConstructor = $__require('npm:core-js@1.2.3/library/modules/$.species-constructor'),
        RECORD = $__require('npm:core-js@1.2.3/library/modules/$.uid')('record'),
        asap = $__require('npm:core-js@1.2.3/library/modules/$.microtask'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var useNative = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('npm:core-js@1.2.3/library/modules/$.support-desc')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var isPromise = function(it) {
      return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
    };
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(react) {
          var cb = ok ? react.ok : react.fail,
              ret,
              then;
          try {
            if (cb) {
              if (!ok)
                record.h = true;
              ret = cb === true ? value : cb(value);
              if (ret === react.P) {
                react.rej(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(ret)) {
                then.call(ret, react.res, react.rej);
              } else
                react.res(ret);
            } else
              react.rej(value);
          } catch (err) {
            react.rej(err);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise[RECORD],
          chain = record.a || record.c,
          i = 0,
          react;
      if (record.h)
        return false;
      while (chain.length > i) {
        react = chain[i++];
        if (react.fail || !isUnhandled(react.P))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!useNative) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        this[RECORD] = record;
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('npm:core-js@1.2.3/library/modules/$.mix')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var react = {
            ok: typeof onFulfilled == 'function' ? onFulfilled : true,
            fail: typeof onRejected == 'function' ? onRejected : false
          };
          var promise = react.P = new (speciesConstructor(this, P))(function(res, rej) {
            react.res = res;
            react.rej = rej;
          });
          aFunction(react.res);
          aFunction(react.rej);
          var record = this[RECORD];
          record.c.push(react);
          if (record.a)
            record.a.push(react);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
    $__require('npm:core-js@1.2.3/library/modules/$.tag')(P, PROMISE);
    species(P);
    species(Wrapper = $__require('npm:core-js@1.2.3/library/modules/$.core')[PROMISE]);
    $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
        return new this(function(res, rej) {
          rej(r);
        });
      }});
    $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
          res(x);
        });
      }});
    $def($def.S + $def.F * !(useNative && $__require('npm:core-js@1.2.3/library/modules/$.iter-detect')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            values = [];
        return new C(function(res, rej) {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              C.resolve(promise).then(function(value) {
                results[index] = value;
                --remaining || res(results);
              }, rej);
            });
          else
            res(results);
        });
      },
      race: function race(iterable) {
        var C = getConstructor(this);
        return new C(function(res, rej) {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(res, rej);
          });
        });
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.object.to-string", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/promise", ["npm:core-js@1.2.3/library/modules/es6.object.to-string", "npm:core-js@1.2.3/library/modules/es6.string.iterator", "npm:core-js@1.2.3/library/modules/web.dom.iterable", "npm:core-js@1.2.3/library/modules/es6.promise", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.object.to-string');
  $__require('npm:core-js@1.2.3/library/modules/es6.string.iterator');
  $__require('npm:core-js@1.2.3/library/modules/web.dom.iterable');
  $__require('npm:core-js@1.2.3/library/modules/es6.promise');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').Promise;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/promise", ["npm:core-js@1.2.3/library/fn/promise"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/promise'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/object/create", ["npm:core-js@1.2.3/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/object/create", ["npm:core-js@1.2.3/library/fn/object/create"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/object/create'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.is-object", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.an-object", ["npm:core-js@1.2.3/library/modules/$.is-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/library/modules/$.is-object');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.is-array", ["npm:core-js@1.2.3/library/modules/$.cof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.3/library/modules/$.cof');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.enum-keys", ["npm:core-js@1.2.3/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.get-names", ["npm:core-js@1.2.3/library/modules/$.to-iobject", "npm:core-js@1.2.3/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString,
      toIObject = $__require('npm:core-js@1.2.3/library/modules/$.to-iobject'),
      getNames = $__require('npm:core-js@1.2.3/library/modules/$').getNames;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.keyof", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.to-iobject"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
      toIObject = $__require('npm:core-js@1.2.3/library/modules/$.to-iobject');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.symbol", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.global", "npm:core-js@1.2.3/library/modules/$.has", "npm:core-js@1.2.3/library/modules/$.support-desc", "npm:core-js@1.2.3/library/modules/$.def", "npm:core-js@1.2.3/library/modules/$.redef", "npm:core-js@1.2.3/library/modules/$.fails", "npm:core-js@1.2.3/library/modules/$.shared", "npm:core-js@1.2.3/library/modules/$.tag", "npm:core-js@1.2.3/library/modules/$.uid", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.keyof", "npm:core-js@1.2.3/library/modules/$.get-names", "npm:core-js@1.2.3/library/modules/$.enum-keys", "npm:core-js@1.2.3/library/modules/$.is-array", "npm:core-js@1.2.3/library/modules/$.an-object", "npm:core-js@1.2.3/library/modules/$.to-iobject", "npm:core-js@1.2.3/library/modules/$.property-desc", "npm:core-js@1.2.3/library/modules/$.library"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
      global = $__require('npm:core-js@1.2.3/library/modules/$.global'),
      has = $__require('npm:core-js@1.2.3/library/modules/$.has'),
      SUPPORT_DESC = $__require('npm:core-js@1.2.3/library/modules/$.support-desc'),
      $def = $__require('npm:core-js@1.2.3/library/modules/$.def'),
      $redef = $__require('npm:core-js@1.2.3/library/modules/$.redef'),
      $fails = $__require('npm:core-js@1.2.3/library/modules/$.fails'),
      shared = $__require('npm:core-js@1.2.3/library/modules/$.shared'),
      setTag = $__require('npm:core-js@1.2.3/library/modules/$.tag'),
      uid = $__require('npm:core-js@1.2.3/library/modules/$.uid'),
      wks = $__require('npm:core-js@1.2.3/library/modules/$.wks'),
      keyOf = $__require('npm:core-js@1.2.3/library/modules/$.keyof'),
      $names = $__require('npm:core-js@1.2.3/library/modules/$.get-names'),
      enumKeys = $__require('npm:core-js@1.2.3/library/modules/$.enum-keys'),
      isArray = $__require('npm:core-js@1.2.3/library/modules/$.is-array'),
      anObject = $__require('npm:core-js@1.2.3/library/modules/$.an-object'),
      toIObject = $__require('npm:core-js@1.2.3/library/modules/$.to-iobject'),
      createDesc = $__require('npm:core-js@1.2.3/library/modules/$.property-desc'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = SUPPORT_DESC && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    $redef($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (SUPPORT_DESC && !$__require('npm:core-js@1.2.3/library/modules/$.library')) {
      $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $def($def.G + $def.W, {Symbol: $Symbol});
  $def($def.S, 'Symbol', symbolStatics);
  $def($def.S + $def.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setTag($Symbol, 'Symbol');
  setTag(Math, 'Math', true);
  setTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/symbol/index", ["npm:core-js@1.2.3/library/modules/es6.symbol", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.symbol');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.core').Symbol;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/symbol", ["npm:core-js@1.2.3/library/fn/symbol/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.3/library/fn/symbol/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/symbol", ["npm:core-js@1.2.3/library/fn/symbol"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/symbol'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/regenerator/runtime", ["npm:babel-runtime@5.8.25/core-js/symbol", "npm:babel-runtime@5.8.25/core-js/symbol/iterator", "npm:babel-runtime@5.8.25/core-js/object/create", "npm:babel-runtime@5.8.25/core-js/promise", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var _Symbol = $__require('npm:babel-runtime@5.8.25/core-js/symbol')["default"];
    var _Symbol$iterator = $__require('npm:babel-runtime@5.8.25/core-js/symbol/iterator')["default"];
    var _Object$create = $__require('npm:babel-runtime@5.8.25/core-js/object/create')["default"];
    var _Promise = $__require('npm:babel-runtime@5.8.25/core-js/promise')["default"];
    !(function(global) {
      "use strict";
      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined;
      var iteratorSymbol = typeof _Symbol === "function" && _Symbol$iterator || "@@iterator";
      var inModule = typeof module === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          module.exports = runtime;
        }
        return;
      }
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var generator = _Object$create((outerFn || Generator).prototype);
        generator._invoke = makeInvokeMethod(innerFn, self || null, new Context(tryLocsList || []));
        return generator;
      }
      runtime.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = "GeneratorFunction";
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          prototype[method] = function(arg) {
            return this._invoke(method, arg);
          };
        });
      }
      runtime.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      runtime.mark = function(genFun) {
        genFun.__proto__ = GeneratorFunctionPrototype;
        genFun.prototype = _Object$create(Gp);
        return genFun;
      };
      runtime.awrap = function(arg) {
        return new AwaitArgument(arg);
      };
      function AwaitArgument(arg) {
        this.arg = arg;
      }
      function AsyncIterator(generator) {
        function invoke(method, arg) {
          var result = generator[method](arg);
          var value = result.value;
          return value instanceof AwaitArgument ? _Promise.resolve(value.arg).then(invokeNext, invokeThrow) : _Promise.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            return result;
          });
        }
        if (typeof process === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }
        var invokeNext = invoke.bind(generator, "next");
        var invokeThrow = invoke.bind(generator, "throw");
        var invokeReturn = invoke.bind(generator, "return");
        var previousPromise;
        function enqueue(method, arg) {
          var enqueueResult = previousPromise ? previousPromise.then(function() {
            return invoke(method, arg);
          }) : new _Promise(function(resolve) {
            resolve(invoke(method, arg));
          });
          previousPromise = enqueueResult["catch"](function(ignored) {});
          return enqueueResult;
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      runtime.async = function(innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                context.delegate = null;
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }
                if (method === "return") {
                  continue;
                }
              }
              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
              if (record.type === "throw") {
                context.delegate = null;
                method = "throw";
                arg = record.arg;
                continue;
              }
              method = "next";
              arg = undefined;
              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }
              context.delegate = null;
            }
            if (method === "next") {
              if (state === GenStateSuspendedYield) {
                context.sent = arg;
              } else {
                context.sent = undefined;
              }
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }
              if (context.dispatchException(arg)) {
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              var info = {
                value: record.arg,
                done: context.done
              };
              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }
      defineIteratorMethods(Gp);
      Gp[iteratorSymbol] = function() {
        return this;
      };
      Gp.toString = function() {
        return "[object Generator]";
      };
      function pushTryEntry(locs) {
        var entry = {tryLoc: locs[0]};
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{tryLoc: "root"}];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      runtime.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }
                  next.value = undefined;
                  next.done = true;
                  return next;
                };
            return next.next = next;
          }
        }
        return {next: doneResult};
      }
      runtime.values = values;
      function doneResult() {
        return {
          value: undefined,
          done: true
        };
      }
      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = undefined;
          this.done = false;
          this.delegate = null;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }
          return ContinueSentinel;
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };
          return ContinueSentinel;
        }
      };
    })(typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/web.dom.iterable", ["npm:core-js@1.2.3/modules/es6.array.iterator", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.iterators", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/es6.array.iterator');
  var global = $__require('npm:core-js@1.2.3/modules/$.global'),
      hide = $__require('npm:core-js@1.2.3/modules/$.hide'),
      Iterators = $__require('npm:core-js@1.2.3/modules/$.iterators'),
      ITERATOR = $__require('npm:core-js@1.2.3/modules/$.wks')('iterator'),
      NL = global.NodeList,
      HTC = global.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype,
      ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  if (NL && !(ITERATOR in NLProto))
    hide(NLProto, ITERATOR, ArrayValues);
  if (HTC && !(ITERATOR in HTCProto))
    hide(HTCProto, ITERATOR, ArrayValues);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/web.immediate", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.task"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $task = $__require('npm:core-js@1.2.3/modules/$.task');
  $def($def.G + $def.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.path", ["npm:core-js@1.2.3/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.3/modules/$.global');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.partial", ["npm:core-js@1.2.3/modules/$.path", "npm:core-js@1.2.3/modules/$.invoke", "npm:core-js@1.2.3/modules/$.a-function"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var path = $__require('npm:core-js@1.2.3/modules/$.path'),
      invoke = $__require('npm:core-js@1.2.3/modules/$.invoke'),
      aFunction = $__require('npm:core-js@1.2.3/modules/$.a-function');
  module.exports = function() {
    var fn = aFunction(this),
        length = arguments.length,
        pargs = Array(length),
        i = 0,
        _ = path._,
        holder = false;
    while (length > i)
      if ((pargs[i] = arguments[i++]) === _)
        holder = true;
    return function() {
      var that = this,
          $$ = arguments,
          $$len = $$.length,
          j = 0,
          k = 0,
          args;
      if (!holder && !$$len)
        return invoke(fn, pargs, that);
      args = pargs.slice();
      if (holder)
        for (; length > j; j++)
          if (args[j] === _)
            args[j] = $$[k++];
      while ($$len > k)
        args.push($$[k++]);
      return invoke(fn, args, that);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/web.timers", ["npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.invoke", "npm:core-js@1.2.3/modules/$.partial"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/modules/$.global'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      invoke = $__require('npm:core-js@1.2.3/modules/$.invoke'),
      partial = $__require('npm:core-js@1.2.3/modules/$.partial'),
      navigator = global.navigator,
      MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent);
  var wrap = function(set) {
    return MSIE ? function(fn, time) {
      return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
    } : set;
  };
  $def($def.G + $def.B + $def.F * MSIE, {
    setTimeout: wrap(global.setTimeout),
    setInterval: wrap(global.setInterval)
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/js.array.statics", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.core", "npm:core-js@1.2.3/modules/$.ctx"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $Array = $__require('npm:core-js@1.2.3/modules/$.core').Array || Array,
      statics = {};
  var setStatics = function(keys, length) {
    $.each.call(keys.split(','), function(key) {
      if (length == undefined && key in $Array)
        statics[key] = $Array[key];
      else if (key in [])
        statics[key] = $__require('npm:core-js@1.2.3/modules/$.ctx')(Function.call, [][key], length);
    });
  };
  setStatics('pop,reverse,shift,keys,values,entries', 1);
  setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' + 'reduce,reduceRight,copyWithin,fill');
  $def($def.S, 'Array', statics);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.set.to-json", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.collection-to-json"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.P, 'Set', {toJSON: $__require('npm:core-js@1.2.3/modules/$.collection-to-json')('Set')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.collection-to-json", ["npm:core-js@1.2.3/modules/$.for-of", "npm:core-js@1.2.3/modules/$.classof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forOf = $__require('npm:core-js@1.2.3/modules/$.for-of'),
      classof = $__require('npm:core-js@1.2.3/modules/$.classof');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.map.to-json", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.collection-to-json"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.P, 'Map', {toJSON: $__require('npm:core-js@1.2.3/modules/$.collection-to-json')('Map')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.object.entries", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.object-to-array"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $entries = $__require('npm:core-js@1.2.3/modules/$.object-to-array')(true);
  $def($def.S, 'Object', {entries: function entries(it) {
      return $entries(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.object-to-array", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.to-iobject"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      isEnum = $.isEnum;
  module.exports = function(isEntries) {
    return function(it) {
      var O = toIObject(it),
          keys = $.getKeys(O),
          length = keys.length,
          i = 0,
          result = [],
          key;
      while (length > i)
        if (isEnum.call(O, key = keys[i++])) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      return result;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.object.values", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.object-to-array"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $values = $__require('npm:core-js@1.2.3/modules/$.object-to-array')(false);
  $def($def.S, 'Object', {values: function values(it) {
      return $values(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.object.get-own-property-descriptors", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.own-keys", "npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.property-desc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      ownKeys = $__require('npm:core-js@1.2.3/modules/$.own-keys'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      createDesc = $__require('npm:core-js@1.2.3/modules/$.property-desc');
  $def($def.S, 'Object', {getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIObject(object),
          setDesc = $.setDesc,
          getDesc = $.getDesc,
          keys = ownKeys(O),
          result = {},
          i = 0,
          key,
          D;
      while (keys.length > i) {
        D = getDesc(O, key = keys[i++]);
        if (key in result)
          setDesc(result, key, createDesc(0, D));
        else
          result[key] = D;
      }
      return result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.replacer", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(regExp, replace) {
    var replacer = replace === Object(replace) ? function(part) {
      return replace[part];
    } : replace;
    return function(it) {
      return String(it).replace(regExp, replacer);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.regexp.escape", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.replacer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $re = $__require('npm:core-js@1.2.3/modules/$.replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  $def($def.S, 'RegExp', {escape: function escape(it) {
      return $re(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.string.trim-right", ["npm:core-js@1.2.3/modules/$.string-trim"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.string-trim')('trimRight', function($trim) {
    return function trimRight() {
      return $trim(this, 2);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.string.trim-left", ["npm:core-js@1.2.3/modules/$.string-trim"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.string-trim')('trimLeft', function($trim) {
    return function trimLeft() {
      return $trim(this, 1);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.string.pad-right", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.string-pad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $pad = $__require('npm:core-js@1.2.3/modules/$.string-pad');
  $def($def.P, 'String', {padRight: function padRight(maxLength) {
      return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.string-pad", ["npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/$.string-repeat", "npm:core-js@1.2.3/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      repeat = $__require('npm:core-js@1.2.3/modules/$.string-repeat'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined');
  module.exports = function(that, maxLength, fillString, left) {
    var S = String(defined(that)),
        stringLength = S.length,
        fillStr = fillString === undefined ? ' ' : String(fillString),
        intMaxLength = toLength(maxLength);
    if (intMaxLength <= stringLength)
      return S;
    if (fillStr == '')
      fillStr = ' ';
    var fillLen = intMaxLength - stringLength,
        stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen)
      stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.string.pad-left", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.string-pad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $pad = $__require('npm:core-js@1.2.3/modules/$.string-pad');
  $def($def.P, 'String', {padLeft: function padLeft(maxLength) {
      return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.string.at", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.string-at"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $at = $__require('npm:core-js@1.2.3/modules/$.string-at')(true);
  $def($def.P, 'String', {at: function at(pos) {
      return $at(this, pos);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es7.array.includes", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.array-includes", "npm:core-js@1.2.3/modules/$.unscope"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $includes = $__require('npm:core-js@1.2.3/modules/$.array-includes')(true);
  $def($def.P, 'Array', {includes: function includes(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('npm:core-js@1.2.3/modules/$.unscope')('includes');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.set-prototype-of", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.set-proto"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      setProto = $__require('npm:core-js@1.2.3/modules/$.set-proto');
  if (setProto)
    $def($def.S, 'Reflect', {setPrototypeOf: function setPrototypeOf(target, proto) {
        setProto.check(target, proto);
        try {
          setProto.set(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.set", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.property-desc", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.is-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      createDesc = $__require('npm:core-js@1.2.3/modules/$.property-desc'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  function set(target, propertyKey, V) {
    var receiver = arguments.length < 4 ? target : arguments[3],
        ownDesc = $.getDesc(anObject(target), propertyKey),
        existingDescriptor,
        proto;
    if (!ownDesc) {
      if (isObject(proto = $.getProto(target))) {
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = createDesc(0);
    }
    if (has(ownDesc, 'value')) {
      if (ownDesc.writable === false || !isObject(receiver))
        return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
  $def($def.S, 'Reflect', {set: set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.prevent-extensions", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      $preventExtensions = Object.preventExtensions;
  $def($def.S, 'Reflect', {preventExtensions: function preventExtensions(target) {
      anObject(target);
      try {
        if ($preventExtensions)
          $preventExtensions(target);
        return true;
      } catch (e) {
        return false;
      }
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.own-keys", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      Reflect = $__require('npm:core-js@1.2.3/modules/$.global').Reflect;
  module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
    var keys = $.getNames(anObject(it)),
        getSymbols = $.getSymbols;
    return getSymbols ? keys.concat(getSymbols(it)) : keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.own-keys", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.own-keys"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Reflect', {ownKeys: $__require('npm:core-js@1.2.3/modules/$.own-keys')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.is-extensible", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      $isExtensible = Object.isExtensible;
  $def($def.S, 'Reflect', {isExtensible: function isExtensible(target) {
      anObject(target);
      return $isExtensible ? $isExtensible(target) : true;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.has", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Reflect', {has: function has(target, propertyKey) {
      return propertyKey in target;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.get-prototype-of", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      getProto = $__require('npm:core-js@1.2.3/modules/$').getProto,
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  $def($def.S, 'Reflect', {getPrototypeOf: function getPrototypeOf(target) {
      return getProto(anObject(target));
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.get-own-property-descriptor", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  $def($def.S, 'Reflect', {getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return $.getDesc(anObject(target), propertyKey);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.get", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  function get(target, propertyKey) {
    var receiver = arguments.length < 3 ? target : arguments[2],
        desc,
        proto;
    if (anObject(target) === receiver)
      return target[propertyKey];
    if (desc = $.getDesc(target, propertyKey))
      return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (isObject(proto = $.getProto(target)))
      return get(proto, propertyKey, receiver);
  }
  $def($def.S, 'Reflect', {get: get});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.enumerate", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.iter-create"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  var Enumerate = function(iterated) {
    this._t = anObject(iterated);
    this._i = 0;
    var keys = this._k = [],
        key;
    for (key in iterated)
      keys.push(key);
  };
  $__require('npm:core-js@1.2.3/modules/$.iter-create')(Enumerate, 'Object', function() {
    var that = this,
        keys = that._k,
        key;
    do {
      if (that._i >= keys.length)
        return {
          value: undefined,
          done: true
        };
    } while (!((key = keys[that._i++]) in that._t));
    return {
      value: key,
      done: false
    };
  });
  $def($def.S, 'Reflect', {enumerate: function enumerate(target) {
      return new Enumerate(target);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.delete-property", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      getDesc = $__require('npm:core-js@1.2.3/modules/$').getDesc,
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  $def($def.S, 'Reflect', {deleteProperty: function deleteProperty(target, propertyKey) {
      var desc = getDesc(anObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.define-property", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  $def($def.S + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
  }), 'Reflect', {defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      try {
        $.setDesc(target, propertyKey, attributes);
        return true;
      } catch (e) {
        return false;
      }
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.construct", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.a-function", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.core", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      aFunction = $__require('npm:core-js@1.2.3/modules/$.a-function'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      bind = Function.bind || $__require('npm:core-js@1.2.3/modules/$.core').Function.prototype.bind;
  $def($def.S + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    function F() {}
    return !(Reflect.construct(function() {}, [], F) instanceof F);
  }), 'Reflect', {construct: function construct(Target, args) {
      aFunction(Target);
      var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
      if (Target == newTarget) {
        if (args != undefined)
          switch (anObject(args).length) {
            case 0:
              return new Target;
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        var $args = [null];
        $args.push.apply($args, args);
        return new (bind.apply(Target, $args));
      }
      var proto = newTarget.prototype,
          instance = $.create(isObject(proto) ? proto : Object.prototype),
          result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.reflect.apply", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      _apply = Function.apply;
  $def($def.S, 'Reflect', {apply: function apply(target, thisArgument, argumentsList) {
      return _apply.call(target, thisArgument, argumentsList);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.weak-set", ["npm:core-js@1.2.3/modules/$.collection-weak", "npm:core-js@1.2.3/modules/$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var weak = $__require('npm:core-js@1.2.3/modules/$.collection-weak');
  $__require('npm:core-js@1.2.3/modules/$.collection')('WeakSet', function(get) {
    return function WeakSet() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return weak.def(this, value, true);
    }}, weak, false, true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.collection-weak", ["npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.strict-new", "npm:core-js@1.2.3/modules/$.for-of", "npm:core-js@1.2.3/modules/$.array-methods", "npm:core-js@1.2.3/modules/$.uid", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.mix"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hide = $__require('npm:core-js@1.2.3/modules/$.hide'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      strictNew = $__require('npm:core-js@1.2.3/modules/$.strict-new'),
      forOf = $__require('npm:core-js@1.2.3/modules/$.for-of'),
      method = $__require('npm:core-js@1.2.3/modules/$.array-methods'),
      WEAK = $__require('npm:core-js@1.2.3/modules/$.uid')('weak'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      $has = $__require('npm:core-js@1.2.3/modules/$.has'),
      isExtensible = Object.isExtensible || isObject,
      find = method(5),
      findIndex = method(6),
      id = 0;
  var frozenStore = function(that) {
    return that._l || (that._l = new FrozenStore);
  };
  var FrozenStore = function() {
    this.a = [];
  };
  var findFrozen = function(store, key) {
    return find(store.a, function(it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function(key) {
      var entry = findFrozen(this, key);
      if (entry)
        return entry[1];
    },
    has: function(key) {
      return !!findFrozen(this, key);
    },
    set: function(key, value) {
      var entry = findFrozen(this, key);
      if (entry)
        entry[1] = value;
      else
        this.a.push([key, value]);
    },
    'delete': function(key) {
      var index = findIndex(this.a, function(it) {
        return it[0] === key;
      });
      if (~index)
        this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      $__require('npm:core-js@1.2.3/modules/$.mix')(C.prototype, {
        'delete': function(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function(that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.weak-map", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.collection-weak", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.collection", "npm:core-js@1.2.3/modules/$.redef"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      weak = $__require('npm:core-js@1.2.3/modules/$.collection-weak'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = $__require('npm:core-js@1.2.3/modules/$.collection')('WeakMap', function(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key))
          return frozenStore(this).get(key);
        if (has(key, WEAK))
          return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function(key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      $__require('npm:core-js@1.2.3/modules/$.redef')(proto, key, function(a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.set", ["npm:core-js@1.2.3/modules/$.collection-strong", "npm:core-js@1.2.3/modules/$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var strong = $__require('npm:core-js@1.2.3/modules/$.collection-strong');
  $__require('npm:core-js@1.2.3/modules/$.collection')('Set', function(get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    }}, strong);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.collection", ["npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.for-of", "npm:core-js@1.2.3/modules/$.strict-new", "npm:core-js@1.2.3/modules/$.redef", "npm:core-js@1.2.3/modules/$.fails", "npm:core-js@1.2.3/modules/$.mix", "npm:core-js@1.2.3/modules/$.iter-detect", "npm:core-js@1.2.3/modules/$.tag"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/modules/$.global'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      forOf = $__require('npm:core-js@1.2.3/modules/$.for-of'),
      strictNew = $__require('npm:core-js@1.2.3/modules/$.strict-new');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    var fixMethod = function(KEY) {
      var fn = proto[KEY];
      $__require('npm:core-js@1.2.3/modules/$.redef')(proto, KEY, KEY == 'delete' ? function(a) {
        return fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) {
        fn.call(this, a === 0 ? 0 : a);
        return this;
      } : function set(a, b) {
        fn.call(this, a === 0 ? 0 : a, b);
        return this;
      });
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !$__require('npm:core-js@1.2.3/modules/$.fails')(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      $__require('npm:core-js@1.2.3/modules/$.mix')(C.prototype, methods);
    } else {
      var inst = new C,
          chain = inst[ADDER](IS_WEAK ? {} : -0, 1),
          buggyZero;
      if (!$__require('npm:core-js@1.2.3/modules/$.iter-detect')(function(iter) {
        new C(iter);
      })) {
        C = wrapper(function(target, iterable) {
          strictNew(target, C, NAME);
          var that = new Base;
          if (iterable != undefined)
            forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }
      IS_WEAK || inst.forEach(function(val, key) {
        buggyZero = 1 / key === -Infinity;
      });
      if (buggyZero) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (buggyZero || chain !== inst)
        fixMethod(ADDER);
      if (IS_WEAK && proto.clear)
        delete proto.clear;
    }
    $__require('npm:core-js@1.2.3/modules/$.tag')(C, NAME);
    O[NAME] = C;
    $def($def.G + $def.W + $def.F * (C != Base), O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.collection-strong", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.ctx", "npm:core-js@1.2.3/modules/$.species", "npm:core-js@1.2.3/modules/$.strict-new", "npm:core-js@1.2.3/modules/$.defined", "npm:core-js@1.2.3/modules/$.for-of", "npm:core-js@1.2.3/modules/$.iter-step", "npm:core-js@1.2.3/modules/$.uid", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.mix", "npm:core-js@1.2.3/modules/$.iter-define", "npm:core-js@1.2.3/modules/$.core"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      hide = $__require('npm:core-js@1.2.3/modules/$.hide'),
      ctx = $__require('npm:core-js@1.2.3/modules/$.ctx'),
      species = $__require('npm:core-js@1.2.3/modules/$.species'),
      strictNew = $__require('npm:core-js@1.2.3/modules/$.strict-new'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined'),
      forOf = $__require('npm:core-js@1.2.3/modules/$.for-of'),
      step = $__require('npm:core-js@1.2.3/modules/$.iter-step'),
      ID = $__require('npm:core-js@1.2.3/modules/$.uid')('id'),
      $has = $__require('npm:core-js@1.2.3/modules/$.has'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      isExtensible = Object.isExtensible || isObject,
      SUPPORT_DESC = $__require('npm:core-js@1.2.3/modules/$.support-desc'),
      SIZE = SUPPORT_DESC ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      $__require('npm:core-js@1.2.3/modules/$.mix')(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (SUPPORT_DESC)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $__require('npm:core-js@1.2.3/modules/$.iter-define')(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      species(C);
      species($__require('npm:core-js@1.2.3/modules/$.core')[NAME]);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.map", ["npm:core-js@1.2.3/modules/$.collection-strong", "npm:core-js@1.2.3/modules/$.collection"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var strong = $__require('npm:core-js@1.2.3/modules/$.collection-strong');
  $__require('npm:core-js@1.2.3/modules/$.collection')('Map', function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.mix", ["npm:core-js@1.2.3/modules/$.redef"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $redef = $__require('npm:core-js@1.2.3/modules/$.redef');
  module.exports = function(target, src) {
    for (var key in src)
      $redef(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.task", ["npm:core-js@1.2.3/modules/$.ctx", "npm:core-js@1.2.3/modules/$.invoke", "npm:core-js@1.2.3/modules/$.html", "npm:core-js@1.2.3/modules/$.dom-create", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.cof", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ctx = $__require('npm:core-js@1.2.3/modules/$.ctx'),
        invoke = $__require('npm:core-js@1.2.3/modules/$.invoke'),
        html = $__require('npm:core-js@1.2.3/modules/$.html'),
        cel = $__require('npm:core-js@1.2.3/modules/$.dom-create'),
        global = $__require('npm:core-js@1.2.3/modules/$.global'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('npm:core-js@1.2.3/modules/$.cof')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.microtask", ["npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.task", "npm:core-js@1.2.3/modules/$.cof", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('npm:core-js@1.2.3/modules/$.global'),
        macrotask = $__require('npm:core-js@1.2.3/modules/$.task').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        isNode = $__require('npm:core-js@1.2.3/modules/$.cof')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        if (domain)
          domain.enter();
        head.fn.call();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.species-constructor", ["npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.a-function", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      aFunction = $__require('npm:core-js@1.2.3/modules/$.a-function'),
      SPECIES = $__require('npm:core-js@1.2.3/modules/$.wks')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.for-of", ["npm:core-js@1.2.3/modules/$.ctx", "npm:core-js@1.2.3/modules/$.iter-call", "npm:core-js@1.2.3/modules/$.is-array-iter", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/core.get-iterator-method"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.2.3/modules/$.ctx'),
      call = $__require('npm:core-js@1.2.3/modules/$.iter-call'),
      isArrayIter = $__require('npm:core-js@1.2.3/modules/$.is-array-iter'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      getIterFn = $__require('npm:core-js@1.2.3/modules/core.get-iterator-method');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.strict-new", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.promise", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.library", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.ctx", "npm:core-js@1.2.3/modules/$.classof", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.a-function", "npm:core-js@1.2.3/modules/$.strict-new", "npm:core-js@1.2.3/modules/$.for-of", "npm:core-js@1.2.3/modules/$.set-proto", "npm:core-js@1.2.3/modules/$.same", "npm:core-js@1.2.3/modules/$.species", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.species-constructor", "npm:core-js@1.2.3/modules/$.uid", "npm:core-js@1.2.3/modules/$.microtask", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.mix", "npm:core-js@1.2.3/modules/$.tag", "npm:core-js@1.2.3/modules/$.core", "npm:core-js@1.2.3/modules/$.iter-detect", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('npm:core-js@1.2.3/modules/$'),
        LIBRARY = $__require('npm:core-js@1.2.3/modules/$.library'),
        global = $__require('npm:core-js@1.2.3/modules/$.global'),
        ctx = $__require('npm:core-js@1.2.3/modules/$.ctx'),
        classof = $__require('npm:core-js@1.2.3/modules/$.classof'),
        $def = $__require('npm:core-js@1.2.3/modules/$.def'),
        isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
        anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
        aFunction = $__require('npm:core-js@1.2.3/modules/$.a-function'),
        strictNew = $__require('npm:core-js@1.2.3/modules/$.strict-new'),
        forOf = $__require('npm:core-js@1.2.3/modules/$.for-of'),
        setProto = $__require('npm:core-js@1.2.3/modules/$.set-proto').set,
        same = $__require('npm:core-js@1.2.3/modules/$.same'),
        species = $__require('npm:core-js@1.2.3/modules/$.species'),
        SPECIES = $__require('npm:core-js@1.2.3/modules/$.wks')('species'),
        speciesConstructor = $__require('npm:core-js@1.2.3/modules/$.species-constructor'),
        RECORD = $__require('npm:core-js@1.2.3/modules/$.uid')('record'),
        asap = $__require('npm:core-js@1.2.3/modules/$.microtask'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var useNative = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('npm:core-js@1.2.3/modules/$.support-desc')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var isPromise = function(it) {
      return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
    };
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(react) {
          var cb = ok ? react.ok : react.fail,
              ret,
              then;
          try {
            if (cb) {
              if (!ok)
                record.h = true;
              ret = cb === true ? value : cb(value);
              if (ret === react.P) {
                react.rej(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(ret)) {
                then.call(ret, react.res, react.rej);
              } else
                react.res(ret);
            } else
              react.rej(value);
          } catch (err) {
            react.rej(err);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise[RECORD],
          chain = record.a || record.c,
          i = 0,
          react;
      if (record.h)
        return false;
      while (chain.length > i) {
        react = chain[i++];
        if (react.fail || !isUnhandled(react.P))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!useNative) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        this[RECORD] = record;
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('npm:core-js@1.2.3/modules/$.mix')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var react = {
            ok: typeof onFulfilled == 'function' ? onFulfilled : true,
            fail: typeof onRejected == 'function' ? onRejected : false
          };
          var promise = react.P = new (speciesConstructor(this, P))(function(res, rej) {
            react.res = res;
            react.rej = rej;
          });
          aFunction(react.res);
          aFunction(react.rej);
          var record = this[RECORD];
          record.c.push(react);
          if (record.a)
            record.a.push(react);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
    $__require('npm:core-js@1.2.3/modules/$.tag')(P, PROMISE);
    species(P);
    species(Wrapper = $__require('npm:core-js@1.2.3/modules/$.core')[PROMISE]);
    $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
        return new this(function(res, rej) {
          rej(r);
        });
      }});
    $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
          res(x);
        });
      }});
    $def($def.S + $def.F * !(useNative && $__require('npm:core-js@1.2.3/modules/$.iter-detect')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            values = [];
        return new C(function(res, rej) {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              C.resolve(promise).then(function(value) {
                results[index] = value;
                --remaining || res(results);
              }, rej);
            });
          else
            res(results);
        });
      },
      race: function race(iterable) {
        var C = getConstructor(this);
        return new C(function(res, rej) {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(res, rej);
          });
        });
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.regexp.split", ["npm:core-js@1.2.3/modules/$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.fix-re-wks')('split', 2, function(defined, SPLIT, $split) {
    return function split(separator, limit) {
      'use strict';
      var O = defined(this),
          fn = separator == undefined ? undefined : separator[SPLIT];
      return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.regexp.search", ["npm:core-js@1.2.3/modules/$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.fix-re-wks')('search', 1, function(defined, SEARCH) {
    return function search(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.regexp.replace", ["npm:core-js@1.2.3/modules/$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.fix-re-wks')('replace', 2, function(defined, REPLACE, $replace) {
    return function replace(searchValue, replaceValue) {
      'use strict';
      var O = defined(this),
          fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.fix-re-wks", ["npm:core-js@1.2.3/modules/$.defined", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.fails", "npm:core-js@1.2.3/modules/$.redef", "npm:core-js@1.2.3/modules/$.hide"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY, length, exec) {
    var defined = $__require('npm:core-js@1.2.3/modules/$.defined'),
        SYMBOL = $__require('npm:core-js@1.2.3/modules/$.wks')(KEY),
        original = ''[KEY];
    if ($__require('npm:core-js@1.2.3/modules/$.fails')(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ''[KEY](O) != 7;
    })) {
      $__require('npm:core-js@1.2.3/modules/$.redef')(String.prototype, KEY, exec(defined, SYMBOL, original));
      $__require('npm:core-js@1.2.3/modules/$.hide')(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
        return original.call(string, this, arg);
      } : function(string) {
        return original.call(string, this);
      });
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.regexp.match", ["npm:core-js@1.2.3/modules/$.fix-re-wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.fix-re-wks')('match', 1, function(defined, MATCH) {
    return function match(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.regexp.flags", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.flags"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$');
  if ($__require('npm:core-js@1.2.3/modules/$.support-desc') && /./g.flags != 'g')
    $.setDesc(RegExp.prototype, 'flags', {
      configurable: true,
      get: $__require('npm:core-js@1.2.3/modules/$.flags')
    });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.flags", ["npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  module.exports = function() {
    var that = anObject(this),
        result = '';
    if (that.global)
      result += 'g';
    if (that.ignoreCase)
      result += 'i';
    if (that.multiline)
      result += 'm';
    if (that.unicode)
      result += 'u';
    if (that.sticky)
      result += 'y';
    return result;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.regexp.constructor", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.is-regexp", "npm:core-js@1.2.3/modules/$.flags", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.fails", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.redef", "npm:core-js@1.2.3/modules/$.species"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      global = $__require('npm:core-js@1.2.3/modules/$.global'),
      isRegExp = $__require('npm:core-js@1.2.3/modules/$.is-regexp'),
      $flags = $__require('npm:core-js@1.2.3/modules/$.flags'),
      $RegExp = global.RegExp,
      Base = $RegExp,
      proto = $RegExp.prototype,
      re1 = /a/g,
      re2 = /a/g,
      CORRECT_NEW = new $RegExp(re1) !== re1;
  if ($__require('npm:core-js@1.2.3/modules/$.support-desc') && (!CORRECT_NEW || $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    re2[$__require('npm:core-js@1.2.3/modules/$.wks')('match')] = false;
    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
  }))) {
    $RegExp = function RegExp(p, f) {
      var piRE = isRegExp(p),
          fiU = f === undefined;
      return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p : CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
    };
    $.each.call($.getNames(Base), function(key) {
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function() {
          return Base[key];
        },
        set: function(it) {
          Base[key] = it;
        }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    $__require('npm:core-js@1.2.3/modules/$.redef')(global, 'RegExp', $RegExp);
  }
  $__require('npm:core-js@1.2.3/modules/$.species')($RegExp);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.find-index", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.array-methods", "npm:core-js@1.2.3/modules/$.unscope"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var KEY = 'findIndex',
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      forced = true,
      $find = $__require('npm:core-js@1.2.3/modules/$.array-methods')(6);
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $def($def.P + $def.F * forced, 'Array', {findIndex: function findIndex(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('npm:core-js@1.2.3/modules/$.unscope')(KEY);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.find", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.array-methods", "npm:core-js@1.2.3/modules/$.unscope"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var KEY = 'find',
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      forced = true,
      $find = $__require('npm:core-js@1.2.3/modules/$.array-methods')(5);
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $def($def.P + $def.F * forced, 'Array', {find: function find(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('npm:core-js@1.2.3/modules/$.unscope')(KEY);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.array-fill", ["npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.to-index", "npm:core-js@1.2.3/modules/$.to-length"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.2.3/modules/$.to-object'),
      toIndex = $__require('npm:core-js@1.2.3/modules/$.to-index'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length');
  module.exports = [].fill || function fill(value) {
    var O = toObject(this, true),
        length = toLength(O.length),
        $$ = arguments,
        $$len = $$.length,
        index = toIndex($$len > 1 ? $$[1] : undefined, length),
        end = $$len > 2 ? $$[2] : undefined,
        endPos = end === undefined ? length : toIndex(end, length);
    while (endPos > index)
      O[index++] = value;
    return O;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.fill", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.array-fill", "npm:core-js@1.2.3/modules/$.unscope"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.P, 'Array', {fill: $__require('npm:core-js@1.2.3/modules/$.array-fill')});
  $__require('npm:core-js@1.2.3/modules/$.unscope')('fill');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.array-copy-within", ["npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.to-index", "npm:core-js@1.2.3/modules/$.to-length"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.2.3/modules/$.to-object'),
      toIndex = $__require('npm:core-js@1.2.3/modules/$.to-index'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length');
  module.exports = [].copyWithin || function copyWithin(target, start) {
    var O = toObject(this),
        len = toLength(O.length),
        to = toIndex(target, len),
        from = toIndex(start, len),
        $$ = arguments,
        end = $$.length > 2 ? $$[2] : undefined,
        count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
        inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O)
        O[to] = O[from];
      else
        delete O[to];
      to += inc;
      from += inc;
    }
    return O;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.copy-within", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.array-copy-within", "npm:core-js@1.2.3/modules/$.unscope"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.P, 'Array', {copyWithin: $__require('npm:core-js@1.2.3/modules/$.array-copy-within')});
  $__require('npm:core-js@1.2.3/modules/$.unscope')('copyWithin');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.species", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.support-desc"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      SPECIES = $__require('npm:core-js@1.2.3/modules/$.wks')('species');
  module.exports = function(C) {
    if ($__require('npm:core-js@1.2.3/modules/$.support-desc') && !(SPECIES in C))
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.species", ["npm:core-js@1.2.3/modules/$.species"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.species')(Array);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iter-step", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.unscope", ["npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.hide"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNSCOPABLES = $__require('npm:core-js@1.2.3/modules/$.wks')('unscopables');
  if ([][UNSCOPABLES] == undefined)
    $__require('npm:core-js@1.2.3/modules/$.hide')(Array.prototype, UNSCOPABLES, {});
  module.exports = function(key) {
    [][UNSCOPABLES][key] = true;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.iterator", ["npm:core-js@1.2.3/modules/$.unscope", "npm:core-js@1.2.3/modules/$.iter-step", "npm:core-js@1.2.3/modules/$.iterators", "npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var setUnscope = $__require('npm:core-js@1.2.3/modules/$.unscope'),
      step = $__require('npm:core-js@1.2.3/modules/$.iter-step'),
      Iterators = $__require('npm:core-js@1.2.3/modules/$.iterators'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject');
  $__require('npm:core-js@1.2.3/modules/$.iter-define')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  setUnscope('keys');
  setUnscope('values');
  setUnscope('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.of", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    function F() {}
    return !(Array.of.call(F) instanceof F);
  }), 'Array', {of: function of() {
      var index = 0,
          $$ = arguments,
          $$len = $$.length,
          result = new (typeof this == 'function' ? this : Array)($$len);
      while ($$len > index)
        result[index] = $$[index++];
      result.length = $$len;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iter-detect", ["npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SYMBOL_ITERATOR = $__require('npm:core-js@1.2.3/modules/$.wks')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][SYMBOL_ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[SYMBOL_ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[SYMBOL_ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/core.get-iterator-method", ["npm:core-js@1.2.3/modules/$.classof", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.iterators", "npm:core-js@1.2.3/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.3/modules/$.classof'),
      ITERATOR = $__require('npm:core-js@1.2.3/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.3/modules/$.iterators');
  module.exports = $__require('npm:core-js@1.2.3/modules/$.core').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.is-array-iter", ["npm:core-js@1.2.3/modules/$.iterators", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('npm:core-js@1.2.3/modules/$.iterators'),
      ITERATOR = $__require('npm:core-js@1.2.3/modules/$.wks')('iterator');
  module.exports = function(it) {
    return (Iterators.Array || Array.prototype[ITERATOR]) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iter-call", ["npm:core-js@1.2.3/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.array.from", ["npm:core-js@1.2.3/modules/$.ctx", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.iter-call", "npm:core-js@1.2.3/modules/$.is-array-iter", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/core.get-iterator-method", "npm:core-js@1.2.3/modules/$.iter-detect"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.2.3/modules/$.ctx'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      toObject = $__require('npm:core-js@1.2.3/modules/$.to-object'),
      call = $__require('npm:core-js@1.2.3/modules/$.iter-call'),
      isArrayIter = $__require('npm:core-js@1.2.3/modules/$.is-array-iter'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      getIterFn = $__require('npm:core-js@1.2.3/modules/core.get-iterator-method');
  $def($def.S + $def.F * !$__require('npm:core-js@1.2.3/modules/$.iter-detect')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.starts-with", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/$.string-context", "npm:core-js@1.2.3/modules/$.fails-is-regexp"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      context = $__require('npm:core-js@1.2.3/modules/$.string-context'),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];
  $def($def.P + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails-is-regexp')(STARTS_WITH), 'String', {startsWith: function startsWith(searchString) {
      var that = context(this, searchString, STARTS_WITH),
          $$ = arguments,
          index = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.string-repeat", ["npm:core-js@1.2.3/modules/$.to-integer", "npm:core-js@1.2.3/modules/$.defined"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.3/modules/$.to-integer'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined');
  module.exports = function repeat(count) {
    var str = String(defined(this)),
        res = '',
        n = toInteger(count);
    if (n < 0 || n == Infinity)
      throw RangeError("Count can't be negative");
    for (; n > 0; (n >>>= 1) && (str += str))
      if (n & 1)
        res += str;
    return res;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.repeat", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.string-repeat"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.P, 'String', {repeat: $__require('npm:core-js@1.2.3/modules/$.string-repeat')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.includes", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.string-context", "npm:core-js@1.2.3/modules/$.fails-is-regexp"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      context = $__require('npm:core-js@1.2.3/modules/$.string-context'),
      INCLUDES = 'includes';
  $def($def.P + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails-is-regexp')(INCLUDES), 'String', {includes: function includes(searchString) {
      return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.fails-is-regexp", ["npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[$__require('npm:core-js@1.2.3/modules/$.wks')('match')] = false;
        return !'/./'[KEY](re);
      } catch (f) {}
    }
    return true;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.is-regexp", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.cof", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      cof = $__require('npm:core-js@1.2.3/modules/$.cof'),
      MATCH = $__require('npm:core-js@1.2.3/modules/$.wks')('match');
  module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.string-context", ["npm:core-js@1.2.3/modules/$.is-regexp", "npm:core-js@1.2.3/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isRegExp = $__require('npm:core-js@1.2.3/modules/$.is-regexp'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined');
  module.exports = function(that, searchString, NAME) {
    if (isRegExp(searchString))
      throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.ends-with", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/$.string-context", "npm:core-js@1.2.3/modules/$.fails-is-regexp"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      context = $__require('npm:core-js@1.2.3/modules/$.string-context'),
      ENDS_WITH = 'endsWith',
      $endsWith = ''[ENDS_WITH];
  $def($def.P + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails-is-regexp')(ENDS_WITH), 'String', {endsWith: function endsWith(searchString) {
      var that = context(this, searchString, ENDS_WITH),
          $$ = arguments,
          endPosition = $$.length > 1 ? $$[1] : undefined,
          len = toLength(that.length),
          end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
          search = String(searchString);
      return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.code-point-at", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.string-at"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $at = $__require('npm:core-js@1.2.3/modules/$.string-at')(false);
  $def($def.P, 'String', {codePointAt: function codePointAt(pos) {
      return $at(this, pos);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iter-create", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.property-desc", "npm:core-js@1.2.3/modules/$.tag"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.3/modules/$.hide')(IteratorPrototype, $__require('npm:core-js@1.2.3/modules/$.wks')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: $__require('npm:core-js@1.2.3/modules/$.property-desc')(1, next)});
    $__require('npm:core-js@1.2.3/modules/$.tag')(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iterators", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iter-define", ["npm:core-js@1.2.3/modules/$.library", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.redef", "npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.iterators", "npm:core-js@1.2.3/modules/$.iter-create", "npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.tag"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('npm:core-js@1.2.3/modules/$.library'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $redef = $__require('npm:core-js@1.2.3/modules/$.redef'),
      hide = $__require('npm:core-js@1.2.3/modules/$.hide'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      SYMBOL_ITERATOR = $__require('npm:core-js@1.2.3/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.3/modules/$.iterators'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
    $__require('npm:core-js@1.2.3/modules/$.iter-create')(Constructor, NAME, next);
    var createMethod = function(kind) {
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        proto = Base.prototype,
        _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        _default = _native || createMethod(DEFAULT),
        methods,
        key;
    if (_native) {
      var IteratorPrototype = $__require('npm:core-js@1.2.3/modules/$').getProto(_default.call(new Base));
      $__require('npm:core-js@1.2.3/modules/$.tag')(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
    }
    if (!LIBRARY || FORCE)
      hide(proto, SYMBOL_ITERATOR, _default);
    Iterators[NAME] = _default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEFAULT == VALUES ? _default : createMethod(VALUES),
        keys: IS_SET ? _default : createMethod(KEYS),
        entries: DEFAULT != VALUES ? _default : createMethod('entries')
      };
      if (FORCE)
        for (key in methods) {
          if (!(key in proto))
            $redef(proto, key, methods[key]);
        }
      else
        $def($def.P + $def.F * BUGGY, NAME, methods);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.string-at", ["npm:core-js@1.2.3/modules/$.to-integer", "npm:core-js@1.2.3/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.3/modules/$.to-integer'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.iterator", ["npm:core-js@1.2.3/modules/$.string-at", "npm:core-js@1.2.3/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('npm:core-js@1.2.3/modules/$.string-at')(true);
  $__require('npm:core-js@1.2.3/modules/$.iter-define')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.string-trim", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.defined", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var trim = function(string, TYPE) {
    string = String(defined(string));
    if (TYPE & 1)
      string = string.replace(ltrim, '');
    if (TYPE & 2)
      string = string.replace(rtrim, '');
    return string;
  };
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined'),
      spaces = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',
      space = '[' + spaces + ']',
      non = '\u200b\u0085',
      ltrim = RegExp('^' + space + space + '*'),
      rtrim = RegExp(space + space + '*$');
  module.exports = function(KEY, exec) {
    var exp = {};
    exp[KEY] = exec(trim);
    $def($def.P + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
      return !!spaces[KEY]() || non[KEY]() != non;
    }), 'String', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.trim", ["npm:core-js@1.2.3/modules/$.string-trim"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.string-trim')('trim', function($trim) {
    return function trim() {
      return $trim(this, 3);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.raw", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.to-length"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length');
  $def($def.S, 'String', {raw: function raw(callSite) {
      var tpl = toIObject(callSite.raw),
          len = toLength(tpl.length),
          $$ = arguments,
          $$len = $$.length,
          res = [],
          i = 0;
      while (len > i) {
        res.push(String(tpl[i++]));
        if (i < $$len)
          res.push(String($$[i]));
      }
      return res.join('');
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.string.from-code-point", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.to-index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      toIndex = $__require('npm:core-js@1.2.3/modules/$.to-index'),
      fromCharCode = String.fromCharCode,
      $fromCodePoint = String.fromCodePoint;
  $def($def.S + $def.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {fromCodePoint: function fromCodePoint(x) {
      var res = [],
          $$ = arguments,
          $$len = $$.length,
          i = 0,
          code;
      while ($$len > i) {
        code = +$$[i++];
        if (toIndex(code, 0x10ffff) !== code)
          throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
      }
      return res.join('');
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.trunc", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {trunc: function trunc(it) {
      return (it > 0 ? Math.floor : Math.ceil)(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.tanh", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.expm1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      expm1 = $__require('npm:core-js@1.2.3/modules/$.expm1'),
      exp = Math.exp;
  $def($def.S, 'Math', {tanh: function tanh(x) {
      var a = expm1(x = +x),
          b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.sinh", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.expm1", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      expm1 = $__require('npm:core-js@1.2.3/modules/$.expm1'),
      exp = Math.exp;
  $def($def.S + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    return !Math.sinh(-2e-17) != -2e-17;
  }), 'Math', {sinh: function sinh(x) {
      return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.sign", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.sign"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {sign: $__require('npm:core-js@1.2.3/modules/$.sign')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.log2", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {log2: function log2(x) {
      return Math.log(x) / Math.LN2;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.log1p", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.log1p"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {log1p: $__require('npm:core-js@1.2.3/modules/$.log1p')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.log10", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {log10: function log10(x) {
      return Math.log(x) / Math.LN10;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.imul", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $imul = Math.imul;
  $def($def.S + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
  }), 'Math', {imul: function imul(x, y) {
      var UINT16 = 0xffff,
          xn = +x,
          yn = +y,
          xl = UINT16 & xn,
          yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.hypot", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      abs = Math.abs;
  $def($def.S, 'Math', {hypot: function hypot(value1, value2) {
      var sum = 0,
          i = 0,
          $$ = arguments,
          $$len = $$.length,
          larg = 0,
          arg,
          div;
      while (i < $$len) {
        arg = abs($$[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else
          sum += arg;
      }
      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.fround", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.sign"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      sign = $__require('npm:core-js@1.2.3/modules/$.sign'),
      pow = Math.pow,
      EPSILON = pow(2, -52),
      EPSILON32 = pow(2, -23),
      MAX32 = pow(2, 127) * (2 - EPSILON32),
      MIN32 = pow(2, -126);
  var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };
  $def($def.S, 'Math', {fround: function fround(x) {
      var $abs = Math.abs(x),
          $sign = sign(x),
          a,
          result;
      if ($abs < MIN32)
        return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result)
        return $sign * Infinity;
      return $sign * result;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.expm1", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.expm1 || function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.expm1", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.expm1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {expm1: $__require('npm:core-js@1.2.3/modules/$.expm1')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.cosh", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      exp = Math.exp;
  $def($def.S, 'Math', {cosh: function cosh(x) {
      return (exp(x = +x) + exp(-x)) / 2;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.clz32", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.sign", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.sign || function sign(x) {
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.cbrt", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.sign"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      sign = $__require('npm:core-js@1.2.3/modules/$.sign');
  $def($def.S, 'Math', {cbrt: function cbrt(x) {
      return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.atanh", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Math', {atanh: function atanh(x) {
      return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.asinh", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  }
  $def($def.S, 'Math', {asinh: asinh});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.log1p", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.math.acosh", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.log1p"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      log1p = $__require('npm:core-js@1.2.3/modules/$.log1p'),
      sqrt = Math.sqrt,
      $acosh = Math.acosh;
  $def($def.S + $def.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.parse-int", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {parseInt: parseInt});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.parse-float", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {parseFloat: parseFloat});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.min-safe-integer", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.max-safe-integer", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.is-safe-integer", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.is-integer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      isInteger = $__require('npm:core-js@1.2.3/modules/$.is-integer'),
      abs = Math.abs;
  $def($def.S, 'Number', {isSafeInteger: function isSafeInteger(number) {
      return isInteger(number) && abs(number) <= 0x1fffffffffffff;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.is-nan", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {isNaN: function isNaN(number) {
      return number != number;
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.is-integer", ["npm:core-js@1.2.3/modules/$.is-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      floor = Math.floor;
  module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.is-integer", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.is-integer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {isInteger: $__require('npm:core-js@1.2.3/modules/$.is-integer')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.is-finite", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      _isFinite = $__require('npm:core-js@1.2.3/modules/$.global').isFinite;
  $def($def.S, 'Number', {isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.epsilon", ["npm:core-js@1.2.3/modules/$.def"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Number', {EPSILON: Math.pow(2, -52)});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.number.constructor", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.cof", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.fails", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.redef"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      global = $__require('npm:core-js@1.2.3/modules/$.global'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      cof = $__require('npm:core-js@1.2.3/modules/$.cof'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      fails = $__require('npm:core-js@1.2.3/modules/$.fails'),
      NUMBER = 'Number',
      $Number = global[NUMBER],
      Base = $Number,
      proto = $Number.prototype,
      BROKEN_COF = cof($.create(proto)) == NUMBER;
  var toPrimitive = function(it) {
    var fn,
        val;
    if (typeof(fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))
      return val;
    if (typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
      return val;
    throw TypeError("Can't convert object to number");
  };
  var toNumber = function(it) {
    if (isObject(it))
      it = toPrimitive(it);
    if (typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48) {
      var binary = false;
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          binary = true;
        case 79:
        case 111:
          return parseInt(it.slice(2), binary ? 2 : 8);
      }
    }
    return +it;
  };
  if (!($Number('0o1') && $Number('0b1'))) {
    $Number = function Number(it) {
      var that = this;
      return that instanceof $Number && (BROKEN_COF ? fails(function() {
        proto.valueOf.call(that);
      }) : cof(that) != NUMBER) ? new Base(toNumber(it)) : toNumber(it);
    };
    $.each.call($__require('npm:core-js@1.2.3/modules/$.support-desc') ? $.getNames(Base) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), function(key) {
      if (has(Base, key) && !has($Number, key)) {
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    });
    $Number.prototype = proto;
    proto.constructor = $Number;
    $__require('npm:core-js@1.2.3/modules/$.redef')(global, NUMBER, $Number);
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.function.has-instance", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      HAS_INSTANCE = $__require('npm:core-js@1.2.3/modules/$.wks')('hasInstance'),
      FunctionProto = Function.prototype;
  if (!(HAS_INSTANCE in FunctionProto))
    $.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O) {
        if (typeof this != 'function' || !isObject(O))
          return false;
        if (!isObject(this.prototype))
          return O instanceof this;
        while (O = $.getProto(O))
          if (this.prototype === O)
            return true;
        return false;
      }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.function.name", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.property-desc", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.support-desc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var setDesc = $__require('npm:core-js@1.2.3/modules/$').setDesc,
      createDesc = $__require('npm:core-js@1.2.3/modules/$.property-desc'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      FProto = Function.prototype,
      nameRE = /^\s*function ([^ (]*)/,
      NAME = 'name';
  NAME in FProto || $__require('npm:core-js@1.2.3/modules/$.support-desc') && setDesc(FProto, NAME, {
    configurable: true,
    get: function() {
      var match = ('' + this).match(nameRE),
          name = match ? match[1] : '';
      has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
      return name;
    }
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.get-own-property-names", ["npm:core-js@1.2.3/modules/$.object-sap", "npm:core-js@1.2.3/modules/$.get-names"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('getOwnPropertyNames', function() {
    return $__require('npm:core-js@1.2.3/modules/$.get-names').get;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.keys", ["npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.2.3/modules/$.to-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.get-prototype-of", ["npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.2.3/modules/$.to-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('getPrototypeOf', function($getPrototypeOf) {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.get-own-property-descriptor", ["npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.is-extensible", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('isExtensible', function($isExtensible) {
    return function isExtensible(it) {
      return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.is-sealed", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('isSealed', function($isSealed) {
    return function isSealed(it) {
      return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.is-frozen", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('isFrozen', function($isFrozen) {
    return function isFrozen(it) {
      return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.prevent-extensions", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('preventExtensions', function($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.seal", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('seal', function($seal) {
    return function seal(it) {
      return $seal && isObject(it) ? $seal(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.object-sap", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.core", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY, exec) {
    var $def = $__require('npm:core-js@1.2.3/modules/$.def'),
        fn = ($__require('npm:core-js@1.2.3/modules/$.core').Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $def($def.S + $def.F * $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.freeze", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  $__require('npm:core-js@1.2.3/modules/$.object-sap')('freeze', function($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.classof", ["npm:core-js@1.2.3/modules/$.cof", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.3/modules/$.cof'),
      TAG = $__require('npm:core-js@1.2.3/modules/$.wks')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.to-string", ["npm:core-js@1.2.3/modules/$.classof", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.redef"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.3/modules/$.classof'),
      test = {};
  test[$__require('npm:core-js@1.2.3/modules/$.wks')('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    $__require('npm:core-js@1.2.3/modules/$.redef')(Object.prototype, 'toString', function toString() {
      return '[object ' + classof(this) + ']';
    }, true);
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.set-proto", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.ctx"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('npm:core-js@1.2.3/modules/$').getDesc,
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.3/modules/$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.set-prototype-of", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.set-proto"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Object', {setPrototypeOf: $__require('npm:core-js@1.2.3/modules/$.set-proto').set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.same", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.is", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.same"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S, 'Object', {is: $__require('npm:core-js@1.2.3/modules/$.same')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.assign", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.iobject", "npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      toObject = $__require('npm:core-js@1.2.3/modules/$.to-object'),
      IObject = $__require('npm:core-js@1.2.3/modules/$.iobject');
  module.exports = $__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.object.assign", ["npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.assign"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.2.3/modules/$.def');
  $def($def.S + $def.F, 'Object', {assign: $__require('npm:core-js@1.2.3/modules/$.assign')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.library", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = false;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.enum-keys", ["npm:core-js@1.2.3/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.get-names", ["npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString,
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      getNames = $__require('npm:core-js@1.2.3/modules/$').getNames;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.keyof", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.to-iobject"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.tag", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('npm:core-js@1.2.3/modules/$').setDesc,
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      TAG = $__require('npm:core-js@1.2.3/modules/$.wks')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es6.symbol", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.redef", "npm:core-js@1.2.3/modules/$.fails", "npm:core-js@1.2.3/modules/$.shared", "npm:core-js@1.2.3/modules/$.tag", "npm:core-js@1.2.3/modules/$.uid", "npm:core-js@1.2.3/modules/$.wks", "npm:core-js@1.2.3/modules/$.keyof", "npm:core-js@1.2.3/modules/$.get-names", "npm:core-js@1.2.3/modules/$.enum-keys", "npm:core-js@1.2.3/modules/$.is-array", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.property-desc", "npm:core-js@1.2.3/modules/$.library"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      global = $__require('npm:core-js@1.2.3/modules/$.global'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      SUPPORT_DESC = $__require('npm:core-js@1.2.3/modules/$.support-desc'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      $redef = $__require('npm:core-js@1.2.3/modules/$.redef'),
      $fails = $__require('npm:core-js@1.2.3/modules/$.fails'),
      shared = $__require('npm:core-js@1.2.3/modules/$.shared'),
      setTag = $__require('npm:core-js@1.2.3/modules/$.tag'),
      uid = $__require('npm:core-js@1.2.3/modules/$.uid'),
      wks = $__require('npm:core-js@1.2.3/modules/$.wks'),
      keyOf = $__require('npm:core-js@1.2.3/modules/$.keyof'),
      $names = $__require('npm:core-js@1.2.3/modules/$.get-names'),
      enumKeys = $__require('npm:core-js@1.2.3/modules/$.enum-keys'),
      isArray = $__require('npm:core-js@1.2.3/modules/$.is-array'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      createDesc = $__require('npm:core-js@1.2.3/modules/$.property-desc'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = SUPPORT_DESC && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    $redef($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (SUPPORT_DESC && !$__require('npm:core-js@1.2.3/modules/$.library')) {
      $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $def($def.G + $def.W, {Symbol: $Symbol});
  $def($def.S, 'Symbol', symbolStatics);
  $def($def.S + $def.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setTag($Symbol, 'Symbol');
  setTag(Math, 'Math', true);
  setTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.array-includes", ["npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/$.to-index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      toIndex = $__require('npm:core-js@1.2.3/modules/$.to-index');
  module.exports = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value)
            return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) {
            if (O[index] === el)
              return IS_INCLUDES || index;
          }
      return !IS_INCLUDES && -1;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.to-index", ["npm:core-js@1.2.3/modules/$.to-integer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.3/modules/$.to-integer'),
      max = Math.max,
      min = Math.min;
  module.exports = function(index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.to-iobject", ["npm:core-js@1.2.3/modules/$.iobject", "npm:core-js@1.2.3/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.2.3/modules/$.iobject'),
      defined = $__require('npm:core-js@1.2.3/modules/$.defined');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.an-object", ["npm:core-js@1.2.3/modules/$.is-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.shared", ["npm:core-js@1.2.3/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/modules/$.global'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.wks", ["npm:core-js@1.2.3/modules/$.shared", "npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.uid"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('npm:core-js@1.2.3/modules/$.shared')('wks'),
      Symbol = $__require('npm:core-js@1.2.3/modules/$.global').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || $__require('npm:core-js@1.2.3/modules/$.uid'))('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.is-array", ["npm:core-js@1.2.3/modules/$.cof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.3/modules/$.cof');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.to-integer", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.to-length", ["npm:core-js@1.2.3/modules/$.to-integer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.3/modules/$.to-integer'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.defined", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.to-object", ["npm:core-js@1.2.3/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('npm:core-js@1.2.3/modules/$.defined');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.iobject", ["npm:core-js@1.2.3/modules/$.cof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.3/modules/$.cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.a-function", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.ctx", ["npm:core-js@1.2.3/modules/$.a-function"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.2.3/modules/$.a-function');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.array-methods", ["npm:core-js@1.2.3/modules/$.ctx", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.iobject", "npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/$.is-array", "npm:core-js@1.2.3/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.2.3/modules/$.ctx'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      IObject = $__require('npm:core-js@1.2.3/modules/$.iobject'),
      toObject = $__require('npm:core-js@1.2.3/modules/$.to-object'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      isArray = $__require('npm:core-js@1.2.3/modules/$.is-array'),
      SPECIES = $__require('npm:core-js@1.2.3/modules/$.wks')('species');
  var ASC = function(original, length) {
    var C;
    if (isArray(original) && isObject(C = original.constructor)) {
      C = C[SPECIES];
      if (C === null)
        C = undefined;
    }
    return new (C === undefined ? Array : C)(length);
  };
  module.exports = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? ASC($this, length) : IS_FILTER ? ASC($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.invoke", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.uid", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.redef", ["npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.uid", "npm:core-js@1.2.3/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/modules/$.global'),
      hide = $__require('npm:core-js@1.2.3/modules/$.hide'),
      SRC = $__require('npm:core-js@1.2.3/modules/$.uid')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);
  $__require('npm:core-js@1.2.3/modules/$.core').inspectSource = function(it) {
    return $toString.call(it);
  };
  (module.exports = function(O, key, val, safe) {
    if (typeof val == 'function') {
      val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      val.hasOwnProperty('name') || hide(val, 'name', key);
    }
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe)
        delete O[key];
      hide(O, key, val);
    }
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.hide", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.property-desc", "npm:core-js@1.2.3/modules/$.support-desc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      createDesc = $__require('npm:core-js@1.2.3/modules/$.property-desc');
  module.exports = $__require('npm:core-js@1.2.3/modules/$.support-desc') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.core", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.3'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.def", ["npm:core-js@1.2.3/modules/$.global", "npm:core-js@1.2.3/modules/$.core", "npm:core-js@1.2.3/modules/$.hide", "npm:core-js@1.2.3/modules/$.redef"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/modules/$.global'),
      core = $__require('npm:core-js@1.2.3/modules/$.core'),
      hide = $__require('npm:core-js@1.2.3/modules/$.hide'),
      $redef = $__require('npm:core-js@1.2.3/modules/$.redef'),
      PROTOTYPE = 'prototype';
  var ctx = function(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var $def = function(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      out = (own ? target : source)[key];
      if (type & $def.B && own)
        exp = ctx(out, global);
      else
        exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (target && !own)
        $redef(target, key, out);
      if (exports[key] != out)
        hide(exports, key, exp);
      if (isProto)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  global.core = core;
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.cof", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.has", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.is-object", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.dom-create", ["npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      document = $__require('npm:core-js@1.2.3/modules/$.global').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.global", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.html", ["npm:core-js@1.2.3/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.3/modules/$.global').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.property-desc", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.fails", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$.support-desc", ["npm:core-js@1.2.3/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('npm:core-js@1.2.3/modules/$.fails')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/$", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/modules/es5", ["npm:core-js@1.2.3/modules/$", "npm:core-js@1.2.3/modules/$.support-desc", "npm:core-js@1.2.3/modules/$.property-desc", "npm:core-js@1.2.3/modules/$.html", "npm:core-js@1.2.3/modules/$.dom-create", "npm:core-js@1.2.3/modules/$.has", "npm:core-js@1.2.3/modules/$.cof", "npm:core-js@1.2.3/modules/$.def", "npm:core-js@1.2.3/modules/$.invoke", "npm:core-js@1.2.3/modules/$.array-methods", "npm:core-js@1.2.3/modules/$.uid", "npm:core-js@1.2.3/modules/$.is-object", "npm:core-js@1.2.3/modules/$.an-object", "npm:core-js@1.2.3/modules/$.a-function", "npm:core-js@1.2.3/modules/$.to-object", "npm:core-js@1.2.3/modules/$.to-iobject", "npm:core-js@1.2.3/modules/$.to-integer", "npm:core-js@1.2.3/modules/$.to-index", "npm:core-js@1.2.3/modules/$.to-length", "npm:core-js@1.2.3/modules/$.iobject", "npm:core-js@1.2.3/modules/$.fails", "npm:core-js@1.2.3/modules/$.array-includes", "npm:core-js@1.2.3/modules/$.is-array"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/modules/$'),
      SUPPORT_DESC = $__require('npm:core-js@1.2.3/modules/$.support-desc'),
      createDesc = $__require('npm:core-js@1.2.3/modules/$.property-desc'),
      html = $__require('npm:core-js@1.2.3/modules/$.html'),
      cel = $__require('npm:core-js@1.2.3/modules/$.dom-create'),
      has = $__require('npm:core-js@1.2.3/modules/$.has'),
      cof = $__require('npm:core-js@1.2.3/modules/$.cof'),
      $def = $__require('npm:core-js@1.2.3/modules/$.def'),
      invoke = $__require('npm:core-js@1.2.3/modules/$.invoke'),
      arrayMethod = $__require('npm:core-js@1.2.3/modules/$.array-methods'),
      IE_PROTO = $__require('npm:core-js@1.2.3/modules/$.uid')('__proto__'),
      isObject = $__require('npm:core-js@1.2.3/modules/$.is-object'),
      anObject = $__require('npm:core-js@1.2.3/modules/$.an-object'),
      aFunction = $__require('npm:core-js@1.2.3/modules/$.a-function'),
      toObject = $__require('npm:core-js@1.2.3/modules/$.to-object'),
      toIObject = $__require('npm:core-js@1.2.3/modules/$.to-iobject'),
      toInteger = $__require('npm:core-js@1.2.3/modules/$.to-integer'),
      toIndex = $__require('npm:core-js@1.2.3/modules/$.to-index'),
      toLength = $__require('npm:core-js@1.2.3/modules/$.to-length'),
      IObject = $__require('npm:core-js@1.2.3/modules/$.iobject'),
      fails = $__require('npm:core-js@1.2.3/modules/$.fails'),
      ObjectProto = Object.prototype,
      A = [],
      _slice = A.slice,
      _join = A.join,
      defineProperty = $.setDesc,
      getOwnDescriptor = $.getDesc,
      defineProperties = $.setDescs,
      $indexOf = $__require('npm:core-js@1.2.3/modules/$.array-includes')(false),
      factories = {},
      IE8_DOM_DEFINE;
  if (!SUPPORT_DESC) {
    IE8_DOM_DEFINE = !fails(function() {
      return defineProperty(cel('div'), 'a', {get: function() {
          return 7;
        }}).a != 7;
    });
    $.setDesc = function(O, P, Attributes) {
      if (IE8_DOM_DEFINE)
        try {
          return defineProperty(O, P, Attributes);
        } catch (e) {}
      if ('get' in Attributes || 'set' in Attributes)
        throw TypeError('Accessors not supported!');
      if ('value' in Attributes)
        anObject(O)[P] = Attributes.value;
      return O;
    };
    $.getDesc = function(O, P) {
      if (IE8_DOM_DEFINE)
        try {
          return getOwnDescriptor(O, P);
        } catch (e) {}
      if (has(O, P))
        return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
    };
    $.setDescs = defineProperties = function(O, Properties) {
      anObject(O);
      var keys = $.getKeys(Properties),
          length = keys.length,
          i = 0,
          P;
      while (length > i)
        $.setDesc(O, P = keys[i++], Properties[P]);
      return O;
    };
  }
  $def($def.S + $def.F * !SUPPORT_DESC, 'Object', {
    getOwnPropertyDescriptor: $.getDesc,
    defineProperty: $.setDesc,
    defineProperties: defineProperties
  });
  var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' + 'toLocaleString,toString,valueOf').split(','),
      keys2 = keys1.concat('length', 'prototype'),
      keysLen1 = keys1.length;
  var createDict = function() {
    var iframe = cel('iframe'),
        i = keysLen1,
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write('<script>document.F=Object</script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--)
      delete createDict.prototype[keys1[i]];
    return createDict();
  };
  var createGetKeys = function(names, length) {
    return function(object) {
      var O = toIObject(object),
          i = 0,
          result = [],
          key;
      for (key in O)
        if (key != IE_PROTO)
          has(O, key) && result.push(key);
      while (length > i)
        if (has(O, key = names[i++])) {
          ~$indexOf(result, key) || result.push(key);
        }
      return result;
    };
  };
  var Empty = function() {};
  $def($def.S, 'Object', {
    getPrototypeOf: $.getProto = $.getProto || function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO))
        return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    },
    getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
    create: $.create = $.create || function(O, Properties) {
      var result;
      if (O !== null) {
        Empty.prototype = anObject(O);
        result = new Empty();
        Empty.prototype = null;
        result[IE_PROTO] = O;
      } else
        result = createDict();
      return Properties === undefined ? result : defineProperties(result, Properties);
    },
    keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
  });
  var construct = function(F, len, args) {
    if (!(len in factories)) {
      for (var n = [],
          i = 0; i < len; i++)
        n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }
    return factories[len](F, args);
  };
  $def($def.P, 'Function', {bind: function bind(that) {
      var fn = aFunction(this),
          partArgs = _slice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(_slice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject(fn.prototype))
        bound.prototype = fn.prototype;
      return bound;
    }});
  var buggySlice = fails(function() {
    if (html)
      _slice.call(html);
  });
  $def($def.P + $def.F * buggySlice, 'Array', {slice: function(begin, end) {
      var len = toLength(this.length),
          klass = cof(this);
      end = end === undefined ? len : end;
      if (klass == 'Array')
        return _slice.call(this, begin, end);
      var start = toIndex(begin, len),
          upTo = toIndex(end, len),
          size = toLength(upTo - start),
          cloned = Array(size),
          i = 0;
      for (; i < size; i++)
        cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
      return cloned;
    }});
  $def($def.P + $def.F * (IObject != Object), 'Array', {join: function() {
      return _join.apply(IObject(this), arguments);
    }});
  $def($def.S, 'Array', {isArray: $__require('npm:core-js@1.2.3/modules/$.is-array')});
  var createArrayReduce = function(isRight) {
    return function(callbackfn, memo) {
      aFunction(callbackfn);
      var O = IObject(this),
          length = toLength(O.length),
          index = isRight ? length - 1 : 0,
          i = isRight ? -1 : 1;
      if (arguments.length < 2)
        for (; ; ) {
          if (index in O) {
            memo = O[index];
            index += i;
            break;
          }
          index += i;
          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }
      for (; isRight ? index >= 0 : length > index; index += i)
        if (index in O) {
          memo = callbackfn(memo, O[index], index, this);
        }
      return memo;
    };
  };
  var methodize = function($fn) {
    return function(arg1) {
      return $fn(this, arg1, arguments[1]);
    };
  };
  $def($def.P, 'Array', {
    forEach: $.each = $.each || methodize(arrayMethod(0)),
    map: methodize(arrayMethod(1)),
    filter: methodize(arrayMethod(2)),
    some: methodize(arrayMethod(3)),
    every: methodize(arrayMethod(4)),
    reduce: createArrayReduce(false),
    reduceRight: createArrayReduce(true),
    indexOf: methodize($indexOf),
    lastIndexOf: function(el, fromIndex) {
      var O = toIObject(this),
          length = toLength(O.length),
          index = length - 1;
      if (arguments.length > 1)
        index = Math.min(index, toInteger(fromIndex));
      if (index < 0)
        index = toLength(length + index);
      for (; index >= 0; index--)
        if (index in O)
          if (O[index] === el)
            return index;
      return -1;
    }
  });
  $def($def.S, 'Date', {now: function() {
      return +new Date;
    }});
  var lz = function(num) {
    return num > 9 ? num : '0' + num;
  };
  var date = new Date(-5e13 - 1),
      brokenDate = !(date.toISOString && date.toISOString() == '0385-07-25T07:06:39.999Z' && fails(function() {
        new Date(NaN).toISOString();
      }));
  $def($def.P + $def.F * brokenDate, 'Date', {toISOString: function toISOString() {
      if (!isFinite(this))
        throw RangeError('Invalid time value');
      var d = this,
          y = d.getUTCFullYear(),
          m = d.getUTCMilliseconds(),
          s = y < 0 ? '-' : y > 9999 ? '+' : '';
      return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
    }});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/shim", ["npm:core-js@1.2.3/modules/es5", "npm:core-js@1.2.3/modules/es6.symbol", "npm:core-js@1.2.3/modules/es6.object.assign", "npm:core-js@1.2.3/modules/es6.object.is", "npm:core-js@1.2.3/modules/es6.object.set-prototype-of", "npm:core-js@1.2.3/modules/es6.object.to-string", "npm:core-js@1.2.3/modules/es6.object.freeze", "npm:core-js@1.2.3/modules/es6.object.seal", "npm:core-js@1.2.3/modules/es6.object.prevent-extensions", "npm:core-js@1.2.3/modules/es6.object.is-frozen", "npm:core-js@1.2.3/modules/es6.object.is-sealed", "npm:core-js@1.2.3/modules/es6.object.is-extensible", "npm:core-js@1.2.3/modules/es6.object.get-own-property-descriptor", "npm:core-js@1.2.3/modules/es6.object.get-prototype-of", "npm:core-js@1.2.3/modules/es6.object.keys", "npm:core-js@1.2.3/modules/es6.object.get-own-property-names", "npm:core-js@1.2.3/modules/es6.function.name", "npm:core-js@1.2.3/modules/es6.function.has-instance", "npm:core-js@1.2.3/modules/es6.number.constructor", "npm:core-js@1.2.3/modules/es6.number.epsilon", "npm:core-js@1.2.3/modules/es6.number.is-finite", "npm:core-js@1.2.3/modules/es6.number.is-integer", "npm:core-js@1.2.3/modules/es6.number.is-nan", "npm:core-js@1.2.3/modules/es6.number.is-safe-integer", "npm:core-js@1.2.3/modules/es6.number.max-safe-integer", "npm:core-js@1.2.3/modules/es6.number.min-safe-integer", "npm:core-js@1.2.3/modules/es6.number.parse-float", "npm:core-js@1.2.3/modules/es6.number.parse-int", "npm:core-js@1.2.3/modules/es6.math.acosh", "npm:core-js@1.2.3/modules/es6.math.asinh", "npm:core-js@1.2.3/modules/es6.math.atanh", "npm:core-js@1.2.3/modules/es6.math.cbrt", "npm:core-js@1.2.3/modules/es6.math.clz32", "npm:core-js@1.2.3/modules/es6.math.cosh", "npm:core-js@1.2.3/modules/es6.math.expm1", "npm:core-js@1.2.3/modules/es6.math.fround", "npm:core-js@1.2.3/modules/es6.math.hypot", "npm:core-js@1.2.3/modules/es6.math.imul", "npm:core-js@1.2.3/modules/es6.math.log10", "npm:core-js@1.2.3/modules/es6.math.log1p", "npm:core-js@1.2.3/modules/es6.math.log2", "npm:core-js@1.2.3/modules/es6.math.sign", "npm:core-js@1.2.3/modules/es6.math.sinh", "npm:core-js@1.2.3/modules/es6.math.tanh", "npm:core-js@1.2.3/modules/es6.math.trunc", "npm:core-js@1.2.3/modules/es6.string.from-code-point", "npm:core-js@1.2.3/modules/es6.string.raw", "npm:core-js@1.2.3/modules/es6.string.trim", "npm:core-js@1.2.3/modules/es6.string.iterator", "npm:core-js@1.2.3/modules/es6.string.code-point-at", "npm:core-js@1.2.3/modules/es6.string.ends-with", "npm:core-js@1.2.3/modules/es6.string.includes", "npm:core-js@1.2.3/modules/es6.string.repeat", "npm:core-js@1.2.3/modules/es6.string.starts-with", "npm:core-js@1.2.3/modules/es6.array.from", "npm:core-js@1.2.3/modules/es6.array.of", "npm:core-js@1.2.3/modules/es6.array.iterator", "npm:core-js@1.2.3/modules/es6.array.species", "npm:core-js@1.2.3/modules/es6.array.copy-within", "npm:core-js@1.2.3/modules/es6.array.fill", "npm:core-js@1.2.3/modules/es6.array.find", "npm:core-js@1.2.3/modules/es6.array.find-index", "npm:core-js@1.2.3/modules/es6.regexp.constructor", "npm:core-js@1.2.3/modules/es6.regexp.flags", "npm:core-js@1.2.3/modules/es6.regexp.match", "npm:core-js@1.2.3/modules/es6.regexp.replace", "npm:core-js@1.2.3/modules/es6.regexp.search", "npm:core-js@1.2.3/modules/es6.regexp.split", "npm:core-js@1.2.3/modules/es6.promise", "npm:core-js@1.2.3/modules/es6.map", "npm:core-js@1.2.3/modules/es6.set", "npm:core-js@1.2.3/modules/es6.weak-map", "npm:core-js@1.2.3/modules/es6.weak-set", "npm:core-js@1.2.3/modules/es6.reflect.apply", "npm:core-js@1.2.3/modules/es6.reflect.construct", "npm:core-js@1.2.3/modules/es6.reflect.define-property", "npm:core-js@1.2.3/modules/es6.reflect.delete-property", "npm:core-js@1.2.3/modules/es6.reflect.enumerate", "npm:core-js@1.2.3/modules/es6.reflect.get", "npm:core-js@1.2.3/modules/es6.reflect.get-own-property-descriptor", "npm:core-js@1.2.3/modules/es6.reflect.get-prototype-of", "npm:core-js@1.2.3/modules/es6.reflect.has", "npm:core-js@1.2.3/modules/es6.reflect.is-extensible", "npm:core-js@1.2.3/modules/es6.reflect.own-keys", "npm:core-js@1.2.3/modules/es6.reflect.prevent-extensions", "npm:core-js@1.2.3/modules/es6.reflect.set", "npm:core-js@1.2.3/modules/es6.reflect.set-prototype-of", "npm:core-js@1.2.3/modules/es7.array.includes", "npm:core-js@1.2.3/modules/es7.string.at", "npm:core-js@1.2.3/modules/es7.string.pad-left", "npm:core-js@1.2.3/modules/es7.string.pad-right", "npm:core-js@1.2.3/modules/es7.string.trim-left", "npm:core-js@1.2.3/modules/es7.string.trim-right", "npm:core-js@1.2.3/modules/es7.regexp.escape", "npm:core-js@1.2.3/modules/es7.object.get-own-property-descriptors", "npm:core-js@1.2.3/modules/es7.object.values", "npm:core-js@1.2.3/modules/es7.object.entries", "npm:core-js@1.2.3/modules/es7.map.to-json", "npm:core-js@1.2.3/modules/es7.set.to-json", "npm:core-js@1.2.3/modules/js.array.statics", "npm:core-js@1.2.3/modules/web.timers", "npm:core-js@1.2.3/modules/web.immediate", "npm:core-js@1.2.3/modules/web.dom.iterable", "npm:core-js@1.2.3/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/modules/es5');
  $__require('npm:core-js@1.2.3/modules/es6.symbol');
  $__require('npm:core-js@1.2.3/modules/es6.object.assign');
  $__require('npm:core-js@1.2.3/modules/es6.object.is');
  $__require('npm:core-js@1.2.3/modules/es6.object.set-prototype-of');
  $__require('npm:core-js@1.2.3/modules/es6.object.to-string');
  $__require('npm:core-js@1.2.3/modules/es6.object.freeze');
  $__require('npm:core-js@1.2.3/modules/es6.object.seal');
  $__require('npm:core-js@1.2.3/modules/es6.object.prevent-extensions');
  $__require('npm:core-js@1.2.3/modules/es6.object.is-frozen');
  $__require('npm:core-js@1.2.3/modules/es6.object.is-sealed');
  $__require('npm:core-js@1.2.3/modules/es6.object.is-extensible');
  $__require('npm:core-js@1.2.3/modules/es6.object.get-own-property-descriptor');
  $__require('npm:core-js@1.2.3/modules/es6.object.get-prototype-of');
  $__require('npm:core-js@1.2.3/modules/es6.object.keys');
  $__require('npm:core-js@1.2.3/modules/es6.object.get-own-property-names');
  $__require('npm:core-js@1.2.3/modules/es6.function.name');
  $__require('npm:core-js@1.2.3/modules/es6.function.has-instance');
  $__require('npm:core-js@1.2.3/modules/es6.number.constructor');
  $__require('npm:core-js@1.2.3/modules/es6.number.epsilon');
  $__require('npm:core-js@1.2.3/modules/es6.number.is-finite');
  $__require('npm:core-js@1.2.3/modules/es6.number.is-integer');
  $__require('npm:core-js@1.2.3/modules/es6.number.is-nan');
  $__require('npm:core-js@1.2.3/modules/es6.number.is-safe-integer');
  $__require('npm:core-js@1.2.3/modules/es6.number.max-safe-integer');
  $__require('npm:core-js@1.2.3/modules/es6.number.min-safe-integer');
  $__require('npm:core-js@1.2.3/modules/es6.number.parse-float');
  $__require('npm:core-js@1.2.3/modules/es6.number.parse-int');
  $__require('npm:core-js@1.2.3/modules/es6.math.acosh');
  $__require('npm:core-js@1.2.3/modules/es6.math.asinh');
  $__require('npm:core-js@1.2.3/modules/es6.math.atanh');
  $__require('npm:core-js@1.2.3/modules/es6.math.cbrt');
  $__require('npm:core-js@1.2.3/modules/es6.math.clz32');
  $__require('npm:core-js@1.2.3/modules/es6.math.cosh');
  $__require('npm:core-js@1.2.3/modules/es6.math.expm1');
  $__require('npm:core-js@1.2.3/modules/es6.math.fround');
  $__require('npm:core-js@1.2.3/modules/es6.math.hypot');
  $__require('npm:core-js@1.2.3/modules/es6.math.imul');
  $__require('npm:core-js@1.2.3/modules/es6.math.log10');
  $__require('npm:core-js@1.2.3/modules/es6.math.log1p');
  $__require('npm:core-js@1.2.3/modules/es6.math.log2');
  $__require('npm:core-js@1.2.3/modules/es6.math.sign');
  $__require('npm:core-js@1.2.3/modules/es6.math.sinh');
  $__require('npm:core-js@1.2.3/modules/es6.math.tanh');
  $__require('npm:core-js@1.2.3/modules/es6.math.trunc');
  $__require('npm:core-js@1.2.3/modules/es6.string.from-code-point');
  $__require('npm:core-js@1.2.3/modules/es6.string.raw');
  $__require('npm:core-js@1.2.3/modules/es6.string.trim');
  $__require('npm:core-js@1.2.3/modules/es6.string.iterator');
  $__require('npm:core-js@1.2.3/modules/es6.string.code-point-at');
  $__require('npm:core-js@1.2.3/modules/es6.string.ends-with');
  $__require('npm:core-js@1.2.3/modules/es6.string.includes');
  $__require('npm:core-js@1.2.3/modules/es6.string.repeat');
  $__require('npm:core-js@1.2.3/modules/es6.string.starts-with');
  $__require('npm:core-js@1.2.3/modules/es6.array.from');
  $__require('npm:core-js@1.2.3/modules/es6.array.of');
  $__require('npm:core-js@1.2.3/modules/es6.array.iterator');
  $__require('npm:core-js@1.2.3/modules/es6.array.species');
  $__require('npm:core-js@1.2.3/modules/es6.array.copy-within');
  $__require('npm:core-js@1.2.3/modules/es6.array.fill');
  $__require('npm:core-js@1.2.3/modules/es6.array.find');
  $__require('npm:core-js@1.2.3/modules/es6.array.find-index');
  $__require('npm:core-js@1.2.3/modules/es6.regexp.constructor');
  $__require('npm:core-js@1.2.3/modules/es6.regexp.flags');
  $__require('npm:core-js@1.2.3/modules/es6.regexp.match');
  $__require('npm:core-js@1.2.3/modules/es6.regexp.replace');
  $__require('npm:core-js@1.2.3/modules/es6.regexp.search');
  $__require('npm:core-js@1.2.3/modules/es6.regexp.split');
  $__require('npm:core-js@1.2.3/modules/es6.promise');
  $__require('npm:core-js@1.2.3/modules/es6.map');
  $__require('npm:core-js@1.2.3/modules/es6.set');
  $__require('npm:core-js@1.2.3/modules/es6.weak-map');
  $__require('npm:core-js@1.2.3/modules/es6.weak-set');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.apply');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.construct');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.define-property');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.delete-property');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.enumerate');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.get');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.get-own-property-descriptor');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.get-prototype-of');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.has');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.is-extensible');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.own-keys');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.prevent-extensions');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.set');
  $__require('npm:core-js@1.2.3/modules/es6.reflect.set-prototype-of');
  $__require('npm:core-js@1.2.3/modules/es7.array.includes');
  $__require('npm:core-js@1.2.3/modules/es7.string.at');
  $__require('npm:core-js@1.2.3/modules/es7.string.pad-left');
  $__require('npm:core-js@1.2.3/modules/es7.string.pad-right');
  $__require('npm:core-js@1.2.3/modules/es7.string.trim-left');
  $__require('npm:core-js@1.2.3/modules/es7.string.trim-right');
  $__require('npm:core-js@1.2.3/modules/es7.regexp.escape');
  $__require('npm:core-js@1.2.3/modules/es7.object.get-own-property-descriptors');
  $__require('npm:core-js@1.2.3/modules/es7.object.values');
  $__require('npm:core-js@1.2.3/modules/es7.object.entries');
  $__require('npm:core-js@1.2.3/modules/es7.map.to-json');
  $__require('npm:core-js@1.2.3/modules/es7.set.to-json');
  $__require('npm:core-js@1.2.3/modules/js.array.statics');
  $__require('npm:core-js@1.2.3/modules/web.timers');
  $__require('npm:core-js@1.2.3/modules/web.immediate');
  $__require('npm:core-js@1.2.3/modules/web.dom.iterable');
  module.exports = $__require('npm:core-js@1.2.3/modules/$.core');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-core@5.8.25/lib/polyfill", ["npm:core-js@1.2.3/shim", "npm:babel-runtime@5.8.25/regenerator/runtime"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  $__require('npm:core-js@1.2.3/shim');
  $__require('npm:babel-runtime@5.8.25/regenerator/runtime');
  if (global._babelPolyfill) {
    throw new Error("only one instance of babel/polyfill is allowed");
  }
  global._babelPolyfill = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-core@5.8.25/polyfill", ["npm:babel-core@5.8.25/lib/polyfill"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  module.exports = $__require('npm:babel-core@5.8.25/lib/polyfill');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-router@0.2.15/release/angular-ui-router", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          var param = this.params[paramName];
          var paramVal = m[i + 1];
          for (j = 0; j < param.replace; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              bool: {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            return config.type instanceof Type ? config.type : new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = extend({}, state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "'' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if (hash)
                toParams['#'] = hash;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              if (result && options.notify) {
                $rootScope.$broadcast('$viewContentLoading', options);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = function() {
            return {
              enter: function(element, target, cb) {
                target.after(element);
                cb();
              },
              leave: function(element, cb) {
                element.remove();
                cb();
              }
            };
          };
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                var promise = $animate.enter(element, null, target, cb);
                if (promise && promise.then)
                  promise.then(cb);
              },
              leave: function(element, cb) {
                var promise = $animate.leave(element, cb);
                if (promise && promise.then)
                  promise.then(cb);
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics();
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                if (previousEl) {
                  previousEl.remove();
                  previousEl = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    previousEl = null;
                  });
                  previousEl = currentEl;
                  currentEl = null;
                }
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var params = null,
                url = null,
                base = stateContext(element) || $state.$current;
            var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
            var newHref = null,
                isAnchor = element.prop("tagName").toUpperCase() === "A";
            var isForm = element[0].nodeName === "FORM";
            var attr = isForm ? "action" : hrefKind,
                nav = true;
            var options = {
              relative: base,
              inherit: true
            };
            var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
            angular.forEach(allowedOptions, function(option) {
              if (option in optionsOverride) {
                options[option] = optionsOverride[option];
              }
            });
            var update = function(newVal) {
              if (newVal)
                params = angular.copy(newVal);
              if (!nav)
                return;
              newHref = $state.href(ref.state, params, options);
              var activeDirective = uiSrefActive[1] || uiSrefActive[0];
              if (activeDirective) {
                activeDirective.$$addStateInfo(ref.state, params);
              }
              if (newHref === null) {
                nav = false;
                return false;
              }
              attrs.$set(attr, newHref);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                if (newVal !== params)
                  update(newVal);
              }, true);
              params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (isForm)
              return;
            element.bind("click", function(e) {
              var button = e.which || e.button;
              if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                var transition = $timeout(function() {
                  $state.go(ref.state, params, options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                e.preventDefault = function() {
                  if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
                };
              }
            });
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var states = [],
                activeClass;
            activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
            this.$$addStateInfo = function(newState, newParams) {
              var state = $state.get(newState, stateContext($element));
              states.push({
                state: state || {name: newState},
                params: newParams
              });
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function update() {
              if (anyMatch()) {
                $element.addClass(activeClass);
              } else {
                $element.removeClass(activeClass);
              }
            }
            function anyMatch() {
              for (var i = 0; i < states.length; i++) {
                if (isMatch(states[i].state, states[i].params)) {
                  return true;
                }
              }
              return false;
            }
            function isMatch(state, params) {
              if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                return $state.is(state.name, params);
              } else {
                return $state.includes(state.name, params);
              }
            }
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state) {
          return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
          return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-router@0.2.15", ["npm:angular-ui-router@0.2.15/release/angular-ui-router"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-ui-router@0.2.15/release/angular-ui-router');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ng-sortable@1.3.1/dist/ng-sortable", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    'use strict';
    angular.module('as.sortable', []).constant('sortableConfig', {
      itemClass: 'as-sortable-item',
      handleClass: 'as-sortable-item-handle',
      placeHolderClass: 'as-sortable-placeholder',
      dragClass: 'as-sortable-drag',
      hiddenClass: 'as-sortable-hidden',
      dragging: 'as-sortable-dragging'
    });
  }());
  (function() {
    'use strict';
    var mainModule = angular.module('as.sortable');
    mainModule.factory('$helper', ['$document', '$window', function($document, $window) {
      return {
        height: function(element) {
          return element[0].getBoundingClientRect().height;
        },
        width: function(element) {
          return element[0].getBoundingClientRect().width;
        },
        offset: function(element, scrollableContainer) {
          var boundingClientRect = element[0].getBoundingClientRect();
          if (!scrollableContainer) {
            scrollableContainer = $document[0].documentElement;
          }
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || scrollableContainer.scrollTop - scrollableContainer.offsetTop),
            left: boundingClientRect.left + ($window.pageXOffset || scrollableContainer.scrollLeft - scrollableContainer.offsetLeft)
          };
        },
        eventObj: function(event) {
          var obj = event;
          if (event.targetTouches !== undefined) {
            obj = event.targetTouches.item(0);
          } else if (event.originalEvent !== undefined && event.originalEvent.targetTouches !== undefined) {
            obj = event.originalEvent.targetTouches.item(0);
          }
          return obj;
        },
        isTouchInvalid: function(event) {
          var touchInvalid = false;
          if (event.touches !== undefined && event.touches.length > 1) {
            touchInvalid = true;
          } else if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined && event.originalEvent.touches.length > 1) {
            touchInvalid = true;
          }
          return touchInvalid;
        },
        positionStarted: function(event, target, scrollableContainer) {
          var pos = {};
          pos.offsetX = event.pageX - this.offset(target, scrollableContainer).left;
          pos.offsetY = event.pageY - this.offset(target, scrollableContainer).top;
          pos.startX = pos.lastX = event.pageX;
          pos.startY = pos.lastY = event.pageY;
          pos.nowX = pos.nowY = pos.distX = pos.distY = pos.dirAx = 0;
          pos.dirX = pos.dirY = pos.lastDirX = pos.lastDirY = pos.distAxX = pos.distAxY = 0;
          return pos;
        },
        calculatePosition: function(pos, event) {
          pos.lastX = pos.nowX;
          pos.lastY = pos.nowY;
          pos.nowX = event.pageX;
          pos.nowY = event.pageY;
          pos.distX = pos.nowX - pos.lastX;
          pos.distY = pos.nowY - pos.lastY;
          pos.lastDirX = pos.dirX;
          pos.lastDirY = pos.dirY;
          pos.dirX = pos.distX === 0 ? 0 : pos.distX > 0 ? 1 : -1;
          pos.dirY = pos.distY === 0 ? 0 : pos.distY > 0 ? 1 : -1;
          var newAx = Math.abs(pos.distX) > Math.abs(pos.distY) ? 1 : 0;
          if (pos.dirAx !== newAx) {
            pos.distAxX = 0;
            pos.distAxY = 0;
          } else {
            pos.distAxX += Math.abs(pos.distX);
            if (pos.dirX !== 0 && pos.dirX !== pos.lastDirX) {
              pos.distAxX = 0;
            }
            pos.distAxY += Math.abs(pos.distY);
            if (pos.dirY !== 0 && pos.dirY !== pos.lastDirY) {
              pos.distAxY = 0;
            }
          }
          pos.dirAx = newAx;
        },
        movePosition: function(event, element, pos, container, containerPositioning, scrollableContainer) {
          var bounds;
          var useRelative = (containerPositioning === 'relative');
          element.x = event.pageX - pos.offsetX;
          element.y = event.pageY - pos.offsetY;
          if (container) {
            bounds = this.offset(container, scrollableContainer);
            if (useRelative) {
              element.x -= bounds.left;
              element.y -= bounds.top;
              bounds.left = 0;
              bounds.top = 0;
            }
            if (element.x < bounds.left) {
              element.x = bounds.left;
            } else if (element.x >= bounds.width + bounds.left - this.offset(element).width) {
              element.x = bounds.width + bounds.left - this.offset(element).width;
            }
            if (element.y < bounds.top) {
              element.y = bounds.top;
            } else if (element.y >= bounds.height + bounds.top - this.offset(element).height) {
              element.y = bounds.height + bounds.top - this.offset(element).height;
            }
          }
          element.css({
            'left': element.x + 'px',
            'top': element.y + 'px'
          });
          this.calculatePosition(pos, event);
        },
        dragItem: function(item) {
          return {
            index: item.index(),
            parent: item.sortableScope,
            source: item,
            sourceInfo: {
              index: item.index(),
              itemScope: item.itemScope,
              sortableScope: item.sortableScope
            },
            moveTo: function(parent, index) {
              this.parent = parent;
              if (this.isSameParent() && this.source.index() < index) {
                index = index - 1;
              }
              this.index = index;
            },
            isSameParent: function() {
              return this.parent.element === this.sourceInfo.sortableScope.element;
            },
            isOrderChanged: function() {
              return this.index !== this.sourceInfo.index;
            },
            eventArgs: function() {
              return {
                source: this.sourceInfo,
                dest: {
                  index: this.index,
                  sortableScope: this.parent
                }
              };
            },
            apply: function() {
              if (typeof(this.sourceInfo.sortableScope.options.clone) === 'undefined') {
                this.sourceInfo.sortableScope.options.clone = false;
              }
              if (this.sourceInfo.sortableScope.options.clone === false) {
                this.sourceInfo.sortableScope.removeItem(this.sourceInfo.index);
              }
              if (this.parent.modelValue.indexOf(this.source.modelValue) < 0) {
                this.parent.insertItem(this.index, this.source.modelValue);
              }
            }
          };
        },
        noDrag: function(element) {
          return element.attr('no-drag') !== undefined || element.attr('data-no-drag') !== undefined;
        },
        findAncestor: function(el, selector) {
          el = el[0];
          var matches = Element.matches || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector;
          while ((el = el.parentElement) && !matches.call(el, selector)) {}
          return el ? angular.element(el) : angular.element(document.body);
        }
      };
    }]);
  }());
  (function() {
    'use strict';
    var mainModule = angular.module('as.sortable');
    mainModule.controller('as.sortable.sortableController', ['$scope', function($scope) {
      this.scope = $scope;
      $scope.modelValue = null;
      $scope.callbacks = null;
      $scope.type = 'sortable';
      $scope.options = {};
      $scope.isDisabled = false;
      $scope.insertItem = function(index, itemData) {
        $scope.modelValue.splice(index, 0, itemData);
      };
      $scope.removeItem = function(index) {
        var removedItem = null;
        if (index > -1) {
          removedItem = $scope.modelValue.splice(index, 1)[0];
        }
        return removedItem;
      };
      $scope.isEmpty = function() {
        return ($scope.modelValue && $scope.modelValue.length === 0);
      };
      $scope.accept = function(sourceItemHandleScope, destScope, destItemScope) {
        return $scope.callbacks.accept(sourceItemHandleScope, destScope, destItemScope);
      };
    }]);
    mainModule.directive('asSortable', function() {
      return {
        require: 'ngModel',
        restrict: 'A',
        scope: true,
        controller: 'as.sortable.sortableController',
        link: function(scope, element, attrs, ngModelController) {
          var ngModel,
              callbacks;
          ngModel = ngModelController;
          if (!ngModel) {
            return;
          }
          ngModel.$render = function() {
            scope.modelValue = ngModel.$modelValue;
          };
          scope.element = element;
          element.data('_scope', scope);
          callbacks = {
            accept: null,
            orderChanged: null,
            itemMoved: null,
            dragStart: null,
            dragMove: null,
            dragCancel: null,
            dragEnd: null
          };
          callbacks.accept = function(sourceItemHandleScope, destSortableScope, destItemScope) {
            return true;
          };
          callbacks.orderChanged = function(event) {};
          callbacks.itemMoved = function(event) {};
          callbacks.dragStart = function(event) {};
          callbacks.dragMove = function(itemPosition, containment, eventObj) {};
          callbacks.dragCancel = function(event) {};
          callbacks.dragEnd = function(event) {};
          scope.$watch(attrs.asSortable, function(newVal, oldVal) {
            angular.forEach(newVal, function(value, key) {
              if (callbacks[key]) {
                if (typeof value === 'function') {
                  callbacks[key] = value;
                }
              } else {
                scope.options[key] = value;
              }
            });
            scope.callbacks = callbacks;
          }, true);
          if (angular.isDefined(attrs.isDisabled)) {
            scope.$watch(attrs.isDisabled, function(newVal, oldVal) {
              if (!angular.isUndefined(newVal)) {
                scope.isDisabled = newVal;
              }
            }, true);
          }
        }
      };
    });
  }());
  (function() {
    'use strict';
    var mainModule = angular.module('as.sortable');
    mainModule.controller('as.sortable.sortableItemHandleController', ['$scope', function($scope) {
      this.scope = $scope;
      $scope.itemScope = null;
      $scope.type = 'handle';
    }]);
    mainModule.directive('asSortableItemHandle', ['sortableConfig', '$helper', '$window', '$document', function(sortableConfig, $helper, $window, $document) {
      return {
        require: '^asSortableItem',
        scope: true,
        restrict: 'A',
        controller: 'as.sortable.sortableItemHandleController',
        link: function(scope, element, attrs, itemController) {
          var dragElement,
              placeHolder,
              placeElement,
              itemPosition,
              dragItemInfo,
              containment,
              containerPositioning,
              dragListen,
              scrollableContainer,
              dragStart,
              dragMove,
              dragEnd,
              dragCancel,
              isDraggable,
              placeHolderIndex,
              bindDrag,
              unbindDrag,
              bindEvents,
              unBindEvents,
              hasTouch,
              dragHandled,
              createPlaceholder,
              isPlaceHolderPresent,
              isDisabled = false,
              escapeListen;
          hasTouch = $window.hasOwnProperty('ontouchstart');
          if (sortableConfig.handleClass) {
            element.addClass(sortableConfig.handleClass);
          }
          scope.itemScope = itemController.scope;
          element.data('_scope', scope);
          scope.$watch('sortableScope.isDisabled', function(newVal) {
            if (isDisabled !== newVal) {
              isDisabled = newVal;
              if (isDisabled) {
                unbindDrag();
              } else {
                bindDrag();
              }
            }
          });
          scope.$on('$destroy', function() {
            angular.element($document[0].body).unbind('keydown', escapeListen);
          });
          createPlaceholder = function(itemScope) {
            if (typeof scope.sortableScope.options.placeholder === 'function') {
              return angular.element(scope.sortableScope.options.placeholder(itemScope));
            } else if (typeof scope.sortableScope.options.placeholder === 'string') {
              return angular.element(scope.sortableScope.options.placeholder);
            } else {
              return angular.element($document[0].createElement(itemScope.element.prop('tagName')));
            }
          };
          dragListen = function(event) {
            var unbindMoveListen = function() {
              angular.element($document).unbind('mousemove', moveListen);
              angular.element($document).unbind('touchmove', moveListen);
              element.unbind('mouseup', unbindMoveListen);
              element.unbind('touchend', unbindMoveListen);
              element.unbind('touchcancel', unbindMoveListen);
            };
            var startPosition;
            var moveListen = function(e) {
              e.preventDefault();
              var eventObj = $helper.eventObj(e);
              if (!startPosition) {
                startPosition = {
                  clientX: eventObj.clientX,
                  clientY: eventObj.clientY
                };
              }
              if (Math.abs(eventObj.clientX - startPosition.clientX) + Math.abs(eventObj.clientY - startPosition.clientY) > 10) {
                unbindMoveListen();
                dragStart(event);
              }
            };
            angular.element($document).bind('mousemove', moveListen);
            angular.element($document).bind('touchmove', moveListen);
            element.bind('mouseup', unbindMoveListen);
            element.bind('touchend', unbindMoveListen);
            element.bind('touchcancel', unbindMoveListen);
          };
          dragStart = function(event) {
            var eventObj,
                tagName;
            if (!hasTouch && (event.button === 2 || event.which === 3)) {
              return;
            }
            if (hasTouch && $helper.isTouchInvalid(event)) {
              return;
            }
            if (dragHandled || !isDraggable(event)) {
              return;
            }
            dragHandled = true;
            event.preventDefault();
            eventObj = $helper.eventObj(event);
            scrollableContainer = angular.element($document[0].querySelector(scope.sortableScope.options.scrollableContainer)).length > 0 ? $document[0].querySelector(scope.sortableScope.options.scrollableContainer) : $document[0].documentElement;
            containment = (scope.sortableScope.options.containment) ? $helper.findAncestor(element, scope.sortableScope.options.containment) : angular.element($document[0].body);
            containment.css('cursor', 'move');
            containment.css('cursor', '-webkit-grabbing');
            containment.css('cursor', '-moz-grabbing');
            containment.addClass('as-sortable-un-selectable');
            containerPositioning = scope.sortableScope.options.containerPositioning || 'absolute';
            dragItemInfo = $helper.dragItem(scope);
            tagName = scope.itemScope.element.prop('tagName');
            dragElement = angular.element($document[0].createElement(scope.sortableScope.element.prop('tagName'))).addClass(scope.sortableScope.element.attr('class')).addClass(sortableConfig.dragClass);
            dragElement.css('width', $helper.width(scope.itemScope.element) + 'px');
            dragElement.css('height', $helper.height(scope.itemScope.element) + 'px');
            placeHolder = createPlaceholder(scope.itemScope).addClass(sortableConfig.placeHolderClass).addClass(scope.sortableScope.options.additionalPlaceholderClass);
            placeHolder.css('width', $helper.width(scope.itemScope.element) + 'px');
            placeHolder.css('height', $helper.height(scope.itemScope.element) + 'px');
            if (scope.itemScope.sortableScope.options.clone) {
              placeHolder.css('display', 'none');
            }
            placeElement = angular.element($document[0].createElement(tagName));
            if (sortableConfig.hiddenClass) {
              placeElement.addClass(sortableConfig.hiddenClass);
            }
            itemPosition = $helper.positionStarted(eventObj, scope.itemScope.element, scrollableContainer);
            scope.itemScope.element.after(placeHolder);
            scope.itemScope.element.after(placeElement);
            if (scope.itemScope.sortableScope.options.clone) {
              dragElement.append(scope.itemScope.element.clone());
            } else {
              dragElement.append(scope.itemScope.element);
            }
            containment.append(dragElement);
            $helper.movePosition(eventObj, dragElement, itemPosition, containment, containerPositioning, scrollableContainer);
            scope.sortableScope.$apply(function() {
              scope.callbacks.dragStart(dragItemInfo.eventArgs());
            });
            bindEvents();
          };
          isDraggable = function(event) {
            var elementClicked,
                sourceScope,
                isDraggable;
            elementClicked = angular.element(event.target);
            sourceScope = fetchScope(elementClicked);
            isDraggable = (sourceScope && sourceScope.type === 'handle');
            while (isDraggable && elementClicked[0] !== element[0]) {
              if ($helper.noDrag(elementClicked)) {
                isDraggable = false;
              }
              elementClicked = elementClicked.parent();
            }
            return isDraggable;
          };
          function insertBefore(targetElement, targetScope) {
            placeHolder.css('display', 'block');
            targetElement[0].parentNode.insertBefore(placeHolder[0], targetElement[0]);
            dragItemInfo.moveTo(targetScope.sortableScope, targetScope.index());
          }
          function insertAfter(targetElement, targetScope) {
            placeHolder.css('display', 'block');
            targetElement.after(placeHolder);
            dragItemInfo.moveTo(targetScope.sortableScope, targetScope.index() + 1);
          }
          dragMove = function(event) {
            var eventObj,
                targetX,
                targetY,
                targetScope,
                targetElement;
            if (hasTouch && $helper.isTouchInvalid(event)) {
              return;
            }
            if (!dragHandled) {
              return;
            }
            if (dragElement) {
              event.preventDefault();
              eventObj = $helper.eventObj(event);
              scope.sortableScope.$apply(function() {
                scope.callbacks.dragMove(itemPosition, containment, eventObj);
              });
              $helper.movePosition(eventObj, dragElement, itemPosition, containment, containerPositioning, scrollableContainer);
              targetX = eventObj.pageX - $document[0].documentElement.scrollLeft;
              targetY = eventObj.pageY - ($window.pageYOffset || $document[0].documentElement.scrollTop);
              dragElement.addClass(sortableConfig.hiddenClass);
              $document[0].elementFromPoint(targetX, targetY);
              targetElement = angular.element($document[0].elementFromPoint(targetX, targetY));
              dragElement.removeClass(sortableConfig.hiddenClass);
              dragElement.addClass(sortableConfig.dragging);
              targetScope = fetchScope(targetElement);
              if (!targetScope || !targetScope.type) {
                return;
              }
              if (targetScope.type === 'handle') {
                targetScope = targetScope.itemScope;
              }
              if (targetScope.type !== 'item' && targetScope.type !== 'sortable') {
                return;
              }
              if (targetScope.type === 'item' && targetScope.accept(scope, targetScope.sortableScope, targetScope)) {
                targetElement = targetScope.element;
                var placeholderIndex = placeHolderIndex(targetScope.sortableScope.element);
                if (placeholderIndex < 0) {
                  insertBefore(targetElement, targetScope);
                } else {
                  if (placeholderIndex <= targetScope.index()) {
                    insertAfter(targetElement, targetScope);
                  } else {
                    insertBefore(targetElement, targetScope);
                  }
                }
              }
              if (targetScope.type === 'sortable') {
                if (targetScope.accept(scope, targetScope) && targetElement[0].parentNode !== targetScope.element[0]) {
                  if (!isPlaceHolderPresent(targetElement)) {
                    targetElement[0].appendChild(placeHolder[0]);
                    dragItemInfo.moveTo(targetScope, targetScope.modelValue.length);
                  }
                }
              }
            }
          };
          function fetchScope(element) {
            var scope;
            while (!scope && element.length) {
              scope = element.data('_scope');
              if (!scope) {
                element = element.parent();
              }
            }
            return scope;
          }
          placeHolderIndex = function(targetElement) {
            var itemElements,
                i;
            if (targetElement.hasClass(sortableConfig.placeHolderClass)) {
              return 0;
            }
            itemElements = targetElement.children();
            for (i = 0; i < itemElements.length; i += 1) {
              if (angular.element(itemElements[i]).hasClass(sortableConfig.placeHolderClass)) {
                return i;
              }
            }
            return -1;
          };
          isPlaceHolderPresent = function(targetElement) {
            return placeHolderIndex(targetElement) >= 0;
          };
          function rollbackDragChanges() {
            placeElement.replaceWith(scope.itemScope.element);
            placeHolder.remove();
            dragElement.remove();
            dragElement = null;
            dragHandled = false;
            containment.css('cursor', '');
            containment.removeClass('as-sortable-un-selectable');
          }
          dragEnd = function(event) {
            if (!dragHandled) {
              return;
            }
            event.preventDefault();
            if (dragElement) {
              rollbackDragChanges();
              dragItemInfo.apply();
              scope.sortableScope.$apply(function() {
                if (dragItemInfo.isSameParent()) {
                  if (dragItemInfo.isOrderChanged()) {
                    scope.callbacks.orderChanged(dragItemInfo.eventArgs());
                  }
                } else {
                  scope.callbacks.itemMoved(dragItemInfo.eventArgs());
                }
              });
              scope.sortableScope.$apply(function() {
                scope.callbacks.dragEnd(dragItemInfo.eventArgs());
              });
              dragItemInfo = null;
            }
            unBindEvents();
          };
          dragCancel = function(event) {
            if (!dragHandled) {
              return;
            }
            event.preventDefault();
            if (dragElement) {
              rollbackDragChanges();
              scope.sortableScope.$apply(function() {
                scope.callbacks.dragCancel(dragItemInfo.eventArgs());
              });
              dragItemInfo = null;
            }
            unBindEvents();
          };
          bindDrag = function() {
            element.bind('touchstart', dragListen);
            element.bind('mousedown', dragListen);
          };
          unbindDrag = function() {
            element.unbind('touchstart', dragListen);
            element.unbind('mousedown', dragListen);
          };
          bindDrag();
          escapeListen = function(event) {
            if (event.keyCode === 27) {
              dragCancel(event);
            }
          };
          angular.element($document[0].body).bind('keydown', escapeListen);
          bindEvents = function() {
            angular.element($document).bind('touchmove', dragMove);
            angular.element($document).bind('touchend', dragEnd);
            angular.element($document).bind('touchcancel', dragCancel);
            angular.element($document).bind('mousemove', dragMove);
            angular.element($document).bind('mouseup', dragEnd);
          };
          unBindEvents = function() {
            angular.element($document).unbind('touchend', dragEnd);
            angular.element($document).unbind('touchcancel', dragCancel);
            angular.element($document).unbind('touchmove', dragMove);
            angular.element($document).unbind('mouseup', dragEnd);
            angular.element($document).unbind('mousemove', dragMove);
          };
        }
      };
    }]);
  }());
  (function() {
    'use strict';
    var mainModule = angular.module('as.sortable');
    mainModule.controller('as.sortable.sortableItemController', ['$scope', function($scope) {
      this.scope = $scope;
      $scope.sortableScope = null;
      $scope.modelValue = null;
      $scope.type = 'item';
      $scope.index = function() {
        return $scope.$index;
      };
      $scope.itemData = function() {
        return $scope.sortableScope.modelValue[$scope.$index];
      };
    }]);
    mainModule.directive('asSortableItem', ['sortableConfig', function(sortableConfig) {
      return {
        require: ['^asSortable', '?ngModel'],
        restrict: 'A',
        controller: 'as.sortable.sortableItemController',
        link: function(scope, element, attrs, ctrl) {
          var sortableController = ctrl[0];
          var ngModelController = ctrl[1];
          if (sortableConfig.itemClass) {
            element.addClass(sortableConfig.itemClass);
          }
          scope.sortableScope = sortableController.scope;
          if (ngModelController) {
            ngModelController.$render = function() {
              scope.modelValue = ngModelController.$modelValue;
            };
          } else {
            scope.modelValue = sortableController.scope.modelValue[scope.$index];
          }
          scope.element = element;
          element.data('_scope', scope);
        }
      };
    }]);
  }());
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ng-sortable@1.3.1/index", ["npm:ng-sortable@1.3.1/dist/ng-sortable"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:ng-sortable@1.3.1/dist/ng-sortable');
  module.exports = 'as.sortable';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ng-sortable@1.3.1", ["npm:ng-sortable@1.3.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:ng-sortable@1.3.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.4.7/angular-sanitize", ["github:angular/bower-angular@1.4.7"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
          END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
          ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
          BEGIN_TAG_REGEXP = /^</,
          BEGING_END_TAGE_REGEXP = /^<\//,
          COMMENT_REGEXP = /<!--(.*?)-->/g,
          DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
          CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
          SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
      var voidElements = makeMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = makeMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
      var specialElements = makeMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
      var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
      var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function makeMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      function htmlParser(html, handler) {
        if (typeof html !== 'string') {
          if (html === null || typeof html === 'undefined') {
            html = '';
          } else {
            html = '' + html;
          }
        }
        var index,
            chars,
            match,
            stack = [],
            last = html,
            text;
        stack.last = function() {
          return stack[stack.length - 1];
        };
        while (html) {
          text = '';
          chars = true;
          if (!stack.last() || !specialElements[stack.last()]) {
            if (html.indexOf("<!--") === 0) {
              index = html.indexOf("--", 4);
              if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                if (handler.comment)
                  handler.comment(html.substring(4, index));
                html = html.substring(index + 3);
                chars = false;
              }
            } else if (DOCTYPE_REGEXP.test(html)) {
              match = html.match(DOCTYPE_REGEXP);
              if (match) {
                html = html.replace(match[0], '');
                chars = false;
              }
            } else if (BEGING_END_TAGE_REGEXP.test(html)) {
              match = html.match(END_TAG_REGEXP);
              if (match) {
                html = html.substring(match[0].length);
                match[0].replace(END_TAG_REGEXP, parseEndTag);
                chars = false;
              }
            } else if (BEGIN_TAG_REGEXP.test(html)) {
              match = html.match(START_TAG_REGEXP);
              if (match) {
                if (match[4]) {
                  html = html.substring(match[0].length);
                  match[0].replace(START_TAG_REGEXP, parseStartTag);
                }
                chars = false;
              } else {
                text += '<';
                html = html.substring(1);
              }
            }
            if (chars) {
              index = html.indexOf("<");
              text += index < 0 ? html : html.substring(0, index);
              html = index < 0 ? "" : html.substring(index);
              if (handler.chars)
                handler.chars(decodeEntities(text));
            }
          } else {
            html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
              text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
              if (handler.chars)
                handler.chars(decodeEntities(text));
              return "";
            });
            parseEndTag("", stack.last());
          }
          if (html == last) {
            throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
          }
          last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
          tagName = angular.lowercase(tagName);
          if (blockElements[tagName]) {
            while (stack.last() && inlineElements[stack.last()]) {
              parseEndTag("", stack.last());
            }
          }
          if (optionalEndTagElements[tagName] && stack.last() == tagName) {
            parseEndTag("", tagName);
          }
          unary = voidElements[tagName] || !!unary;
          if (!unary) {
            stack.push(tagName);
          }
          var attrs = {};
          rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
            var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
            attrs[name] = decodeEntities(value);
          });
          if (handler.start)
            handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
          var pos = 0,
              i;
          tagName = angular.lowercase(tagName);
          if (tagName) {
            for (pos = stack.length - 1; pos >= 0; pos--) {
              if (stack[pos] == tagName)
                break;
            }
          }
          if (pos >= 0) {
            for (i = stack.length - 1; i >= pos; i--)
              if (handler.end)
                handler.end(stack[i]);
            stack.length = pos;
          }
        }
      }
      var hiddenPre = document.createElement("pre");
      function decodeEntities(value) {
        if (!value) {
          return '';
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs, unary) {
            tag = angular.lowercase(tag);
            if (!ignore && specialElements[tag]) {
              ignore = tag;
            }
            if (!ignore && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out(unary ? '/>' : '>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignore && validElements[tag] === true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignore) {
              ignore = false;
            }
          },
          chars: function(chars) {
            if (!ignore) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
          if (!text)
            return text;
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            html.push('<a ');
            if (angular.isDefined(target)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.4.7", ["github:angular/bower-angular-sanitize@1.4.7/angular-sanitize"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-sanitize@1.4.7/angular-sanitize');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-mocks@1.4.7/angular-mocks", ["github:angular/bower-angular@1.4.7"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      angular.mock = {};
      angular.mock.$BrowserProvider = function() {
        this.$get = function() {
          return new angular.mock.$Browser();
        };
      };
      angular.mock.$Browser = function() {
        var self = this;
        this.isMock = true;
        self.$$url = "http://server/";
        self.$$lastUrl = self.$$url;
        self.pollFns = [];
        self.$$completeOutstandingRequest = angular.noop;
        self.$$incOutstandingRequestCount = angular.noop;
        self.onUrlChange = function(listener) {
          self.pollFns.push(function() {
            if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
              self.$$lastUrl = self.$$url;
              self.$$lastState = self.$$state;
              listener(self.$$url, self.$$state);
            }
          });
          return listener;
        };
        self.$$applicationDestroyed = angular.noop;
        self.$$checkUrlChange = angular.noop;
        self.deferredFns = [];
        self.deferredNextId = 0;
        self.defer = function(fn, delay) {
          delay = delay || 0;
          self.deferredFns.push({
            time: (self.defer.now + delay),
            fn: fn,
            id: self.deferredNextId
          });
          self.deferredFns.sort(function(a, b) {
            return a.time - b.time;
          });
          return self.deferredNextId++;
        };
        self.defer.now = 0;
        self.defer.cancel = function(deferId) {
          var fnIndex;
          angular.forEach(self.deferredFns, function(fn, index) {
            if (fn.id === deferId)
              fnIndex = index;
          });
          if (angular.isDefined(fnIndex)) {
            self.deferredFns.splice(fnIndex, 1);
            return true;
          }
          return false;
        };
        self.defer.flush = function(delay) {
          if (angular.isDefined(delay)) {
            self.defer.now += delay;
          } else {
            if (self.deferredFns.length) {
              self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
            } else {
              throw new Error('No deferred tasks to be flushed');
            }
          }
          while (self.deferredFns.length && self.deferredFns[0].time <= self.defer.now) {
            self.deferredFns.shift().fn();
          }
        };
        self.$$baseHref = '/';
        self.baseHref = function() {
          return this.$$baseHref;
        };
      };
      angular.mock.$Browser.prototype = {
        poll: function poll() {
          angular.forEach(this.pollFns, function(pollFn) {
            pollFn();
          });
        },
        url: function(url, replace, state) {
          if (angular.isUndefined(state)) {
            state = null;
          }
          if (url) {
            this.$$url = url;
            this.$$state = angular.copy(state);
            return this;
          }
          return this.$$url;
        },
        state: function() {
          return this.$$state;
        },
        notifyWhenNoOutstandingRequests: function(fn) {
          fn();
        }
      };
      angular.mock.$ExceptionHandlerProvider = function() {
        var handler;
        this.mode = function(mode) {
          switch (mode) {
            case 'log':
            case 'rethrow':
              var errors = [];
              handler = function(e) {
                if (arguments.length == 1) {
                  errors.push(e);
                } else {
                  errors.push([].slice.call(arguments, 0));
                }
                if (mode === "rethrow") {
                  throw e;
                }
              };
              handler.errors = errors;
              break;
            default:
              throw new Error("Unknown mode '" + mode + "', only 'log'/'rethrow' modes are allowed!");
          }
        };
        this.$get = function() {
          return handler;
        };
        this.mode('rethrow');
      };
      angular.mock.$LogProvider = function() {
        var debug = true;
        function concat(array1, array2, index) {
          return array1.concat(Array.prototype.slice.call(array2, index));
        }
        this.debugEnabled = function(flag) {
          if (angular.isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = function() {
          var $log = {
            log: function() {
              $log.log.logs.push(concat([], arguments, 0));
            },
            warn: function() {
              $log.warn.logs.push(concat([], arguments, 0));
            },
            info: function() {
              $log.info.logs.push(concat([], arguments, 0));
            },
            error: function() {
              $log.error.logs.push(concat([], arguments, 0));
            },
            debug: function() {
              if (debug) {
                $log.debug.logs.push(concat([], arguments, 0));
              }
            }
          };
          $log.reset = function() {
            $log.log.logs = [];
            $log.info.logs = [];
            $log.warn.logs = [];
            $log.error.logs = [];
            $log.debug.logs = [];
          };
          $log.assertEmpty = function() {
            var errors = [];
            angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {
              angular.forEach($log[logLevel].logs, function(log) {
                angular.forEach(log, function(logItem) {
                  errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\n' + (logItem.stack || ''));
                });
              });
            });
            if (errors.length) {
              errors.unshift("Expected $log to be empty! Either a message was logged unexpectedly, or " + "an expected log message was not checked and removed:");
              errors.push('');
              throw new Error(errors.join('\n---------\n'));
            }
          };
          $log.reset();
          return $log;
        };
      };
      angular.mock.$IntervalProvider = function() {
        this.$get = ['$browser', '$rootScope', '$q', '$$q', function($browser, $rootScope, $q, $$q) {
          var repeatFns = [],
              nextRepeatId = 0,
              now = 0;
          var $interval = function(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],
                iteration = 0,
                skipApply = (angular.isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = (angular.isDefined(count)) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = nextRepeatId;
            function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                var fnIndex;
                deferred.resolve(iteration);
                angular.forEach(repeatFns, function(fn, index) {
                  if (fn.id === promise.$$intervalId)
                    fnIndex = index;
                });
                if (angular.isDefined(fnIndex)) {
                  repeatFns.splice(fnIndex, 1);
                }
              }
              if (skipApply) {
                $browser.defer.flush();
              } else {
                $rootScope.$apply();
              }
            }
            repeatFns.push({
              nextTime: (now + delay),
              delay: delay,
              fn: tick,
              id: nextRepeatId,
              deferred: deferred
            });
            repeatFns.sort(function(a, b) {
              return a.nextTime - b.nextTime;
            });
            nextRepeatId++;
            return promise;
          };
          $interval.cancel = function(promise) {
            if (!promise)
              return false;
            var fnIndex;
            angular.forEach(repeatFns, function(fn, index) {
              if (fn.id === promise.$$intervalId)
                fnIndex = index;
            });
            if (angular.isDefined(fnIndex)) {
              repeatFns[fnIndex].deferred.reject('canceled');
              repeatFns.splice(fnIndex, 1);
              return true;
            }
            return false;
          };
          $interval.flush = function(millis) {
            now += millis;
            while (repeatFns.length && repeatFns[0].nextTime <= now) {
              var task = repeatFns[0];
              task.fn();
              task.nextTime += task.delay;
              repeatFns.sort(function(a, b) {
                return a.nextTime - b.nextTime;
              });
            }
            return millis;
          };
          return $interval;
        }];
      };
      var R_ISO8061_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;
      function jsonStringToDate(string) {
        var match;
        if (match = string.match(R_ISO8061_STR)) {
          var date = new Date(0),
              tzHour = 0,
              tzMin = 0;
          if (match[9]) {
            tzHour = toInt(match[9] + match[10]);
            tzMin = toInt(match[9] + match[11]);
          }
          date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
          date.setUTCHours(toInt(match[4] || 0) - tzHour, toInt(match[5] || 0) - tzMin, toInt(match[6] || 0), toInt(match[7] || 0));
          return date;
        }
        return string;
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      angular.mock.TzDate = function(offset, timestamp) {
        var self = new Date(0);
        if (angular.isString(timestamp)) {
          var tsStr = timestamp;
          self.origDate = jsonStringToDate(timestamp);
          timestamp = self.origDate.getTime();
          if (isNaN(timestamp)) {
            throw {
              name: "Illegal Argument",
              message: "Arg '" + tsStr + "' passed into TzDate constructor is not a valid date string"
            };
          }
        } else {
          self.origDate = new Date(timestamp);
        }
        var localOffset = new Date(timestamp).getTimezoneOffset();
        self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
        self.date = new Date(timestamp + self.offsetDiff);
        self.getTime = function() {
          return self.date.getTime() - self.offsetDiff;
        };
        self.toLocaleDateString = function() {
          return self.date.toLocaleDateString();
        };
        self.getFullYear = function() {
          return self.date.getFullYear();
        };
        self.getMonth = function() {
          return self.date.getMonth();
        };
        self.getDate = function() {
          return self.date.getDate();
        };
        self.getHours = function() {
          return self.date.getHours();
        };
        self.getMinutes = function() {
          return self.date.getMinutes();
        };
        self.getSeconds = function() {
          return self.date.getSeconds();
        };
        self.getMilliseconds = function() {
          return self.date.getMilliseconds();
        };
        self.getTimezoneOffset = function() {
          return offset * 60;
        };
        self.getUTCFullYear = function() {
          return self.origDate.getUTCFullYear();
        };
        self.getUTCMonth = function() {
          return self.origDate.getUTCMonth();
        };
        self.getUTCDate = function() {
          return self.origDate.getUTCDate();
        };
        self.getUTCHours = function() {
          return self.origDate.getUTCHours();
        };
        self.getUTCMinutes = function() {
          return self.origDate.getUTCMinutes();
        };
        self.getUTCSeconds = function() {
          return self.origDate.getUTCSeconds();
        };
        self.getUTCMilliseconds = function() {
          return self.origDate.getUTCMilliseconds();
        };
        self.getDay = function() {
          return self.date.getDay();
        };
        if (self.toISOString) {
          self.toISOString = function() {
            return padNumber(self.origDate.getUTCFullYear(), 4) + '-' + padNumber(self.origDate.getUTCMonth() + 1, 2) + '-' + padNumber(self.origDate.getUTCDate(), 2) + 'T' + padNumber(self.origDate.getUTCHours(), 2) + ':' + padNumber(self.origDate.getUTCMinutes(), 2) + ':' + padNumber(self.origDate.getUTCSeconds(), 2) + '.' + padNumber(self.origDate.getUTCMilliseconds(), 3) + 'Z';
          };
        }
        var unimplementedMethods = ['getUTCDay', 'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString', 'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];
        angular.forEach(unimplementedMethods, function(methodName) {
          self[methodName] = function() {
            throw new Error("Method '" + methodName + "' is not implemented in the TzDate mock");
          };
        });
        return self;
      };
      angular.mock.TzDate.prototype = Date.prototype;
      angular.mock.animate = angular.module('ngAnimateMock', ['ng']).config(['$provide', function($provide) {
        $provide.factory('$$forceReflow', function() {
          function reflowFn() {
            reflowFn.totalReflows++;
          }
          reflowFn.totalReflows = 0;
          return reflowFn;
        });
        $provide.factory('$$animateAsyncRun', function() {
          var queue = [];
          var queueFn = function() {
            return function(fn) {
              queue.push(fn);
            };
          };
          queueFn.flush = function() {
            if (queue.length === 0)
              return false;
            for (var i = 0; i < queue.length; i++) {
              queue[i]();
            }
            queue = [];
            return true;
          };
          return queueFn;
        });
        $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$$forceReflow', '$$animateAsyncRun', '$rootScope', function($delegate, $timeout, $browser, $$rAF, $$forceReflow, $$animateAsyncRun, $rootScope) {
          var animate = {
            queue: [],
            cancel: $delegate.cancel,
            on: $delegate.on,
            off: $delegate.off,
            pin: $delegate.pin,
            get reflows() {
              return $$forceReflow.totalReflows;
            },
            enabled: $delegate.enabled,
            flush: function() {
              $rootScope.$digest();
              var doNextRun,
                  somethingFlushed = false;
              do {
                doNextRun = false;
                if ($$rAF.queue.length) {
                  $$rAF.flush();
                  doNextRun = somethingFlushed = true;
                }
                if ($$animateAsyncRun.flush()) {
                  doNextRun = somethingFlushed = true;
                }
              } while (doNextRun);
              if (!somethingFlushed) {
                throw new Error('No pending animations ready to be closed or flushed');
              }
              $rootScope.$digest();
            }
          };
          angular.forEach(['animate', 'enter', 'leave', 'move', 'addClass', 'removeClass', 'setClass'], function(method) {
            animate[method] = function() {
              animate.queue.push({
                event: method,
                element: arguments[0],
                options: arguments[arguments.length - 1],
                args: arguments
              });
              return $delegate[method].apply($delegate, arguments);
            };
          });
          return animate;
        }]);
      }]);
      angular.mock.dump = function(object) {
        return serialize(object);
        function serialize(object) {
          var out;
          if (angular.isElement(object)) {
            object = angular.element(object);
            out = angular.element('<div></div>');
            angular.forEach(object, function(element) {
              out.append(angular.element(element).clone());
            });
            out = out.html();
          } else if (angular.isArray(object)) {
            out = [];
            angular.forEach(object, function(o) {
              out.push(serialize(o));
            });
            out = '[ ' + out.join(', ') + ' ]';
          } else if (angular.isObject(object)) {
            if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {
              out = serializeScope(object);
            } else if (object instanceof Error) {
              out = object.stack || ('' + object.name + ': ' + object.message);
            } else {
              out = angular.toJson(object, true);
            }
          } else {
            out = String(object);
          }
          return out;
        }
        function serializeScope(scope, offset) {
          offset = offset || '  ';
          var log = [offset + 'Scope(' + scope.$id + '): {'];
          for (var key in scope) {
            if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\$|this)/)) {
              log.push('  ' + key + ': ' + angular.toJson(scope[key]));
            }
          }
          var child = scope.$$childHead;
          while (child) {
            log.push(serializeScope(child, offset + '  '));
            child = child.$$nextSibling;
          }
          log.push('}');
          return log.join('\n' + offset);
        }
      };
      angular.mock.$HttpBackendProvider = function() {
        this.$get = ['$rootScope', '$timeout', createHttpBackendMock];
      };
      function createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {
        var definitions = [],
            expectations = [],
            responses = [],
            responsesPush = angular.bind(responses, responses.push),
            copy = angular.copy;
        function createResponse(status, data, headers, statusText) {
          if (angular.isFunction(status))
            return status;
          return function() {
            return angular.isNumber(status) ? [status, data, headers, statusText] : [200, status, data, headers];
          };
        }
        function $httpBackend(method, url, data, callback, headers, timeout, withCredentials) {
          var xhr = new MockXhr(),
              expectation = expectations[0],
              wasExpected = false;
          function prettyPrint(data) {
            return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp) ? data : angular.toJson(data);
          }
          function wrapResponse(wrapped) {
            if (!$browser && timeout) {
              timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);
            }
            return handleResponse;
            function handleResponse() {
              var response = wrapped.response(method, url, data, headers);
              xhr.$$respHeaders = response[2];
              callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(), copy(response[3] || ''));
            }
            function handleTimeout() {
              for (var i = 0,
                  ii = responses.length; i < ii; i++) {
                if (responses[i] === handleResponse) {
                  responses.splice(i, 1);
                  callback(-1, undefined, '');
                  break;
                }
              }
            }
          }
          if (expectation && expectation.match(method, url)) {
            if (!expectation.matchData(data)) {
              throw new Error('Expected ' + expectation + ' with different data\n' + 'EXPECTED: ' + prettyPrint(expectation.data) + '\nGOT:      ' + data);
            }
            if (!expectation.matchHeaders(headers)) {
              throw new Error('Expected ' + expectation + ' with different headers\n' + 'EXPECTED: ' + prettyPrint(expectation.headers) + '\nGOT:      ' + prettyPrint(headers));
            }
            expectations.shift();
            if (expectation.response) {
              responses.push(wrapResponse(expectation));
              return;
            }
            wasExpected = true;
          }
          var i = -1,
              definition;
          while ((definition = definitions[++i])) {
            if (definition.match(method, url, data, headers || {})) {
              if (definition.response) {
                ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
              } else if (definition.passThrough) {
                $delegate(method, url, data, callback, headers, timeout, withCredentials);
              } else
                throw new Error('No response defined !');
              return;
            }
          }
          throw wasExpected ? new Error('No response defined !') : new Error('Unexpected request: ' + method + ' ' + url + '\n' + (expectation ? 'Expected ' + expectation : 'No more request expected'));
        }
        $httpBackend.when = function(method, url, data, headers) {
          var definition = new MockHttpExpectation(method, url, data, headers),
              chain = {respond: function(status, data, headers, statusText) {
                  definition.passThrough = undefined;
                  definition.response = createResponse(status, data, headers, statusText);
                  return chain;
                }};
          if ($browser) {
            chain.passThrough = function() {
              definition.response = undefined;
              definition.passThrough = true;
              return chain;
            };
          }
          definitions.push(definition);
          return chain;
        };
        createShortMethods('when');
        $httpBackend.expect = function(method, url, data, headers) {
          var expectation = new MockHttpExpectation(method, url, data, headers),
              chain = {respond: function(status, data, headers, statusText) {
                  expectation.response = createResponse(status, data, headers, statusText);
                  return chain;
                }};
          expectations.push(expectation);
          return chain;
        };
        createShortMethods('expect');
        $httpBackend.flush = function(count, digest) {
          if (digest !== false)
            $rootScope.$digest();
          if (!responses.length)
            throw new Error('No pending request to flush !');
          if (angular.isDefined(count) && count !== null) {
            while (count--) {
              if (!responses.length)
                throw new Error('No more pending request to flush !');
              responses.shift()();
            }
          } else {
            while (responses.length) {
              responses.shift()();
            }
          }
          $httpBackend.verifyNoOutstandingExpectation(digest);
        };
        $httpBackend.verifyNoOutstandingExpectation = function(digest) {
          if (digest !== false)
            $rootScope.$digest();
          if (expectations.length) {
            throw new Error('Unsatisfied requests: ' + expectations.join(', '));
          }
        };
        $httpBackend.verifyNoOutstandingRequest = function() {
          if (responses.length) {
            throw new Error('Unflushed requests: ' + responses.length);
          }
        };
        $httpBackend.resetExpectations = function() {
          expectations.length = 0;
          responses.length = 0;
        };
        return $httpBackend;
        function createShortMethods(prefix) {
          angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {
            $httpBackend[prefix + method] = function(url, headers) {
              return $httpBackend[prefix](method, url, undefined, headers);
            };
          });
          angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {
            $httpBackend[prefix + method] = function(url, data, headers) {
              return $httpBackend[prefix](method, url, data, headers);
            };
          });
        }
      }
      function MockHttpExpectation(method, url, data, headers) {
        this.data = data;
        this.headers = headers;
        this.match = function(m, u, d, h) {
          if (method != m)
            return false;
          if (!this.matchUrl(u))
            return false;
          if (angular.isDefined(d) && !this.matchData(d))
            return false;
          if (angular.isDefined(h) && !this.matchHeaders(h))
            return false;
          return true;
        };
        this.matchUrl = function(u) {
          if (!url)
            return true;
          if (angular.isFunction(url.test))
            return url.test(u);
          if (angular.isFunction(url))
            return url(u);
          return url == u;
        };
        this.matchHeaders = function(h) {
          if (angular.isUndefined(headers))
            return true;
          if (angular.isFunction(headers))
            return headers(h);
          return angular.equals(headers, h);
        };
        this.matchData = function(d) {
          if (angular.isUndefined(data))
            return true;
          if (data && angular.isFunction(data.test))
            return data.test(d);
          if (data && angular.isFunction(data))
            return data(d);
          if (data && !angular.isString(data)) {
            return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
          }
          return data == d;
        };
        this.toString = function() {
          return method + ' ' + url;
        };
      }
      function createMockXhr() {
        return new MockXhr();
      }
      function MockXhr() {
        MockXhr.$$lastInstance = this;
        this.open = function(method, url, async) {
          this.$$method = method;
          this.$$url = url;
          this.$$async = async;
          this.$$reqHeaders = {};
          this.$$respHeaders = {};
        };
        this.send = function(data) {
          this.$$data = data;
        };
        this.setRequestHeader = function(key, value) {
          this.$$reqHeaders[key] = value;
        };
        this.getResponseHeader = function(name) {
          var header = this.$$respHeaders[name];
          if (header)
            return header;
          name = angular.lowercase(name);
          header = this.$$respHeaders[name];
          if (header)
            return header;
          header = undefined;
          angular.forEach(this.$$respHeaders, function(headerVal, headerName) {
            if (!header && angular.lowercase(headerName) == name)
              header = headerVal;
          });
          return header;
        };
        this.getAllResponseHeaders = function() {
          var lines = [];
          angular.forEach(this.$$respHeaders, function(value, key) {
            lines.push(key + ': ' + value);
          });
          return lines.join('\n');
        };
        this.abort = angular.noop;
      }
      angular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {
        $delegate.flush = function(delay) {
          $browser.defer.flush(delay);
        };
        $delegate.verifyNoPendingTasks = function() {
          if ($browser.deferredFns.length) {
            throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' + formatPendingTasksAsString($browser.deferredFns));
          }
        };
        function formatPendingTasksAsString(tasks) {
          var result = [];
          angular.forEach(tasks, function(task) {
            result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');
          });
          return result.join(', ');
        }
        return $delegate;
      }];
      angular.mock.$RAFDecorator = ['$delegate', function($delegate) {
        var rafFn = function(fn) {
          var index = rafFn.queue.length;
          rafFn.queue.push(fn);
          return function() {
            rafFn.queue.splice(index, 1);
          };
        };
        rafFn.queue = [];
        rafFn.supported = $delegate.supported;
        rafFn.flush = function() {
          if (rafFn.queue.length === 0) {
            throw new Error('No rAF callbacks present');
          }
          var length = rafFn.queue.length;
          for (var i = 0; i < length; i++) {
            rafFn.queue[i]();
          }
          rafFn.queue = rafFn.queue.slice(i);
        };
        return rafFn;
      }];
      angular.mock.$RootElementProvider = function() {
        this.$get = function() {
          return angular.element('<div ng-app></div>');
        };
      };
      angular.mock.$ControllerDecorator = ['$delegate', function($delegate) {
        return function(expression, locals, later, ident) {
          if (later && typeof later === 'object') {
            var create = $delegate(expression, locals, true, ident);
            angular.extend(create.instance, later);
            return create();
          }
          return $delegate(expression, locals, later, ident);
        };
      }];
      angular.module('ngMock', ['ng']).provider({
        $browser: angular.mock.$BrowserProvider,
        $exceptionHandler: angular.mock.$ExceptionHandlerProvider,
        $log: angular.mock.$LogProvider,
        $interval: angular.mock.$IntervalProvider,
        $httpBackend: angular.mock.$HttpBackendProvider,
        $rootElement: angular.mock.$RootElementProvider
      }).config(['$provide', function($provide) {
        $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);
        $provide.decorator('$$rAF', angular.mock.$RAFDecorator);
        $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);
        $provide.decorator('$controller', angular.mock.$ControllerDecorator);
      }]);
      angular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {
        $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);
      }]);
      angular.mock.e2e = {};
      angular.mock.e2e.$httpBackendDecorator = ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];
      angular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {
        var $rootScopePrototype = Object.getPrototypeOf($delegate);
        $rootScopePrototype.$countChildScopes = countChildScopes;
        $rootScopePrototype.$countWatchers = countWatchers;
        return $delegate;
        function countChildScopes() {
          var count = 0;
          var pendingChildHeads = [this.$$childHead];
          var currentScope;
          while (pendingChildHeads.length) {
            currentScope = pendingChildHeads.shift();
            while (currentScope) {
              count += 1;
              pendingChildHeads.push(currentScope.$$childHead);
              currentScope = currentScope.$$nextSibling;
            }
          }
          return count;
        }
        function countWatchers() {
          var count = this.$$watchers ? this.$$watchers.length : 0;
          var pendingChildHeads = [this.$$childHead];
          var currentScope;
          while (pendingChildHeads.length) {
            currentScope = pendingChildHeads.shift();
            while (currentScope) {
              count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
              pendingChildHeads.push(currentScope.$$childHead);
              currentScope = currentScope.$$nextSibling;
            }
          }
          return count;
        }
      }];
      if (window.jasmine || window.mocha) {
        var currentSpec = null,
            annotatedFunctions = [],
            isSpecRunning = function() {
              return !!currentSpec;
            };
        angular.mock.$$annotate = angular.injector.$$annotate;
        angular.injector.$$annotate = function(fn) {
          if (typeof fn === 'function' && !fn.$inject) {
            annotatedFunctions.push(fn);
          }
          return angular.mock.$$annotate.apply(this, arguments);
        };
        (window.beforeEach || window.setup)(function() {
          annotatedFunctions = [];
          currentSpec = this;
        });
        (window.afterEach || window.teardown)(function() {
          var injector = currentSpec.$injector;
          annotatedFunctions.forEach(function(fn) {
            delete fn.$inject;
          });
          angular.forEach(currentSpec.$modules, function(module) {
            if (module && module.$$hashKey) {
              module.$$hashKey = undefined;
            }
          });
          currentSpec.$injector = null;
          currentSpec.$modules = null;
          currentSpec = null;
          if (injector) {
            injector.get('$rootElement').off();
          }
          angular.forEach(angular.element.fragments, function(val, key) {
            delete angular.element.fragments[key];
          });
          MockXhr.$$lastInstance = null;
          angular.forEach(angular.callbacks, function(val, key) {
            delete angular.callbacks[key];
          });
          angular.callbacks.counter = 0;
        });
        window.module = angular.mock.module = function() {
          var moduleFns = Array.prototype.slice.call(arguments, 0);
          return isSpecRunning() ? workFn() : workFn;
          function workFn() {
            if (currentSpec.$injector) {
              throw new Error('Injector already created, can not register a module!');
            } else {
              var modules = currentSpec.$modules || (currentSpec.$modules = []);
              angular.forEach(moduleFns, function(module) {
                if (angular.isObject(module) && !angular.isArray(module)) {
                  modules.push(function($provide) {
                    angular.forEach(module, function(value, key) {
                      $provide.value(key, value);
                    });
                  });
                } else {
                  modules.push(module);
                }
              });
            }
          }
        };
        var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {
          this.message = e.message;
          this.name = e.name;
          if (e.line)
            this.line = e.line;
          if (e.sourceId)
            this.sourceId = e.sourceId;
          if (e.stack && errorForStack)
            this.stack = e.stack + '\n' + errorForStack.stack;
          if (e.stackArray)
            this.stackArray = e.stackArray;
        };
        ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;
        window.inject = angular.mock.inject = function() {
          var blockFns = Array.prototype.slice.call(arguments, 0);
          var errorForStack = new Error('Declaration Location');
          return isSpecRunning() ? workFn.call(currentSpec) : workFn;
          function workFn() {
            var modules = currentSpec.$modules || [];
            var strictDi = !!currentSpec.$injectorStrict;
            modules.unshift('ngMock');
            modules.unshift('ng');
            var injector = currentSpec.$injector;
            if (!injector) {
              if (strictDi) {
                angular.forEach(modules, function(moduleFn) {
                  if (typeof moduleFn === "function") {
                    angular.injector.$$annotate(moduleFn);
                  }
                });
              }
              injector = currentSpec.$injector = angular.injector(modules, strictDi);
              currentSpec.$injectorStrict = strictDi;
            }
            for (var i = 0,
                ii = blockFns.length; i < ii; i++) {
              if (currentSpec.$injectorStrict) {
                injector.annotate(blockFns[i]);
              }
              try {
                injector.invoke(blockFns[i] || angular.noop, this);
              } catch (e) {
                if (e.stack && errorForStack) {
                  throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
                }
                throw e;
              } finally {
                errorForStack = null;
              }
            }
          }
        };
        angular.mock.inject.strictDi = function(value) {
          value = arguments.length ? !!value : true;
          return isSpecRunning() ? workFn() : workFn;
          function workFn() {
            if (value !== currentSpec.$injectorStrict) {
              if (currentSpec.$injector) {
                throw new Error('Injector already created, can not modify strict annotations');
              } else {
                currentSpec.$injectorStrict = value;
              }
            }
          }
        };
      }
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-mocks@1.4.7", ["github:angular/bower-angular-mocks@1.4.7/angular-mocks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-mocks@1.4.7/angular-mocks');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-messages@1.4.7/angular-messages", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function(window, angular, undefined) {
      'use strict';
      var isArray = angular.isArray;
      var forEach = angular.forEach;
      var isString = angular.isString;
      var jqLite = angular.element;
      angular.module('ngMessages', []).directive('ngMessages', ['$animate', function($animate) {
        var ACTIVE_CLASS = 'ng-active';
        var INACTIVE_CLASS = 'ng-inactive';
        return {
          require: 'ngMessages',
          restrict: 'AE',
          controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
            var ctrl = this;
            var latestKey = 0;
            var nextAttachId = 0;
            this.getAttachId = function getAttachId() {
              return nextAttachId++;
            };
            var messages = this.messages = {};
            var renderLater,
                cachedCollection;
            this.render = function(collection) {
              collection = collection || {};
              renderLater = false;
              cachedCollection = collection;
              var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) || isAttrTruthy($scope, $attrs.multiple);
              var unmatchedMessages = [];
              var matchedKeys = {};
              var messageItem = ctrl.head;
              var messageFound = false;
              var totalMessages = 0;
              while (messageItem != null) {
                totalMessages++;
                var messageCtrl = messageItem.message;
                var messageUsed = false;
                if (!messageFound) {
                  forEach(collection, function(value, key) {
                    if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
                      if (matchedKeys[key])
                        return;
                      matchedKeys[key] = true;
                      messageUsed = true;
                      messageCtrl.attach();
                    }
                  });
                }
                if (messageUsed) {
                  messageFound = !multiple;
                } else {
                  unmatchedMessages.push(messageCtrl);
                }
                messageItem = messageItem.next;
              }
              forEach(unmatchedMessages, function(messageCtrl) {
                messageCtrl.detach();
              });
              unmatchedMessages.length !== totalMessages ? $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS) : $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
            };
            $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);
            this.reRender = function() {
              if (!renderLater) {
                renderLater = true;
                $scope.$evalAsync(function() {
                  if (renderLater) {
                    cachedCollection && ctrl.render(cachedCollection);
                  }
                });
              }
            };
            this.register = function(comment, messageCtrl) {
              var nextKey = latestKey.toString();
              messages[nextKey] = {message: messageCtrl};
              insertMessageNode($element[0], comment, nextKey);
              comment.$$ngMessageNode = nextKey;
              latestKey++;
              ctrl.reRender();
            };
            this.deregister = function(comment) {
              var key = comment.$$ngMessageNode;
              delete comment.$$ngMessageNode;
              removeMessageNode($element[0], comment, key);
              delete messages[key];
              ctrl.reRender();
            };
            function findPreviousMessage(parent, comment) {
              var prevNode = comment;
              var parentLookup = [];
              while (prevNode && prevNode !== parent) {
                var prevKey = prevNode.$$ngMessageNode;
                if (prevKey && prevKey.length) {
                  return messages[prevKey];
                }
                if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) == -1) {
                  parentLookup.push(prevNode);
                  prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
                } else {
                  prevNode = prevNode.previousSibling || prevNode.parentNode;
                }
              }
            }
            function insertMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              if (!ctrl.head) {
                ctrl.head = messageNode;
              } else {
                var match = findPreviousMessage(parent, comment);
                if (match) {
                  messageNode.next = match.next;
                  match.next = messageNode;
                } else {
                  messageNode.next = ctrl.head;
                  ctrl.head = messageNode;
                }
              }
            }
            function removeMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              var match = findPreviousMessage(parent, comment);
              if (match) {
                match.next = messageNode.next;
              } else {
                ctrl.head = messageNode.next;
              }
            }
          }]
        };
        function isAttrTruthy(scope, attr) {
          return (isString(attr) && attr.length === 0) || truthy(scope.$eval(attr));
        }
        function truthy(val) {
          return isString(val) ? val.length : !!val;
        }
      }]).directive('ngMessagesInclude', ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {
        return {
          restrict: 'AE',
          require: '^^ngMessages',
          link: function($scope, element, attrs) {
            var src = attrs.ngMessagesInclude || attrs.src;
            $templateRequest(src).then(function(html) {
              $compile(html)($scope, function(contents) {
                element.after(contents);
                var anchor = jqLite($document[0].createComment(' ngMessagesInclude: ' + src + ' '));
                element.after(anchor);
                element.remove();
              });
            });
          }
        };
      }]).directive('ngMessage', ngMessageDirectiveFactory('AE')).directive('ngMessageExp', ngMessageDirectiveFactory('A'));
      function ngMessageDirectiveFactory(restrict) {
        return ['$animate', function($animate) {
          return {
            restrict: 'AE',
            transclude: 'element',
            terminal: true,
            require: '^^ngMessages',
            link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
              var commentNode = element[0];
              var records;
              var staticExp = attrs.ngMessage || attrs.when;
              var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
              var assignRecords = function(items) {
                records = items ? (isArray(items) ? items : items.split(/[\s,]+/)) : null;
                ngMessagesCtrl.reRender();
              };
              if (dynamicExp) {
                assignRecords(scope.$eval(dynamicExp));
                scope.$watchCollection(dynamicExp, assignRecords);
              } else {
                assignRecords(staticExp);
              }
              var currentElement,
                  messageCtrl;
              ngMessagesCtrl.register(commentNode, messageCtrl = {
                test: function(name) {
                  return contains(records, name);
                },
                attach: function() {
                  if (!currentElement) {
                    $transclude(scope, function(elm) {
                      $animate.enter(elm, null, element);
                      currentElement = elm;
                      var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();
                      currentElement.on('$destroy', function() {
                        if (currentElement && currentElement.$$attachId === $$attachId) {
                          ngMessagesCtrl.deregister(commentNode);
                          messageCtrl.detach();
                        }
                      });
                    });
                  }
                },
                detach: function() {
                  if (currentElement) {
                    var elm = currentElement;
                    currentElement = null;
                    $animate.leave(elm);
                  }
                }
              });
            }
          };
        }];
        function contains(collection, key) {
          if (collection) {
            return isArray(collection) ? collection.indexOf(key) >= 0 : collection.hasOwnProperty(key);
          }
        }
      }
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-messages@1.4.7/index", ["github:angular/bower-angular-messages@1.4.7/angular-messages"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('github:angular/bower-angular-messages@1.4.7/angular-messages');
  module.exports = 'ngMessages';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-messages@1.4.7", ["github:angular/bower-angular-messages@1.4.7/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-messages@1.4.7/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular@1.4.7/angular", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
          return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
          return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
      function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
          throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
          throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
          destination = source;
          if (isObject(source)) {
            var index;
            if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
              return stackDest[index];
            }
            if (isArray(source)) {
              return copy(source, [], stackSource, stackDest);
            } else if (isTypedArray(source)) {
              destination = new source.constructor(source);
            } else if (isDate(source)) {
              destination = new Date(source.getTime());
            } else if (isRegExp(source)) {
              destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              destination.lastIndex = source.lastIndex;
            } else if (isFunction(source.cloneNode)) {
              destination = source.cloneNode(true);
            } else {
              var emptyObject = Object.create(getPrototypeOf(source));
              return copy(source, emptyObject, stackSource, stackDest);
            }
            if (stackDest) {
              stackSource.push(source);
              stackDest.push(destination);
            }
          }
        } else {
          if (source === destination)
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          stackSource = stackSource || [];
          stackDest = stackDest || [];
          if (isObject(source)) {
            stackSource.push(source);
            stackDest.push(destination);
          }
          var result,
              key;
          if (isArray(source)) {
            destination.length = 0;
            for (var i = 0; i < source.length; i++) {
              destination.push(copy(source[i], null, stackSource, stackDest));
            }
          } else {
            var h = destination.$$hashKey;
            if (isArray(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key) {
                delete destination[key];
              });
            }
            if (isBlankObject(source)) {
              for (key in source) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            } else if (source && typeof source.hasOwnProperty === 'function') {
              for (key in source) {
                if (source.hasOwnProperty(key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            } else {
              for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            }
            setHashKey(destination, h);
          }
        }
        return destination;
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.7',
        major: 1,
        minor: 4,
        dot: 7,
        codeName: 'dark-luminescence'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          forEach(type.split(' '), function(type) {
            if (isDefined(fn)) {
              var listenerFns = events[type];
              arrayRemove(listenerFns || [], fn);
              if (listenerFns && listenerFns.length > 0) {
                return;
              }
            }
            removeEventListenerFn(element, type, handle);
            delete events[type];
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              eventFns[i].call(element, event);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          while (i--) {
            type = types[i];
            var eventFns = events[type];
            if (!eventFns) {
              events[type] = [];
              if (type === 'mouseenter' || type === 'mouseleave') {
                jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                  var target = this,
                      related = event.relatedTarget;
                  if (!related || (related !== target && !target.contains(related))) {
                    handle(event, type);
                  }
                });
              } else {
                if (type !== '$destroy') {
                  addEventListenerFn(element, type, handle);
                }
              }
              eventFns = events[type];
            }
            eventFns.push(fn);
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', function($$rAF, $q) {
          var RAFPromise = function() {};
          RAFPromise.prototype = {
            done: function(cancel) {
              this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
            },
            end: function() {
              this.done();
            },
            cancel: function() {
              this.done(true);
            },
            getPromise: function() {
              if (!this.defer) {
                this.defer = $q.defer();
              }
              return this.defer.promise;
            },
            then: function(f1, f2) {
              return this.getPromise().then(f1, f2);
            },
            'catch': function(f1) {
              return this.getPromise()['catch'](f1);
            },
            'finally': function(f1) {
              return this.getPromise()['finally'](f1);
            }
          };
          return function(element, options) {
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new RAFPromise();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                close();
                if (!closed) {
                  runner.done();
                }
                closed = true;
              });
              return runner;
            }
            function close() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = {},
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = {},
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = {};
                size = 0;
                lruHash = {};
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                    var destroyBindings = nodeLinkFn.$$destroyBindings;
                    if (destroyBindings) {
                      nodeLinkFn.$$destroyBindings = null;
                      childScope.$on('$destroyed', destroyBindings);
                    }
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                  if (directiveIsMultiElement(directiveNName)) {
                    if (ngAttrName === directiveNName + 'Start') {
                      attrStartName = name;
                      attrEndName = name.substr(0, name.length - 5) + 'end';
                      name = name.substr(0, name.length - 6);
                    }
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn);
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective) {
                    markDirectivesAsIsolate(templateDirectives);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
              var i,
                  ii,
                  linkFn,
                  controller,
                  isolateScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
              }
              if (elementControllers) {
                var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                var bindings;
                var controllerForBindings;
                if (scopeDirective && elementControllers[scopeDirective.name]) {
                  bindings = scopeDirective.$$bindings.bindToController;
                  controller = elementControllers[scopeDirective.name];
                  if (controller && controller.identifier && bindings) {
                    controllerForBindings = controller;
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                  }
                }
                for (i in elementControllers) {
                  controller = elementControllers[i];
                  var controllerResult = controller();
                  if (controllerResult !== controller.instance) {
                    controller.instance = controllerResult;
                    $element.data('$' + i + 'Controller', controllerResult);
                    if (controller === controllerForBindings) {
                      thisLinkFn.$$destroyBindings();
                      thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                    }
                  }
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectivesAsIsolate(directives) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {$$isolateScope: true});
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite(newNode).data(jqLite(firstElementToRemove).data());
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
            var onNewScopeDestroyed;
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var unwatch;
                  if (definition.collection) {
                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  onNewScopeDestroyed = (onNewScopeDestroyed || []);
                  onNewScopeDestroyed.push(unwatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
              for (var i = 0,
                  ii = onNewScopeDestroyed.length; i < ii; ++i) {
                onNewScopeDestroyed[i]();
              }
            } : noop;
            if (newScope && destroyBindings !== noop) {
              newScope.$on('$destroy', destroyBindings);
              return noop;
            }
            return destroyBindings;
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              if (!response.data) {
                resp.data = response.data;
              } else {
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              }
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name, fullExpression) {
        name = name + '';
        if (!isString(name)) {
          throw $parseMinErr('iseccst', 'Cannot convert object to primitive value! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ',text)');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
            formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: function(scope, selectElement, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0,
                children = selectElement.children(),
                ii = children.length; i < ii; i++) {
              if (children[i].value === '') {
                emptyOption = children.eq(i);
                break;
              }
            }
            var providedEmptyOption = !!emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var renderEmptyOption = function() {
              if (!providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              selectElement.val('');
              emptyOption.prop('selected', true);
              emptyOption.attr('selected', true);
            };
            var removeEmptyOption = function() {
              if (!providedEmptyOption) {
                emptyOption.remove();
              }
            };
            var renderUnknownOption = function() {
              selectElement.prepend(unknownOption);
              selectElement.val('?');
              unknownOption.prop('selected', true);
              unknownOption.attr('selected', true);
            };
            var removeUnknownOption = function() {
              unknownOption.remove();
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                var option = options.getOptionFromViewValue(value);
                if (option && !option.disabled) {
                  if (selectElement[0].value !== option.selectValue) {
                    removeUnknownOption();
                    removeEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                    option.element.setAttribute('selected', 'selected');
                  }
                } else {
                  if (value === null || providedEmptyOption) {
                    removeUnknownOption();
                    renderEmptyOption();
                  } else {
                    removeEmptyOption();
                    renderUnknownOption();
                  }
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  removeEmptyOption();
                  removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
              selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                options.items.forEach(function(option) {
                  option.element.selected = false;
                });
                if (value) {
                  value.forEach(function(item) {
                    var option = options.getOptionFromViewValue(item);
                    if (option && !option.disabled)
                      option.element.selected = true;
                  });
                }
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [],
                    selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              emptyOption.remove();
              $compile(emptyOption)(scope);
              emptyOption.removeClass('ng-scope');
            } else {
              emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function updateOptionElement(option, element) {
              option.element = element;
              element.disabled = option.disabled;
              if (option.label !== element.label) {
                element.label = option.label;
                element.textContent = option.label;
              }
              if (option.value !== element.value)
                element.value = option.selectValue;
            }
            function addOrReuseElement(parent, current, type, templateElement) {
              var element;
              if (current && lowercase(current.nodeName) === type) {
                element = current;
              } else {
                element = templateElement.cloneNode(false);
                if (!current) {
                  parent.appendChild(element);
                } else {
                  parent.insertBefore(element, current);
                }
              }
              return element;
            }
            function removeExcessElements(current) {
              var next;
              while (current) {
                next = current.nextSibling;
                jqLiteRemove(current);
                current = next;
              }
            }
            function skipEmptyAndUnknownOptions(current) {
              var emptyOption_ = emptyOption && emptyOption[0];
              var unknownOption_ = unknownOption && unknownOption[0];
              if (emptyOption_ || unknownOption_) {
                while (current && (current === emptyOption_ || current === unknownOption_ || emptyOption_ && emptyOption_.nodeType === NODE_TYPE_COMMENT)) {
                  current = current.nextSibling;
                }
              }
              return current;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              options = ngOptions.getOptions();
              var groupMap = {};
              var currentElement = selectElement[0].firstChild;
              if (providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              currentElement = skipEmptyAndUnknownOptions(currentElement);
              options.items.forEach(function updateOption(option) {
                var group;
                var groupElement;
                var optionElement;
                if (option.group) {
                  group = groupMap[option.group];
                  if (!group) {
                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                    currentElement = groupElement.nextSibling;
                    groupElement.label = option.group;
                    group = groupMap[option.group] = {
                      groupElement: groupElement,
                      currentOptionElement: groupElement.firstChild
                    };
                  }
                  optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  group.currentOptionElement = optionElement.nextSibling;
                } else {
                  optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  currentElement = optionElement.nextSibling;
                }
              });
              Object.keys(groupMap).forEach(function(key) {
                removeExcessElements(groupMap[key].currentOptionElement);
              });
              removeExcessElements(currentElement);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          link: function(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
            element.on('change', function() {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function(option) {
                  if (option.selected) {
                    array.push(option.value);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                var items = new HashMap(value);
                forEach(element.find('option'), function(option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              var lastView,
                  lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
        };
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        function chromeHack(optionElement) {
          if (optionElement[0].hasAttribute('selected')) {
            optionElement[0].selected = true;
          }
        }
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var valueInterpolated = $interpolate(attr.value, true);
            } else {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              function addOption(optionValue) {
                selectCtrl.addOption(optionValue, element);
                selectCtrl.ngModelCtrl.$render();
                chromeHack(element);
              }
              if (selectCtrl && selectCtrl.ngModelCtrl) {
                if (valueInterpolated) {
                  var oldVal;
                  attr.$observe('value', function valueAttributeObserveAction(newVal) {
                    if (isDefined(oldVal)) {
                      selectCtrl.removeOption(oldVal);
                    }
                    oldVal = newVal;
                    addOption(newVal);
                  });
                } else if (interpolateFn) {
                  scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                    attr.$set('value', newVal);
                    if (oldVal !== newVal) {
                      selectCtrl.removeOption(oldVal);
                    }
                    addOption(newVal);
                  });
                } else {
                  addOption(attr.value);
                }
                element.on('$destroy', function() {
                  selectCtrl.removeOption(attr.value);
                  selectCtrl.ngModelCtrl.$render();
                });
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular@1.4.7", ["github:angular/bower-angular@1.4.7/angular"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular@1.4.7/angular');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["npm:process@0.11.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:bluebird@2.10.2/js/browser/bluebird", ["github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define,
          module,
          exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o, !0);
              if (i)
                return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      })({
        1: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var SomePromiseArray = Promise._SomePromiseArray;
            function any(promises) {
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(1);
              ret.setUnwrap();
              ret.init();
              return promise;
            }
            Promise.any = function(promises) {
              return any(promises);
            };
            Promise.prototype.any = function() {
              return any(this);
            };
          };
        }, {}],
        2: [function(_dereq_, module, exports) {
          "use strict";
          var firstLineError;
          try {
            throw new Error();
          } catch (e) {
            firstLineError = e;
          }
          var schedule = _dereq_("./schedule.js");
          var Queue = _dereq_("./queue.js");
          var util = _dereq_("./util.js");
          function Async() {
            this._isTickUsed = false;
            this._lateQueue = new Queue(16);
            this._normalQueue = new Queue(16);
            this._trampolineEnabled = true;
            var self = this;
            this.drainQueues = function() {
              self._drainQueues();
            };
            this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;
          }
          Async.prototype.disableTrampolineIfNecessary = function() {
            if (util.hasDevTools) {
              this._trampolineEnabled = false;
            }
          };
          Async.prototype.enableTrampoline = function() {
            if (!this._trampolineEnabled) {
              this._trampolineEnabled = true;
              this._schedule = function(fn) {
                setTimeout(fn, 0);
              };
            }
          };
          Async.prototype.haveItemsQueued = function() {
            return this._normalQueue.length() > 0;
          };
          Async.prototype.throwLater = function(fn, arg) {
            if (arguments.length === 1) {
              arg = fn;
              fn = function() {
                throw arg;
              };
            }
            if (typeof setTimeout !== "undefined") {
              setTimeout(function() {
                fn(arg);
              }, 0);
            } else
              try {
                this._schedule(function() {
                  fn(arg);
                });
              } catch (e) {
                throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
              }
          };
          function AsyncInvokeLater(fn, receiver, arg) {
            this._lateQueue.push(fn, receiver, arg);
            this._queueTick();
          }
          function AsyncInvoke(fn, receiver, arg) {
            this._normalQueue.push(fn, receiver, arg);
            this._queueTick();
          }
          function AsyncSettlePromises(promise) {
            this._normalQueue._pushOne(promise);
            this._queueTick();
          }
          if (!util.hasDevTools) {
            Async.prototype.invokeLater = AsyncInvokeLater;
            Async.prototype.invoke = AsyncInvoke;
            Async.prototype.settlePromises = AsyncSettlePromises;
          } else {
            if (schedule.isStatic) {
              schedule = function(fn) {
                setTimeout(fn, 0);
              };
            }
            Async.prototype.invokeLater = function(fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
              } else {
                this._schedule(function() {
                  setTimeout(function() {
                    fn.call(receiver, arg);
                  }, 100);
                });
              }
            };
            Async.prototype.invoke = function(fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
              } else {
                this._schedule(function() {
                  fn.call(receiver, arg);
                });
              }
            };
            Async.prototype.settlePromises = function(promise) {
              if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
              } else {
                this._schedule(function() {
                  promise._settlePromises();
                });
              }
            };
          }
          Async.prototype.invokeFirst = function(fn, receiver, arg) {
            this._normalQueue.unshift(fn, receiver, arg);
            this._queueTick();
          };
          Async.prototype._drainQueue = function(queue) {
            while (queue.length() > 0) {
              var fn = queue.shift();
              if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
              }
              var receiver = queue.shift();
              var arg = queue.shift();
              fn.call(receiver, arg);
            }
          };
          Async.prototype._drainQueues = function() {
            this._drainQueue(this._normalQueue);
            this._reset();
            this._drainQueue(this._lateQueue);
          };
          Async.prototype._queueTick = function() {
            if (!this._isTickUsed) {
              this._isTickUsed = true;
              this._schedule(this.drainQueues);
            }
          };
          Async.prototype._reset = function() {
            this._isTickUsed = false;
          };
          module.exports = new Async();
          module.exports.firstLineError = firstLineError;
        }, {
          "./queue.js": 28,
          "./schedule.js": 31,
          "./util.js": 38
        }],
        3: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
            var rejectThis = function(_, e) {
              this._reject(e);
            };
            var targetRejected = function(e, context) {
              context.promiseRejectionQueued = true;
              context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
            };
            var bindingResolved = function(thisArg, context) {
              if (this._isPending()) {
                this._resolveCallback(context.target);
              }
            };
            var bindingRejected = function(e, context) {
              if (!context.promiseRejectionQueued)
                this._reject(e);
            };
            Promise.prototype.bind = function(thisArg) {
              var maybePromise = tryConvertToPromise(thisArg);
              var ret = new Promise(INTERNAL);
              ret._propagateFrom(this, 1);
              var target = this._target();
              ret._setBoundTo(maybePromise);
              if (maybePromise instanceof Promise) {
                var context = {
                  promiseRejectionQueued: false,
                  promise: ret,
                  target: target,
                  bindingPromise: maybePromise
                };
                target._then(INTERNAL, targetRejected, ret._progress, ret, context);
                maybePromise._then(bindingResolved, bindingRejected, ret._progress, ret, context);
              } else {
                ret._resolveCallback(target);
              }
              return ret;
            };
            Promise.prototype._setBoundTo = function(obj) {
              if (obj !== undefined) {
                this._bitField = this._bitField | 131072;
                this._boundTo = obj;
              } else {
                this._bitField = this._bitField & (~131072);
              }
            };
            Promise.prototype._isBound = function() {
              return (this._bitField & 131072) === 131072;
            };
            Promise.bind = function(thisArg, value) {
              var maybePromise = tryConvertToPromise(thisArg);
              var ret = new Promise(INTERNAL);
              ret._setBoundTo(maybePromise);
              if (maybePromise instanceof Promise) {
                maybePromise._then(function() {
                  ret._resolveCallback(value);
                }, ret._reject, ret._progress, ret, null);
              } else {
                ret._resolveCallback(value);
              }
              return ret;
            };
          };
        }, {}],
        4: [function(_dereq_, module, exports) {
          "use strict";
          var old;
          if (typeof Promise !== "undefined")
            old = Promise;
          function noConflict() {
            try {
              if (Promise === bluebird)
                Promise = old;
            } catch (e) {}
            return bluebird;
          }
          var bluebird = _dereq_("./promise.js")();
          bluebird.noConflict = noConflict;
          module.exports = bluebird;
        }, {"./promise.js": 23}],
        5: [function(_dereq_, module, exports) {
          "use strict";
          var cr = Object.create;
          if (cr) {
            var callerCache = cr(null);
            var getterCache = cr(null);
            callerCache[" size"] = getterCache[" size"] = 0;
          }
          module.exports = function(Promise) {
            var util = _dereq_("./util.js");
            var canEvaluate = util.canEvaluate;
            var isIdentifier = util.isIdentifier;
            var getMethodCaller;
            var getGetter;
            if (!true) {
              var makeMethodCaller = function(methodName) {
                return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
              };
              var makeGetter = function(propertyName) {
                return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
              };
              var getCompiled = function(name, compiler, cache) {
                var ret = cache[name];
                if (typeof ret !== "function") {
                  if (!isIdentifier(name)) {
                    return null;
                  }
                  ret = compiler(name);
                  cache[name] = ret;
                  cache[" size"]++;
                  if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for (var i = 0; i < 256; ++i)
                      delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                  }
                }
                return ret;
              };
              getMethodCaller = function(name) {
                return getCompiled(name, makeMethodCaller, callerCache);
              };
              getGetter = function(name) {
                return getCompiled(name, makeGetter, getterCache);
              };
            }
            function ensureMethod(obj, methodName) {
              var fn;
              if (obj != null)
                fn = obj[methodName];
              if (typeof fn !== "function") {
                var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                throw new Promise.TypeError(message);
              }
              return fn;
            }
            function caller(obj) {
              var methodName = this.pop();
              var fn = ensureMethod(obj, methodName);
              return fn.apply(obj, this);
            }
            Promise.prototype.call = function(methodName) {
              var $_len = arguments.length;
              var args = new Array($_len - 1);
              for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
              }
              if (!true) {
                if (canEvaluate) {
                  var maybeCaller = getMethodCaller(methodName);
                  if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                  }
                }
              }
              args.push(methodName);
              return this._then(caller, undefined, undefined, args, undefined);
            };
            function namedGetter(obj) {
              return obj[this];
            }
            function indexedGetter(obj) {
              var index = +this;
              if (index < 0)
                index = Math.max(0, index + obj.length);
              return obj[index];
            }
            Promise.prototype.get = function(propertyName) {
              var isIndex = (typeof propertyName === "number");
              var getter;
              if (!isIndex) {
                if (canEvaluate) {
                  var maybeGetter = getGetter(propertyName);
                  getter = maybeGetter !== null ? maybeGetter : namedGetter;
                } else {
                  getter = namedGetter;
                }
              } else {
                getter = indexedGetter;
              }
              return this._then(getter, undefined, undefined, propertyName, undefined);
            };
          };
        }, {"./util.js": 38}],
        6: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var errors = _dereq_("./errors.js");
            var async = _dereq_("./async.js");
            var CancellationError = errors.CancellationError;
            Promise.prototype._cancel = function(reason) {
              if (!this.isCancellable())
                return this;
              var parent;
              var promiseToReject = this;
              while ((parent = promiseToReject._cancellationParent) !== undefined && parent.isCancellable()) {
                promiseToReject = parent;
              }
              this._unsetCancellable();
              promiseToReject._target()._rejectCallback(reason, false, true);
            };
            Promise.prototype.cancel = function(reason) {
              if (!this.isCancellable())
                return this;
              if (reason === undefined)
                reason = new CancellationError();
              async.invokeLater(this._cancel, this, reason);
              return this;
            };
            Promise.prototype.cancellable = function() {
              if (this._cancellable())
                return this;
              async.enableTrampoline();
              this._setCancellable();
              this._cancellationParent = undefined;
              return this;
            };
            Promise.prototype.uncancellable = function() {
              var ret = this.then();
              ret._unsetCancellable();
              return ret;
            };
            Promise.prototype.fork = function(didFulfill, didReject, didProgress) {
              var ret = this._then(didFulfill, didReject, didProgress, undefined, undefined);
              ret._setCancellable();
              ret._cancellationParent = undefined;
              return ret;
            };
          };
        }, {
          "./async.js": 2,
          "./errors.js": 13
        }],
        7: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var async = _dereq_("./async.js");
            var util = _dereq_("./util.js");
            var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
            var stackFramePattern = null;
            var formatStack = null;
            var indentStackFrames = false;
            var warn;
            function CapturedTrace(parent) {
              this._parent = parent;
              var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
              captureStackTrace(this, CapturedTrace);
              if (length > 32)
                this.uncycle();
            }
            util.inherits(CapturedTrace, Error);
            CapturedTrace.prototype.uncycle = function() {
              var length = this._length;
              if (length < 2)
                return;
              var nodes = [];
              var stackToIndex = {};
              for (var i = 0,
                  node = this; node !== undefined; ++i) {
                nodes.push(node);
                node = node._parent;
              }
              length = this._length = i;
              for (var i = length - 1; i >= 0; --i) {
                var stack = nodes[i].stack;
                if (stackToIndex[stack] === undefined) {
                  stackToIndex[stack] = i;
                }
              }
              for (var i = 0; i < length; ++i) {
                var currentStack = nodes[i].stack;
                var index = stackToIndex[currentStack];
                if (index !== undefined && index !== i) {
                  if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                  }
                  nodes[i]._parent = undefined;
                  nodes[i]._length = 1;
                  var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                  if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                  } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                  }
                  var currentChildLength = cycleEdgeNode._length + 1;
                  for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                  }
                  return;
                }
              }
            };
            CapturedTrace.prototype.parent = function() {
              return this._parent;
            };
            CapturedTrace.prototype.hasParent = function() {
              return this._parent !== undefined;
            };
            CapturedTrace.prototype.attachExtraTrace = function(error) {
              if (error.__stackCleaned__)
                return;
              this.uncycle();
              var parsed = CapturedTrace.parseStackAndMessage(error);
              var message = parsed.message;
              var stacks = [parsed.stack];
              var trace = this;
              while (trace !== undefined) {
                stacks.push(cleanStack(trace.stack.split("\n")));
                trace = trace._parent;
              }
              removeCommonRoots(stacks);
              removeDuplicateOrEmptyJumps(stacks);
              util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
              util.notEnumerableProp(error, "__stackCleaned__", true);
            };
            function reconstructStack(message, stacks) {
              for (var i = 0; i < stacks.length - 1; ++i) {
                stacks[i].push("From previous event:");
                stacks[i] = stacks[i].join("\n");
              }
              if (i < stacks.length) {
                stacks[i] = stacks[i].join("\n");
              }
              return message + "\n" + stacks.join("\n");
            }
            function removeDuplicateOrEmptyJumps(stacks) {
              for (var i = 0; i < stacks.length; ++i) {
                if (stacks[i].length === 0 || ((i + 1 < stacks.length) && stacks[i][0] === stacks[i + 1][0])) {
                  stacks.splice(i, 1);
                  i--;
                }
              }
            }
            function removeCommonRoots(stacks) {
              var current = stacks[0];
              for (var i = 1; i < stacks.length; ++i) {
                var prev = stacks[i];
                var currentLastIndex = current.length - 1;
                var currentLastLine = current[currentLastIndex];
                var commonRootMeetPoint = -1;
                for (var j = prev.length - 1; j >= 0; --j) {
                  if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                  }
                }
                for (var j = commonRootMeetPoint; j >= 0; --j) {
                  var line = prev[j];
                  if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                  } else {
                    break;
                  }
                }
                current = prev;
              }
            }
            function cleanStack(stack) {
              var ret = [];
              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                var isTraceLine = stackFramePattern.test(line) || "    (No stack trace)" === line;
                var isInternalFrame = isTraceLine && shouldIgnore(line);
                if (isTraceLine && !isInternalFrame) {
                  if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                  }
                  ret.push(line);
                }
              }
              return ret;
            }
            function stackFramesAsArray(error) {
              var stack = error.stack.replace(/\s+$/g, "").split("\n");
              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                  break;
                }
              }
              if (i > 0) {
                stack = stack.slice(i);
              }
              return stack;
            }
            CapturedTrace.parseStackAndMessage = function(error) {
              var stack = error.stack;
              var message = error.toString();
              stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
              return {
                message: message,
                stack: cleanStack(stack)
              };
            };
            CapturedTrace.formatAndLogError = function(error, title) {
              if (typeof console !== "undefined") {
                var message;
                if (typeof error === "object" || typeof error === "function") {
                  var stack = error.stack;
                  message = title + formatStack(stack, error);
                } else {
                  message = title + String(error);
                }
                if (typeof warn === "function") {
                  warn(message);
                } else if (typeof console.log === "function" || typeof console.log === "object") {
                  console.log(message);
                }
              }
            };
            CapturedTrace.unhandledRejection = function(reason) {
              CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
            };
            CapturedTrace.isSupported = function() {
              return typeof captureStackTrace === "function";
            };
            CapturedTrace.fireRejectionEvent = function(name, localHandler, reason, promise) {
              var localEventFired = false;
              try {
                if (typeof localHandler === "function") {
                  localEventFired = true;
                  if (name === "rejectionHandled") {
                    localHandler(promise);
                  } else {
                    localHandler(reason, promise);
                  }
                }
              } catch (e) {
                async.throwLater(e);
              }
              var globalEventFired = false;
              try {
                globalEventFired = fireGlobalEvent(name, reason, promise);
              } catch (e) {
                globalEventFired = true;
                async.throwLater(e);
              }
              var domEventFired = false;
              if (fireDomEvent) {
                try {
                  domEventFired = fireDomEvent(name.toLowerCase(), {
                    reason: reason,
                    promise: promise
                  });
                } catch (e) {
                  domEventFired = true;
                  async.throwLater(e);
                }
              }
              if (!globalEventFired && !localEventFired && !domEventFired && name === "unhandledRejection") {
                CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
              }
            };
            function formatNonError(obj) {
              var str;
              if (typeof obj === "function") {
                str = "[function " + (obj.name || "anonymous") + "]";
              } else {
                str = obj.toString();
                var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                if (ruselessToString.test(str)) {
                  try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                  } catch (e) {}
                }
                if (str.length === 0) {
                  str = "(empty array)";
                }
              }
              return ("(<" + snip(str) + ">, no stack trace)");
            }
            function snip(str) {
              var maxChars = 41;
              if (str.length < maxChars) {
                return str;
              }
              return str.substr(0, maxChars - 3) + "...";
            }
            var shouldIgnore = function() {
              return false;
            };
            var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
            function parseLineInfo(line) {
              var matches = line.match(parseLineInfoRegex);
              if (matches) {
                return {
                  fileName: matches[1],
                  line: parseInt(matches[2], 10)
                };
              }
            }
            CapturedTrace.setBounds = function(firstLineError, lastLineError) {
              if (!CapturedTrace.isSupported())
                return;
              var firstStackLines = firstLineError.stack.split("\n");
              var lastStackLines = lastLineError.stack.split("\n");
              var firstIndex = -1;
              var lastIndex = -1;
              var firstFileName;
              var lastFileName;
              for (var i = 0; i < firstStackLines.length; ++i) {
                var result = parseLineInfo(firstStackLines[i]);
                if (result) {
                  firstFileName = result.fileName;
                  firstIndex = result.line;
                  break;
                }
              }
              for (var i = 0; i < lastStackLines.length; ++i) {
                var result = parseLineInfo(lastStackLines[i]);
                if (result) {
                  lastFileName = result.fileName;
                  lastIndex = result.line;
                  break;
                }
              }
              if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
                return;
              }
              shouldIgnore = function(line) {
                if (bluebirdFramePattern.test(line))
                  return true;
                var info = parseLineInfo(line);
                if (info) {
                  if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                  }
                }
                return false;
              };
            };
            var captureStackTrace = (function stackDetection() {
              var v8stackFramePattern = /^\s*at\s*/;
              var v8stackFormatter = function(stack, error) {
                if (typeof stack === "string")
                  return stack;
                if (error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }
                return formatNonError(error);
              };
              if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                var captureStackTrace = Error.captureStackTrace;
                shouldIgnore = function(line) {
                  return bluebirdFramePattern.test(line);
                };
                return function(receiver, ignoreUntil) {
                  Error.stackTraceLimit = Error.stackTraceLimit + 6;
                  captureStackTrace(receiver, ignoreUntil);
                  Error.stackTraceLimit = Error.stackTraceLimit - 6;
                };
              }
              var err = new Error();
              if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
                stackFramePattern = /@/;
                formatStack = v8stackFormatter;
                indentStackFrames = true;
                return function captureStackTrace(o) {
                  o.stack = new Error().stack;
                };
              }
              var hasStackAfterThrow;
              try {
                throw new Error();
              } catch (e) {
                hasStackAfterThrow = ("stack" in e);
              }
              if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                return function captureStackTrace(o) {
                  Error.stackTraceLimit = Error.stackTraceLimit + 6;
                  try {
                    throw new Error();
                  } catch (e) {
                    o.stack = e.stack;
                  }
                  Error.stackTraceLimit = Error.stackTraceLimit - 6;
                };
              }
              formatStack = function(stack, error) {
                if (typeof stack === "string")
                  return stack;
                if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }
                return formatNonError(error);
              };
              return null;
            })([]);
            var fireDomEvent;
            var fireGlobalEvent = (function() {
              if (util.isNode) {
                return function(name, reason, promise) {
                  if (name === "rejectionHandled") {
                    return process.emit(name, promise);
                  } else {
                    return process.emit(name, reason, promise);
                  }
                };
              } else {
                var customEventWorks = false;
                var anyEventWorks = true;
                try {
                  var ev = new self.CustomEvent("test");
                  customEventWorks = ev instanceof CustomEvent;
                } catch (e) {}
                if (!customEventWorks) {
                  try {
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent("testingtheevent", false, true, {});
                    self.dispatchEvent(event);
                  } catch (e) {
                    anyEventWorks = false;
                  }
                }
                if (anyEventWorks) {
                  fireDomEvent = function(type, detail) {
                    var event;
                    if (customEventWorks) {
                      event = new self.CustomEvent(type, {
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                      });
                    } else if (self.dispatchEvent) {
                      event = document.createEvent("CustomEvent");
                      event.initCustomEvent(type, false, true, detail);
                    }
                    return event ? !self.dispatchEvent(event) : false;
                  };
                }
                var toWindowMethodNameMap = {};
                toWindowMethodNameMap["unhandledRejection"] = ("on" + "unhandledRejection").toLowerCase();
                toWindowMethodNameMap["rejectionHandled"] = ("on" + "rejectionHandled").toLowerCase();
                return function(name, reason, promise) {
                  var methodName = toWindowMethodNameMap[name];
                  var method = self[methodName];
                  if (!method)
                    return false;
                  if (name === "rejectionHandled") {
                    method.call(self, promise);
                  } else {
                    method.call(self, reason, promise);
                  }
                  return true;
                };
              }
            })();
            if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
              warn = function(message) {
                console.warn(message);
              };
              if (util.isNode && process.stderr.isTTY) {
                warn = function(message) {
                  process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
                };
              } else if (!util.isNode && typeof(new Error().stack) === "string") {
                warn = function(message) {
                  console.warn("%c" + message, "color: red");
                };
              }
            }
            return CapturedTrace;
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        8: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(NEXT_FILTER) {
            var util = _dereq_("./util.js");
            var errors = _dereq_("./errors.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var keys = _dereq_("./es5.js").keys;
            var TypeError = errors.TypeError;
            function CatchFilter(instances, callback, promise) {
              this._instances = instances;
              this._callback = callback;
              this._promise = promise;
            }
            function safePredicate(predicate, e) {
              var safeObject = {};
              var retfilter = tryCatch(predicate).call(safeObject, e);
              if (retfilter === errorObj)
                return retfilter;
              var safeKeys = keys(safeObject);
              if (safeKeys.length) {
                errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
                return errorObj;
              }
              return retfilter;
            }
            CatchFilter.prototype.doFilter = function(e) {
              var cb = this._callback;
              var promise = this._promise;
              var boundTo = promise._boundValue();
              for (var i = 0,
                  len = this._instances.length; i < len; ++i) {
                var item = this._instances[i];
                var itemIsErrorType = item === Error || (item != null && item.prototype instanceof Error);
                if (itemIsErrorType && e instanceof item) {
                  var ret = tryCatch(cb).call(boundTo, e);
                  if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                  }
                  return ret;
                } else if (typeof item === "function" && !itemIsErrorType) {
                  var shouldHandle = safePredicate(item, e);
                  if (shouldHandle === errorObj) {
                    e = errorObj.e;
                    break;
                  } else if (shouldHandle) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                      NEXT_FILTER.e = ret.e;
                      return NEXT_FILTER;
                    }
                    return ret;
                  }
                }
              }
              NEXT_FILTER.e = e;
              return NEXT_FILTER;
            };
            return CatchFilter;
          };
        }, {
          "./errors.js": 13,
          "./es5.js": 14,
          "./util.js": 38
        }],
        9: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, CapturedTrace, isDebugging) {
            var contextStack = [];
            function Context() {
              this._trace = new CapturedTrace(peekContext());
            }
            Context.prototype._pushContext = function() {
              if (!isDebugging())
                return;
              if (this._trace !== undefined) {
                contextStack.push(this._trace);
              }
            };
            Context.prototype._popContext = function() {
              if (!isDebugging())
                return;
              if (this._trace !== undefined) {
                contextStack.pop();
              }
            };
            function createContext() {
              if (isDebugging())
                return new Context();
            }
            function peekContext() {
              var lastIndex = contextStack.length - 1;
              if (lastIndex >= 0) {
                return contextStack[lastIndex];
              }
              return undefined;
            }
            Promise.prototype._peekContext = peekContext;
            Promise.prototype._pushContext = Context.prototype._pushContext;
            Promise.prototype._popContext = Context.prototype._popContext;
            return createContext;
          };
        }, {}],
        10: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, CapturedTrace) {
            var getDomain = Promise._getDomain;
            var async = _dereq_("./async.js");
            var Warning = _dereq_("./errors.js").Warning;
            var util = _dereq_("./util.js");
            var canAttachTrace = util.canAttachTrace;
            var unhandledRejectionHandled;
            var possiblyUnhandledRejection;
            var debugging = false || (util.isNode && (!!process.env["BLUEBIRD_DEBUG"] || process.env["NODE_ENV"] === "development"));
            if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0)
              debugging = false;
            if (debugging) {
              async.disableTrampolineIfNecessary();
            }
            Promise.prototype._ignoreRejections = function() {
              this._unsetRejectionIsUnhandled();
              this._bitField = this._bitField | 16777216;
            };
            Promise.prototype._ensurePossibleRejectionHandled = function() {
              if ((this._bitField & 16777216) !== 0)
                return;
              this._setRejectionIsUnhandled();
              async.invokeLater(this._notifyUnhandledRejection, this, undefined);
            };
            Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
              CapturedTrace.fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
            };
            Promise.prototype._notifyUnhandledRejection = function() {
              if (this._isRejectionUnhandled()) {
                var reason = this._getCarriedStackTrace() || this._settledValue;
                this._setUnhandledRejectionIsNotified();
                CapturedTrace.fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
              }
            };
            Promise.prototype._setUnhandledRejectionIsNotified = function() {
              this._bitField = this._bitField | 524288;
            };
            Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
              this._bitField = this._bitField & (~524288);
            };
            Promise.prototype._isUnhandledRejectionNotified = function() {
              return (this._bitField & 524288) > 0;
            };
            Promise.prototype._setRejectionIsUnhandled = function() {
              this._bitField = this._bitField | 2097152;
            };
            Promise.prototype._unsetRejectionIsUnhandled = function() {
              this._bitField = this._bitField & (~2097152);
              if (this._isUnhandledRejectionNotified()) {
                this._unsetUnhandledRejectionIsNotified();
                this._notifyUnhandledRejectionIsHandled();
              }
            };
            Promise.prototype._isRejectionUnhandled = function() {
              return (this._bitField & 2097152) > 0;
            };
            Promise.prototype._setCarriedStackTrace = function(capturedTrace) {
              this._bitField = this._bitField | 1048576;
              this._fulfillmentHandler0 = capturedTrace;
            };
            Promise.prototype._isCarryingStackTrace = function() {
              return (this._bitField & 1048576) > 0;
            };
            Promise.prototype._getCarriedStackTrace = function() {
              return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : undefined;
            };
            Promise.prototype._captureStackTrace = function() {
              if (debugging) {
                this._trace = new CapturedTrace(this._peekContext());
              }
              return this;
            };
            Promise.prototype._attachExtraTrace = function(error, ignoreSelf) {
              if (debugging && canAttachTrace(error)) {
                var trace = this._trace;
                if (trace !== undefined) {
                  if (ignoreSelf)
                    trace = trace._parent;
                }
                if (trace !== undefined) {
                  trace.attachExtraTrace(error);
                } else if (!error.__stackCleaned__) {
                  var parsed = CapturedTrace.parseStackAndMessage(error);
                  util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                  util.notEnumerableProp(error, "__stackCleaned__", true);
                }
              }
            };
            Promise.prototype._warn = function(message) {
              var warning = new Warning(message);
              var ctx = this._peekContext();
              if (ctx) {
                ctx.attachExtraTrace(warning);
              } else {
                var parsed = CapturedTrace.parseStackAndMessage(warning);
                warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
              }
              CapturedTrace.formatAndLogError(warning, "");
            };
            Promise.onPossiblyUnhandledRejection = function(fn) {
              var domain = getDomain();
              possiblyUnhandledRejection = typeof fn === "function" ? (domain === null ? fn : domain.bind(fn)) : undefined;
            };
            Promise.onUnhandledRejectionHandled = function(fn) {
              var domain = getDomain();
              unhandledRejectionHandled = typeof fn === "function" ? (domain === null ? fn : domain.bind(fn)) : undefined;
            };
            Promise.longStackTraces = function() {
              if (async.haveItemsQueued() && debugging === false) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
              }
              debugging = CapturedTrace.isSupported();
              if (debugging) {
                async.disableTrampolineIfNecessary();
              }
            };
            Promise.hasLongStackTraces = function() {
              return debugging && CapturedTrace.isSupported();
            };
            if (!CapturedTrace.isSupported()) {
              Promise.longStackTraces = function() {};
              debugging = false;
            }
            return function() {
              return debugging;
            };
          };
        }, {
          "./async.js": 2,
          "./errors.js": 13,
          "./util.js": 38
        }],
        11: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var isPrimitive = util.isPrimitive;
          module.exports = function(Promise) {
            var returner = function() {
              return this;
            };
            var thrower = function() {
              throw this;
            };
            var returnUndefined = function() {};
            var throwUndefined = function() {
              throw undefined;
            };
            var wrapper = function(value, action) {
              if (action === 1) {
                return function() {
                  throw value;
                };
              } else if (action === 2) {
                return function() {
                  return value;
                };
              }
            };
            Promise.prototype["return"] = Promise.prototype.thenReturn = function(value) {
              if (value === undefined)
                return this.then(returnUndefined);
              if (isPrimitive(value)) {
                return this._then(wrapper(value, 2), undefined, undefined, undefined, undefined);
              } else if (value instanceof Promise) {
                value._ignoreRejections();
              }
              return this._then(returner, undefined, undefined, value, undefined);
            };
            Promise.prototype["throw"] = Promise.prototype.thenThrow = function(reason) {
              if (reason === undefined)
                return this.then(throwUndefined);
              if (isPrimitive(reason)) {
                return this._then(wrapper(reason, 1), undefined, undefined, undefined, undefined);
              }
              return this._then(thrower, undefined, undefined, reason, undefined);
            };
          };
        }, {"./util.js": 38}],
        12: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var PromiseReduce = Promise.reduce;
            Promise.prototype.each = function(fn) {
              return PromiseReduce(this, fn, null, INTERNAL);
            };
            Promise.each = function(promises, fn) {
              return PromiseReduce(promises, fn, null, INTERNAL);
            };
          };
        }, {}],
        13: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5.js");
          var Objectfreeze = es5.freeze;
          var util = _dereq_("./util.js");
          var inherits = util.inherits;
          var notEnumerableProp = util.notEnumerableProp;
          function subError(nameProperty, defaultMessage) {
            function SubError(message) {
              if (!(this instanceof SubError))
                return new SubError(message);
              notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
              notEnumerableProp(this, "name", nameProperty);
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              } else {
                Error.call(this);
              }
            }
            inherits(SubError, Error);
            return SubError;
          }
          var _TypeError,
              _RangeError;
          var Warning = subError("Warning", "warning");
          var CancellationError = subError("CancellationError", "cancellation error");
          var TimeoutError = subError("TimeoutError", "timeout error");
          var AggregateError = subError("AggregateError", "aggregate error");
          try {
            _TypeError = TypeError;
            _RangeError = RangeError;
          } catch (e) {
            _TypeError = subError("TypeError", "type error");
            _RangeError = subError("RangeError", "range error");
          }
          var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
          for (var i = 0; i < methods.length; ++i) {
            if (typeof Array.prototype[methods[i]] === "function") {
              AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
            }
          }
          es5.defineProperty(AggregateError.prototype, "length", {
            value: 0,
            configurable: false,
            writable: true,
            enumerable: true
          });
          AggregateError.prototype["isOperational"] = true;
          var level = 0;
          AggregateError.prototype.toString = function() {
            var indent = Array(level * 4 + 1).join(" ");
            var ret = "\n" + indent + "AggregateError of:" + "\n";
            level++;
            indent = Array(level * 4 + 1).join(" ");
            for (var i = 0; i < this.length; ++i) {
              var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
              var lines = str.split("\n");
              for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
              }
              str = lines.join("\n");
              ret += str + "\n";
            }
            level--;
            return ret;
          };
          function OperationalError(message) {
            if (!(this instanceof OperationalError))
              return new OperationalError(message);
            notEnumerableProp(this, "name", "OperationalError");
            notEnumerableProp(this, "message", message);
            this.cause = message;
            this["isOperational"] = true;
            if (message instanceof Error) {
              notEnumerableProp(this, "message", message.message);
              notEnumerableProp(this, "stack", message.stack);
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }
          inherits(OperationalError, Error);
          var errorTypes = Error["__BluebirdErrorTypes__"];
          if (!errorTypes) {
            errorTypes = Objectfreeze({
              CancellationError: CancellationError,
              TimeoutError: TimeoutError,
              OperationalError: OperationalError,
              RejectionError: OperationalError,
              AggregateError: AggregateError
            });
            notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
          }
          module.exports = {
            Error: Error,
            TypeError: _TypeError,
            RangeError: _RangeError,
            CancellationError: errorTypes.CancellationError,
            OperationalError: errorTypes.OperationalError,
            TimeoutError: errorTypes.TimeoutError,
            AggregateError: errorTypes.AggregateError,
            Warning: Warning
          };
        }, {
          "./es5.js": 14,
          "./util.js": 38
        }],
        14: [function(_dereq_, module, exports) {
          var isES5 = (function() {
            "use strict";
            return this === undefined;
          })();
          if (isES5) {
            module.exports = {
              freeze: Object.freeze,
              defineProperty: Object.defineProperty,
              getDescriptor: Object.getOwnPropertyDescriptor,
              keys: Object.keys,
              names: Object.getOwnPropertyNames,
              getPrototypeOf: Object.getPrototypeOf,
              isArray: Array.isArray,
              isES5: isES5,
              propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
              }
            };
          } else {
            var has = {}.hasOwnProperty;
            var str = {}.toString;
            var proto = {}.constructor.prototype;
            var ObjectKeys = function(o) {
              var ret = [];
              for (var key in o) {
                if (has.call(o, key)) {
                  ret.push(key);
                }
              }
              return ret;
            };
            var ObjectGetDescriptor = function(o, key) {
              return {value: o[key]};
            };
            var ObjectDefineProperty = function(o, key, desc) {
              o[key] = desc.value;
              return o;
            };
            var ObjectFreeze = function(obj) {
              return obj;
            };
            var ObjectGetPrototypeOf = function(obj) {
              try {
                return Object(obj).constructor.prototype;
              } catch (e) {
                return proto;
              }
            };
            var ArrayIsArray = function(obj) {
              try {
                return str.call(obj) === "[object Array]";
              } catch (e) {
                return false;
              }
            };
            module.exports = {
              isArray: ArrayIsArray,
              keys: ObjectKeys,
              names: ObjectKeys,
              defineProperty: ObjectDefineProperty,
              getDescriptor: ObjectGetDescriptor,
              freeze: ObjectFreeze,
              getPrototypeOf: ObjectGetPrototypeOf,
              isES5: isES5,
              propertyIsWritable: function() {
                return true;
              }
            };
          }
        }, {}],
        15: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var PromiseMap = Promise.map;
            Promise.prototype.filter = function(fn, options) {
              return PromiseMap(this, fn, options, INTERNAL);
            };
            Promise.filter = function(promises, fn, options) {
              return PromiseMap(promises, fn, options, INTERNAL);
            };
          };
        }, {}],
        16: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
            var util = _dereq_("./util.js");
            var isPrimitive = util.isPrimitive;
            var thrower = util.thrower;
            function returnThis() {
              return this;
            }
            function throwThis() {
              throw this;
            }
            function return$(r) {
              return function() {
                return r;
              };
            }
            function throw$(r) {
              return function() {
                throw r;
              };
            }
            function promisedFinally(ret, reasonOrValue, isFulfilled) {
              var then;
              if (isPrimitive(reasonOrValue)) {
                then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
              } else {
                then = isFulfilled ? returnThis : throwThis;
              }
              return ret._then(then, thrower, undefined, reasonOrValue, undefined);
            }
            function finallyHandler(reasonOrValue) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundValue()) : handler();
              if (ret !== undefined) {
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());
                }
              }
              if (promise.isRejected()) {
                NEXT_FILTER.e = reasonOrValue;
                return NEXT_FILTER;
              } else {
                return reasonOrValue;
              }
            }
            function tapHandler(value) {
              var promise = this.promise;
              var handler = this.handler;
              var ret = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);
              if (ret !== undefined) {
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  return promisedFinally(maybePromise, value, true);
                }
              }
              return value;
            }
            Promise.prototype._passThroughHandler = function(handler, isFinally) {
              if (typeof handler !== "function")
                return this.then();
              var promiseAndHandler = {
                promise: this,
                handler: handler
              };
              return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : undefined, undefined, promiseAndHandler, undefined);
            };
            Promise.prototype.lastly = Promise.prototype["finally"] = function(handler) {
              return this._passThroughHandler(handler, true);
            };
            Promise.prototype.tap = function(handler) {
              return this._passThroughHandler(handler, false);
            };
          };
        }, {"./util.js": 38}],
        17: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise) {
            var errors = _dereq_("./errors.js");
            var TypeError = errors.TypeError;
            var util = _dereq_("./util.js");
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            var yieldHandlers = [];
            function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
              for (var i = 0; i < yieldHandlers.length; ++i) {
                traceParent._pushContext();
                var result = tryCatch(yieldHandlers[i])(value);
                traceParent._popContext();
                if (result === errorObj) {
                  traceParent._pushContext();
                  var ret = Promise.reject(errorObj.e);
                  traceParent._popContext();
                  return ret;
                }
                var maybePromise = tryConvertToPromise(result, traceParent);
                if (maybePromise instanceof Promise)
                  return maybePromise;
              }
              return null;
            }
            function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
              var promise = this._promise = new Promise(INTERNAL);
              promise._captureStackTrace();
              this._stack = stack;
              this._generatorFunction = generatorFunction;
              this._receiver = receiver;
              this._generator = undefined;
              this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
            }
            PromiseSpawn.prototype.promise = function() {
              return this._promise;
            };
            PromiseSpawn.prototype._run = function() {
              this._generator = this._generatorFunction.call(this._receiver);
              this._receiver = this._generatorFunction = undefined;
              this._next(undefined);
            };
            PromiseSpawn.prototype._continue = function(result) {
              if (result === errorObj) {
                return this._promise._rejectCallback(result.e, false, true);
              }
              var value = result.value;
              if (result.done === true) {
                this._promise._resolveCallback(value);
              } else {
                var maybePromise = tryConvertToPromise(value, this._promise);
                if (!(maybePromise instanceof Promise)) {
                  maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                  if (maybePromise === null) {
                    this._throw(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                  }
                }
                maybePromise._then(this._next, this._throw, undefined, this, null);
              }
            };
            PromiseSpawn.prototype._throw = function(reason) {
              this._promise._attachExtraTrace(reason);
              this._promise._pushContext();
              var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
              this._promise._popContext();
              this._continue(result);
            };
            PromiseSpawn.prototype._next = function(value) {
              this._promise._pushContext();
              var result = tryCatch(this._generator.next).call(this._generator, value);
              this._promise._popContext();
              this._continue(result);
            };
            Promise.coroutine = function(generatorFunction, options) {
              if (typeof generatorFunction !== "function") {
                throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
              }
              var yieldHandler = Object(options).yieldHandler;
              var PromiseSpawn$ = PromiseSpawn;
              var stack = new Error().stack;
              return function() {
                var generator = generatorFunction.apply(this, arguments);
                var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
                spawn._generator = generator;
                spawn._next(undefined);
                return spawn.promise();
              };
            };
            Promise.coroutine.addYieldHandler = function(fn) {
              if (typeof fn !== "function")
                throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              yieldHandlers.push(fn);
            };
            Promise.spawn = function(generatorFunction) {
              if (typeof generatorFunction !== "function") {
                return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
              }
              var spawn = new PromiseSpawn(generatorFunction, this);
              var ret = spawn.promise();
              spawn._run(Promise.spawn);
              return ret;
            };
          };
        }, {
          "./errors.js": 13,
          "./util.js": 38
        }],
        18: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
            var util = _dereq_("./util.js");
            var canEvaluate = util.canEvaluate;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var reject;
            if (!true) {
              if (canEvaluate) {
                var thenCallback = function(i) {
                  return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
                };
                var caller = function(count) {
                  var values = [];
                  for (var i = 1; i <= count; ++i)
                    values.push("holder.p" + i);
                  return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
                };
                var thenCallbacks = [];
                var callers = [undefined];
                for (var i = 1; i <= 5; ++i) {
                  thenCallbacks.push(thenCallback(i));
                  callers.push(caller(i));
                }
                var Holder = function(total, fn) {
                  this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                  this.fn = fn;
                  this.total = total;
                  this.now = 0;
                };
                Holder.prototype.callers = callers;
                Holder.prototype.checkFulfillment = function(promise) {
                  var now = this.now;
                  now++;
                  var total = this.total;
                  if (now >= total) {
                    var handler = this.callers[total];
                    promise._pushContext();
                    var ret = tryCatch(handler)(this);
                    promise._popContext();
                    if (ret === errorObj) {
                      promise._rejectCallback(ret.e, false, true);
                    } else {
                      promise._resolveCallback(ret);
                    }
                  } else {
                    this.now = now;
                  }
                };
                var reject = function(reason) {
                  this._reject(reason);
                };
              }
            }
            Promise.join = function() {
              var last = arguments.length - 1;
              var fn;
              if (last > 0 && typeof arguments[last] === "function") {
                fn = arguments[last];
                if (!true) {
                  if (last < 6 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var holder = new Holder(last, fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                      var maybePromise = tryConvertToPromise(arguments[i], ret);
                      if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        if (maybePromise._isPending()) {
                          maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                        } else if (maybePromise._isFulfilled()) {
                          callbacks[i].call(ret, maybePromise._value(), holder);
                        } else {
                          ret._reject(maybePromise._reason());
                        }
                      } else {
                        callbacks[i].call(ret, maybePromise, holder);
                      }
                    }
                    return ret;
                  }
                }
              }
              var $_len = arguments.length;
              var args = new Array($_len);
              for (var $_i = 0; $_i < $_len; ++$_i) {
                args[$_i] = arguments[$_i];
              }
              if (fn)
                args.pop();
              var ret = new PromiseArray(args).promise();
              return fn !== undefined ? ret.spread(fn) : ret;
            };
          };
        }, {"./util.js": 38}],
        19: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
            var getDomain = Promise._getDomain;
            var async = _dereq_("./async.js");
            var util = _dereq_("./util.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var PENDING = {};
            var EMPTY_ARRAY = [];
            function MappingPromiseArray(promises, fn, limit, _filter) {
              this.constructor$(promises);
              this._promise._captureStackTrace();
              var domain = getDomain();
              this._callback = domain === null ? fn : domain.bind(fn);
              this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
              this._limit = limit;
              this._inFlight = 0;
              this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
              async.invoke(init, this, undefined);
            }
            util.inherits(MappingPromiseArray, PromiseArray);
            function init() {
              this._init$(undefined, -2);
            }
            MappingPromiseArray.prototype._init = function() {};
            MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var values = this._values;
              var length = this.length();
              var preservedValues = this._preservedValues;
              var limit = this._limit;
              if (values[index] === PENDING) {
                values[index] = value;
                if (limit >= 1) {
                  this._inFlight--;
                  this._drainQueue();
                  if (this._isResolved())
                    return;
                }
              } else {
                if (limit >= 1 && this._inFlight >= limit) {
                  values[index] = value;
                  this._queue.push(index);
                  return;
                }
                if (preservedValues !== null)
                  preservedValues[index] = value;
                var callback = this._callback;
                var receiver = this._promise._boundValue();
                this._promise._pushContext();
                var ret = tryCatch(callback).call(receiver, value, index, length);
                this._promise._popContext();
                if (ret === errorObj)
                  return this._reject(ret.e);
                var maybePromise = tryConvertToPromise(ret, this._promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  if (maybePromise._isPending()) {
                    if (limit >= 1)
                      this._inFlight++;
                    values[index] = PENDING;
                    return maybePromise._proxyPromiseArray(this, index);
                  } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                  } else {
                    return this._reject(maybePromise._reason());
                  }
                }
                values[index] = ret;
              }
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= length) {
                if (preservedValues !== null) {
                  this._filter(values, preservedValues);
                } else {
                  this._resolve(values);
                }
              }
            };
            MappingPromiseArray.prototype._drainQueue = function() {
              var queue = this._queue;
              var limit = this._limit;
              var values = this._values;
              while (queue.length > 0 && this._inFlight < limit) {
                if (this._isResolved())
                  return;
                var index = queue.pop();
                this._promiseFulfilled(values[index], index);
              }
            };
            MappingPromiseArray.prototype._filter = function(booleans, values) {
              var len = values.length;
              var ret = new Array(len);
              var j = 0;
              for (var i = 0; i < len; ++i) {
                if (booleans[i])
                  ret[j++] = values[i];
              }
              ret.length = j;
              this._resolve(ret);
            };
            MappingPromiseArray.prototype.preservedValues = function() {
              return this._preservedValues;
            };
            function map(promises, fn, options, _filter) {
              var limit = typeof options === "object" && options !== null ? options.concurrency : 0;
              limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
              return new MappingPromiseArray(promises, fn, limit, _filter);
            }
            Promise.prototype.map = function(fn, options) {
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              return map(this, fn, options, null).promise();
            };
            Promise.map = function(promises, fn, options, _filter) {
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              return map(promises, fn, options, _filter).promise();
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        20: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util.js");
            var tryCatch = util.tryCatch;
            Promise.method = function(fn) {
              if (typeof fn !== "function") {
                throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              }
              return function() {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                ret._pushContext();
                var value = tryCatch(fn).apply(this, arguments);
                ret._popContext();
                ret._resolveFromSyncValue(value);
                return ret;
              };
            };
            Promise.attempt = Promise["try"] = function(fn, args, ctx) {
              if (typeof fn !== "function") {
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              }
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              ret._pushContext();
              var value = util.isArray(args) ? tryCatch(fn).apply(ctx, args) : tryCatch(fn).call(ctx, args);
              ret._popContext();
              ret._resolveFromSyncValue(value);
              return ret;
            };
            Promise.prototype._resolveFromSyncValue = function(value) {
              if (value === util.errorObj) {
                this._rejectCallback(value.e, false, true);
              } else {
                this._resolveCallback(value, true);
              }
            };
          };
        }, {"./util.js": 38}],
        21: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            function spreadAdapter(val, nodeback) {
              var promise = this;
              if (!util.isArray(val))
                return successAdapter.call(promise, val, nodeback);
              var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            function successAdapter(val, nodeback) {
              var promise = this;
              var receiver = promise._boundValue();
              var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            function errorAdapter(reason, nodeback) {
              var promise = this;
              if (!reason) {
                var target = promise._target();
                var newReason = target._getCarriedStackTrace();
                newReason.cause = reason;
                reason = newReason;
              }
              var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }
            Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
              if (typeof nodeback == "function") {
                var adapter = successAdapter;
                if (options !== undefined && Object(options).spread) {
                  adapter = spreadAdapter;
                }
                this._then(adapter, errorAdapter, undefined, this, nodeback);
              }
              return this;
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        22: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray) {
            var util = _dereq_("./util.js");
            var async = _dereq_("./async.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            Promise.prototype.progressed = function(handler) {
              return this._then(undefined, undefined, handler, undefined, undefined);
            };
            Promise.prototype._progress = function(progressValue) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._target()._progressUnchecked(progressValue);
            };
            Promise.prototype._progressHandlerAt = function(index) {
              return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
            };
            Promise.prototype._doProgressWith = function(progression) {
              var progressValue = progression.value;
              var handler = progression.handler;
              var promise = progression.promise;
              var receiver = progression.receiver;
              var ret = tryCatch(handler).call(receiver, progressValue);
              if (ret === errorObj) {
                if (ret.e != null && ret.e.name !== "StopProgressPropagation") {
                  var trace = util.canAttachTrace(ret.e) ? ret.e : new Error(util.toString(ret.e));
                  promise._attachExtraTrace(trace);
                  promise._progress(ret.e);
                }
              } else if (ret instanceof Promise) {
                ret._then(promise._progress, null, null, promise, undefined);
              } else {
                promise._progress(ret);
              }
            };
            Promise.prototype._progressUnchecked = function(progressValue) {
              var len = this._length();
              var progress = this._progress;
              for (var i = 0; i < len; i++) {
                var handler = this._progressHandlerAt(i);
                var promise = this._promiseAt(i);
                if (!(promise instanceof Promise)) {
                  var receiver = this._receiverAt(i);
                  if (typeof handler === "function") {
                    handler.call(receiver, progressValue, promise);
                  } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {
                    receiver._promiseProgressed(progressValue, promise);
                  }
                  continue;
                }
                if (typeof handler === "function") {
                  async.invoke(this._doProgressWith, this, {
                    handler: handler,
                    promise: promise,
                    receiver: this._receiverAt(i),
                    value: progressValue
                  });
                } else {
                  async.invoke(progress, promise, progressValue);
                }
              }
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        23: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function() {
            var makeSelfResolutionError = function() {
              return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
            };
            var reflect = function() {
              return new Promise.PromiseInspection(this._target());
            };
            var apiRejection = function(msg) {
              return Promise.reject(new TypeError(msg));
            };
            var util = _dereq_("./util.js");
            var getDomain;
            if (util.isNode) {
              getDomain = function() {
                var ret = process.domain;
                if (ret === undefined)
                  ret = null;
                return ret;
              };
            } else {
              getDomain = function() {
                return null;
              };
            }
            util.notEnumerableProp(Promise, "_getDomain", getDomain);
            var UNDEFINED_BINDING = {};
            var async = _dereq_("./async.js");
            var errors = _dereq_("./errors.js");
            var TypeError = Promise.TypeError = errors.TypeError;
            Promise.RangeError = errors.RangeError;
            Promise.CancellationError = errors.CancellationError;
            Promise.TimeoutError = errors.TimeoutError;
            Promise.OperationalError = errors.OperationalError;
            Promise.RejectionError = errors.OperationalError;
            Promise.AggregateError = errors.AggregateError;
            var INTERNAL = function() {};
            var APPLY = {};
            var NEXT_FILTER = {e: null};
            var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
            var PromiseArray = _dereq_("./promise_array.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            var CapturedTrace = _dereq_("./captured_trace.js")();
            var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
            var createContext = _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
            var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
            var PromiseResolver = _dereq_("./promise_resolver.js");
            var nodebackForPromise = PromiseResolver._nodebackForPromise;
            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            function Promise(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
              }
              if (this.constructor !== Promise) {
                throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
              }
              this._bitField = 0;
              this._fulfillmentHandler0 = undefined;
              this._rejectionHandler0 = undefined;
              this._progressHandler0 = undefined;
              this._promise0 = undefined;
              this._receiver0 = undefined;
              this._settledValue = undefined;
              if (resolver !== INTERNAL)
                this._resolveFromResolver(resolver);
            }
            Promise.prototype.toString = function() {
              return "[object Promise]";
            };
            Promise.prototype.caught = Promise.prototype["catch"] = function(fn) {
              var len = arguments.length;
              if (len > 1) {
                var catchInstances = new Array(len - 1),
                    j = 0,
                    i;
                for (i = 0; i < len - 1; ++i) {
                  var item = arguments[i];
                  if (typeof item === "function") {
                    catchInstances[j++] = item;
                  } else {
                    return Promise.reject(new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
                  }
                }
                catchInstances.length = j;
                fn = arguments[i];
                var catchFilter = new CatchFilter(catchInstances, fn, this);
                return this._then(undefined, catchFilter.doFilter, undefined, catchFilter, undefined);
              }
              return this._then(undefined, fn, undefined, undefined, undefined);
            };
            Promise.prototype.reflect = function() {
              return this._then(reflect, reflect, undefined, this, undefined);
            };
            Promise.prototype.then = function(didFulfill, didReject, didProgress) {
              if (isDebugging() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
                var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
                if (arguments.length > 1) {
                  msg += ", " + util.classString(didReject);
                }
                this._warn(msg);
              }
              return this._then(didFulfill, didReject, didProgress, undefined, undefined);
            };
            Promise.prototype.done = function(didFulfill, didReject, didProgress) {
              var promise = this._then(didFulfill, didReject, didProgress, undefined, undefined);
              promise._setIsFinal();
            };
            Promise.prototype.spread = function(didFulfill, didReject) {
              return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
            };
            Promise.prototype.isCancellable = function() {
              return !this.isResolved() && this._cancellable();
            };
            Promise.prototype.toJSON = function() {
              var ret = {
                isFulfilled: false,
                isRejected: false,
                fulfillmentValue: undefined,
                rejectionReason: undefined
              };
              if (this.isFulfilled()) {
                ret.fulfillmentValue = this.value();
                ret.isFulfilled = true;
              } else if (this.isRejected()) {
                ret.rejectionReason = this.reason();
                ret.isRejected = true;
              }
              return ret;
            };
            Promise.prototype.all = function() {
              return new PromiseArray(this).promise();
            };
            Promise.prototype.error = function(fn) {
              return this.caught(util.originatesFromRejection, fn);
            };
            Promise.is = function(val) {
              return val instanceof Promise;
            };
            Promise.fromNode = function(fn) {
              var ret = new Promise(INTERNAL);
              var result = tryCatch(fn)(nodebackForPromise(ret));
              if (result === errorObj) {
                ret._rejectCallback(result.e, true, true);
              }
              return ret;
            };
            Promise.all = function(promises) {
              return new PromiseArray(promises).promise();
            };
            Promise.defer = Promise.pending = function() {
              var promise = new Promise(INTERNAL);
              return new PromiseResolver(promise);
            };
            Promise.cast = function(obj) {
              var ret = tryConvertToPromise(obj);
              if (!(ret instanceof Promise)) {
                var val = ret;
                ret = new Promise(INTERNAL);
                ret._fulfillUnchecked(val);
              }
              return ret;
            };
            Promise.resolve = Promise.fulfilled = Promise.cast;
            Promise.reject = Promise.rejected = function(reason) {
              var ret = new Promise(INTERNAL);
              ret._captureStackTrace();
              ret._rejectCallback(reason, true);
              return ret;
            };
            Promise.setScheduler = function(fn) {
              if (typeof fn !== "function")
                throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              var prev = async._schedule;
              async._schedule = fn;
              return prev;
            };
            Promise.prototype._then = function(didFulfill, didReject, didProgress, receiver, internalData) {
              var haveInternalData = internalData !== undefined;
              var ret = haveInternalData ? internalData : new Promise(INTERNAL);
              if (!haveInternalData) {
                ret._propagateFrom(this, 4 | 1);
                ret._captureStackTrace();
              }
              var target = this._target();
              if (target !== this) {
                if (receiver === undefined)
                  receiver = this._boundTo;
                if (!haveInternalData)
                  ret._setIsMigrated();
              }
              var callbackIndex = target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver, getDomain());
              if (target._isResolved() && !target._isSettlePromisesQueued()) {
                async.invoke(target._settlePromiseAtPostResolution, target, callbackIndex);
              }
              return ret;
            };
            Promise.prototype._settlePromiseAtPostResolution = function(index) {
              if (this._isRejectionUnhandled())
                this._unsetRejectionIsUnhandled();
              this._settlePromiseAt(index);
            };
            Promise.prototype._length = function() {
              return this._bitField & 131071;
            };
            Promise.prototype._isFollowingOrFulfilledOrRejected = function() {
              return (this._bitField & 939524096) > 0;
            };
            Promise.prototype._isFollowing = function() {
              return (this._bitField & 536870912) === 536870912;
            };
            Promise.prototype._setLength = function(len) {
              this._bitField = (this._bitField & -131072) | (len & 131071);
            };
            Promise.prototype._setFulfilled = function() {
              this._bitField = this._bitField | 268435456;
            };
            Promise.prototype._setRejected = function() {
              this._bitField = this._bitField | 134217728;
            };
            Promise.prototype._setFollowing = function() {
              this._bitField = this._bitField | 536870912;
            };
            Promise.prototype._setIsFinal = function() {
              this._bitField = this._bitField | 33554432;
            };
            Promise.prototype._isFinal = function() {
              return (this._bitField & 33554432) > 0;
            };
            Promise.prototype._cancellable = function() {
              return (this._bitField & 67108864) > 0;
            };
            Promise.prototype._setCancellable = function() {
              this._bitField = this._bitField | 67108864;
            };
            Promise.prototype._unsetCancellable = function() {
              this._bitField = this._bitField & (~67108864);
            };
            Promise.prototype._setIsMigrated = function() {
              this._bitField = this._bitField | 4194304;
            };
            Promise.prototype._unsetIsMigrated = function() {
              this._bitField = this._bitField & (~4194304);
            };
            Promise.prototype._isMigrated = function() {
              return (this._bitField & 4194304) > 0;
            };
            Promise.prototype._receiverAt = function(index) {
              var ret = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];
              if (ret === UNDEFINED_BINDING) {
                return undefined;
              } else if (ret === undefined && this._isBound()) {
                return this._boundValue();
              }
              return ret;
            };
            Promise.prototype._promiseAt = function(index) {
              return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];
            };
            Promise.prototype._fulfillmentHandlerAt = function(index) {
              return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];
            };
            Promise.prototype._rejectionHandlerAt = function(index) {
              return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];
            };
            Promise.prototype._boundValue = function() {
              var ret = this._boundTo;
              if (ret !== undefined) {
                if (ret instanceof Promise) {
                  if (ret.isFulfilled()) {
                    return ret.value();
                  } else {
                    return undefined;
                  }
                }
              }
              return ret;
            };
            Promise.prototype._migrateCallbacks = function(follower, index) {
              var fulfill = follower._fulfillmentHandlerAt(index);
              var reject = follower._rejectionHandlerAt(index);
              var progress = follower._progressHandlerAt(index);
              var promise = follower._promiseAt(index);
              var receiver = follower._receiverAt(index);
              if (promise instanceof Promise)
                promise._setIsMigrated();
              if (receiver === undefined)
                receiver = UNDEFINED_BINDING;
              this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
            };
            Promise.prototype._addCallbacks = function(fulfill, reject, progress, promise, receiver, domain) {
              var index = this._length();
              if (index >= 131071 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promise;
                if (receiver !== undefined)
                  this._receiver0 = receiver;
                if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                  this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);
                }
                if (typeof reject === "function") {
                  this._rejectionHandler0 = domain === null ? reject : domain.bind(reject);
                }
                if (typeof progress === "function") {
                  this._progressHandler0 = domain === null ? progress : domain.bind(progress);
                }
              } else {
                var base = index * 5 - 5;
                this[base + 3] = promise;
                this[base + 4] = receiver;
                if (typeof fulfill === "function") {
                  this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);
                }
                if (typeof reject === "function") {
                  this[base + 1] = domain === null ? reject : domain.bind(reject);
                }
                if (typeof progress === "function") {
                  this[base + 2] = domain === null ? progress : domain.bind(progress);
                }
              }
              this._setLength(index + 1);
              return index;
            };
            Promise.prototype._setProxyHandlers = function(receiver, promiseSlotValue) {
              var index = this._length();
              if (index >= 131071 - 5) {
                index = 0;
                this._setLength(0);
              }
              if (index === 0) {
                this._promise0 = promiseSlotValue;
                this._receiver0 = receiver;
              } else {
                var base = index * 5 - 5;
                this[base + 3] = promiseSlotValue;
                this[base + 4] = receiver;
              }
              this._setLength(index + 1);
            };
            Promise.prototype._proxyPromiseArray = function(promiseArray, index) {
              this._setProxyHandlers(promiseArray, index);
            };
            Promise.prototype._resolveCallback = function(value, shouldBind) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              if (value === this)
                return this._rejectCallback(makeSelfResolutionError(), false, true);
              var maybePromise = tryConvertToPromise(value, this);
              if (!(maybePromise instanceof Promise))
                return this._fulfill(value);
              var propagationFlags = 1 | (shouldBind ? 4 : 0);
              this._propagateFrom(maybePromise, propagationFlags);
              var promise = maybePromise._target();
              if (promise._isPending()) {
                var len = this._length();
                for (var i = 0; i < len; ++i) {
                  promise._migrateCallbacks(this, i);
                }
                this._setFollowing();
                this._setLength(0);
                this._setFollowee(promise);
              } else if (promise._isFulfilled()) {
                this._fulfillUnchecked(promise._value());
              } else {
                this._rejectUnchecked(promise._reason(), promise._getCarriedStackTrace());
              }
            };
            Promise.prototype._rejectCallback = function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
              if (!shouldNotMarkOriginatingFromRejection) {
                util.markAsOriginatingFromRejection(reason);
              }
              var trace = util.ensureErrorObject(reason);
              var hasStack = trace === reason;
              this._attachExtraTrace(trace, synchronous ? hasStack : false);
              this._reject(reason, hasStack ? undefined : trace);
            };
            Promise.prototype._resolveFromResolver = function(resolver) {
              var promise = this;
              this._captureStackTrace();
              this._pushContext();
              var synchronous = true;
              var r = tryCatch(resolver)(function(value) {
                if (promise === null)
                  return;
                promise._resolveCallback(value);
                promise = null;
              }, function(reason) {
                if (promise === null)
                  return;
                promise._rejectCallback(reason, synchronous);
                promise = null;
              });
              synchronous = false;
              this._popContext();
              if (r !== undefined && r === errorObj && promise !== null) {
                promise._rejectCallback(r.e, true, true);
                promise = null;
              }
            };
            Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
              if (promise._isRejected())
                return;
              promise._pushContext();
              var x;
              if (receiver === APPLY && !this._isRejected()) {
                x = tryCatch(handler).apply(this._boundValue(), value);
              } else {
                x = tryCatch(handler).call(receiver, value);
              }
              promise._popContext();
              if (x === errorObj || x === promise || x === NEXT_FILTER) {
                var err = x === promise ? makeSelfResolutionError() : x.e;
                promise._rejectCallback(err, false, true);
              } else {
                promise._resolveCallback(x);
              }
            };
            Promise.prototype._target = function() {
              var ret = this;
              while (ret._isFollowing())
                ret = ret._followee();
              return ret;
            };
            Promise.prototype._followee = function() {
              return this._rejectionHandler0;
            };
            Promise.prototype._setFollowee = function(promise) {
              this._rejectionHandler0 = promise;
            };
            Promise.prototype._cleanValues = function() {
              if (this._cancellable()) {
                this._cancellationParent = undefined;
              }
            };
            Promise.prototype._propagateFrom = function(parent, flags) {
              if ((flags & 1) > 0 && parent._cancellable()) {
                this._setCancellable();
                this._cancellationParent = parent;
              }
              if ((flags & 4) > 0 && parent._isBound()) {
                this._setBoundTo(parent._boundTo);
              }
            };
            Promise.prototype._fulfill = function(value) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._fulfillUnchecked(value);
            };
            Promise.prototype._reject = function(reason, carriedStackTrace) {
              if (this._isFollowingOrFulfilledOrRejected())
                return;
              this._rejectUnchecked(reason, carriedStackTrace);
            };
            Promise.prototype._settlePromiseAt = function(index) {
              var promise = this._promiseAt(index);
              var isPromise = promise instanceof Promise;
              if (isPromise && promise._isMigrated()) {
                promise._unsetIsMigrated();
                return async.invoke(this._settlePromiseAt, this, index);
              }
              var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
              var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
              var value = this._settledValue;
              var receiver = this._receiverAt(index);
              this._clearCallbackDataAtIndex(index);
              if (typeof handler === "function") {
                if (!isPromise) {
                  handler.call(receiver, value, promise);
                } else {
                  this._settlePromiseFromHandler(handler, receiver, value, promise);
                }
              } else if (receiver instanceof PromiseArray) {
                if (!receiver._isResolved()) {
                  if (this._isFulfilled()) {
                    receiver._promiseFulfilled(value, promise);
                  } else {
                    receiver._promiseRejected(value, promise);
                  }
                }
              } else if (isPromise) {
                if (this._isFulfilled()) {
                  promise._fulfill(value);
                } else {
                  promise._reject(value, carriedStackTrace);
                }
              }
              if (index >= 4 && (index & 31) === 4)
                async.invokeLater(this._setLength, this, 0);
            };
            Promise.prototype._clearCallbackDataAtIndex = function(index) {
              if (index === 0) {
                if (!this._isCarryingStackTrace()) {
                  this._fulfillmentHandler0 = undefined;
                }
                this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = undefined;
              } else {
                var base = index * 5 - 5;
                this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = undefined;
              }
            };
            Promise.prototype._isSettlePromisesQueued = function() {
              return (this._bitField & -1073741824) === -1073741824;
            };
            Promise.prototype._setSettlePromisesQueued = function() {
              this._bitField = this._bitField | -1073741824;
            };
            Promise.prototype._unsetSettlePromisesQueued = function() {
              this._bitField = this._bitField & (~-1073741824);
            };
            Promise.prototype._queueSettlePromises = function() {
              async.settlePromises(this);
              this._setSettlePromisesQueued();
            };
            Promise.prototype._fulfillUnchecked = function(value) {
              if (value === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err, undefined);
              }
              this._setFulfilled();
              this._settledValue = value;
              this._cleanValues();
              if (this._length() > 0) {
                this._queueSettlePromises();
              }
            };
            Promise.prototype._rejectUncheckedCheckError = function(reason) {
              var trace = util.ensureErrorObject(reason);
              this._rejectUnchecked(reason, trace === reason ? undefined : trace);
            };
            Promise.prototype._rejectUnchecked = function(reason, trace) {
              if (reason === this) {
                var err = makeSelfResolutionError();
                this._attachExtraTrace(err);
                return this._rejectUnchecked(err);
              }
              this._setRejected();
              this._settledValue = reason;
              this._cleanValues();
              if (this._isFinal()) {
                async.throwLater(function(e) {
                  if ("stack" in e) {
                    async.invokeFirst(CapturedTrace.unhandledRejection, undefined, e);
                  }
                  throw e;
                }, trace === undefined ? reason : trace);
                return;
              }
              if (trace !== undefined && trace !== reason) {
                this._setCarriedStackTrace(trace);
              }
              if (this._length() > 0) {
                this._queueSettlePromises();
              } else {
                this._ensurePossibleRejectionHandled();
              }
            };
            Promise.prototype._settlePromises = function() {
              this._unsetSettlePromisesQueued();
              var len = this._length();
              for (var i = 0; i < len; i++) {
                this._settlePromiseAt(i);
              }
            };
            util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);
            _dereq_("./progress.js")(Promise, PromiseArray);
            _dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            _dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
            _dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
            _dereq_("./direct_resolve.js")(Promise);
            _dereq_("./synchronous_inspection.js")(Promise);
            _dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
            Promise.Promise = Promise;
            _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
            _dereq_('./cancel.js')(Promise);
            _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
            _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
            _dereq_('./nodeify.js')(Promise);
            _dereq_('./call_get.js')(Promise);
            _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
            _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
            _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
            _dereq_('./settle.js')(Promise, PromiseArray);
            _dereq_('./some.js')(Promise, PromiseArray, apiRejection);
            _dereq_('./promisify.js')(Promise, INTERNAL);
            _dereq_('./any.js')(Promise);
            _dereq_('./each.js')(Promise, INTERNAL);
            _dereq_('./timers.js')(Promise, INTERNAL);
            _dereq_('./filter.js')(Promise, INTERNAL);
            util.toFastProperties(Promise);
            util.toFastProperties(Promise.prototype);
            function fillTypes(value) {
              var p = new Promise(INTERNAL);
              p._fulfillmentHandler0 = value;
              p._rejectionHandler0 = value;
              p._progressHandler0 = value;
              p._promise0 = value;
              p._receiver0 = value;
              p._settledValue = value;
            }
            fillTypes({a: 1});
            fillTypes({b: 2});
            fillTypes({c: 3});
            fillTypes(1);
            fillTypes(function() {});
            fillTypes(undefined);
            fillTypes(false);
            fillTypes(new Promise(INTERNAL));
            CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
            return Promise;
          };
        }, {
          "./any.js": 1,
          "./async.js": 2,
          "./bind.js": 3,
          "./call_get.js": 5,
          "./cancel.js": 6,
          "./captured_trace.js": 7,
          "./catch_filter.js": 8,
          "./context.js": 9,
          "./debuggability.js": 10,
          "./direct_resolve.js": 11,
          "./each.js": 12,
          "./errors.js": 13,
          "./filter.js": 15,
          "./finally.js": 16,
          "./generators.js": 17,
          "./join.js": 18,
          "./map.js": 19,
          "./method.js": 20,
          "./nodeify.js": 21,
          "./progress.js": 22,
          "./promise_array.js": 24,
          "./promise_resolver.js": 25,
          "./promisify.js": 26,
          "./props.js": 27,
          "./race.js": 29,
          "./reduce.js": 30,
          "./settle.js": 32,
          "./some.js": 33,
          "./synchronous_inspection.js": 34,
          "./thenables.js": 35,
          "./timers.js": 36,
          "./using.js": 37,
          "./util.js": 38
        }],
        24: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util.js");
            var isArray = util.isArray;
            function toResolutionValue(val) {
              switch (val) {
                case -2:
                  return [];
                case -3:
                  return {};
              }
            }
            function PromiseArray(values) {
              var promise = this._promise = new Promise(INTERNAL);
              var parent;
              if (values instanceof Promise) {
                parent = values;
                promise._propagateFrom(parent, 1 | 4);
              }
              this._values = values;
              this._length = 0;
              this._totalResolved = 0;
              this._init(undefined, -2);
            }
            PromiseArray.prototype.length = function() {
              return this._length;
            };
            PromiseArray.prototype.promise = function() {
              return this._promise;
            };
            PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
              var values = tryConvertToPromise(this._values, this._promise);
              if (values instanceof Promise) {
                values = values._target();
                this._values = values;
                if (values._isFulfilled()) {
                  values = values._value();
                  if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                    this.__hardReject__(err);
                    return;
                  }
                } else if (values._isPending()) {
                  values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
                  return;
                } else {
                  this._reject(values._reason());
                  return;
                }
              } else if (!isArray(values)) {
                this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
                return;
              }
              if (values.length === 0) {
                if (resolveValueIfEmpty === -5) {
                  this._resolveEmptyArray();
                } else {
                  this._resolve(toResolutionValue(resolveValueIfEmpty));
                }
                return;
              }
              var len = this.getActualLength(values.length);
              this._length = len;
              this._values = this.shouldCopyValues() ? new Array(len) : this._values;
              var promise = this._promise;
              for (var i = 0; i < len; ++i) {
                var isResolved = this._isResolved();
                var maybePromise = tryConvertToPromise(values[i], promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  if (isResolved) {
                    maybePromise._ignoreRejections();
                  } else if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                  } else if (maybePromise._isFulfilled()) {
                    this._promiseFulfilled(maybePromise._value(), i);
                  } else {
                    this._promiseRejected(maybePromise._reason(), i);
                  }
                } else if (!isResolved) {
                  this._promiseFulfilled(maybePromise, i);
                }
              }
            };
            PromiseArray.prototype._isResolved = function() {
              return this._values === null;
            };
            PromiseArray.prototype._resolve = function(value) {
              this._values = null;
              this._promise._fulfill(value);
            };
            PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function(reason) {
              this._values = null;
              this._promise._rejectCallback(reason, false, true);
            };
            PromiseArray.prototype._promiseProgressed = function(progressValue, index) {
              this._promise._progress({
                index: index,
                value: progressValue
              });
            };
            PromiseArray.prototype._promiseFulfilled = function(value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
              }
            };
            PromiseArray.prototype._promiseRejected = function(reason, index) {
              this._totalResolved++;
              this._reject(reason);
            };
            PromiseArray.prototype.shouldCopyValues = function() {
              return true;
            };
            PromiseArray.prototype.getActualLength = function(len) {
              return len;
            };
            return PromiseArray;
          };
        }, {"./util.js": 38}],
        25: [function(_dereq_, module, exports) {
          "use strict";
          var util = _dereq_("./util.js");
          var maybeWrapAsError = util.maybeWrapAsError;
          var errors = _dereq_("./errors.js");
          var TimeoutError = errors.TimeoutError;
          var OperationalError = errors.OperationalError;
          var haveGetters = util.haveGetters;
          var es5 = _dereq_("./es5.js");
          function isUntypedError(obj) {
            return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
          }
          var rErrorKey = /^(?:name|message|stack|cause)$/;
          function wrapAsOperationalError(obj) {
            var ret;
            if (isUntypedError(obj)) {
              ret = new OperationalError(obj);
              ret.name = obj.name;
              ret.message = obj.message;
              ret.stack = obj.stack;
              var keys = es5.keys(obj);
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                  ret[key] = obj[key];
                }
              }
              return ret;
            }
            util.markAsOriginatingFromRejection(obj);
            return obj;
          }
          function nodebackForPromise(promise) {
            return function(err, value) {
              if (promise === null)
                return;
              if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
              } else if (arguments.length > 2) {
                var $_len = arguments.length;
                var args = new Array($_len - 1);
                for (var $_i = 1; $_i < $_len; ++$_i) {
                  args[$_i - 1] = arguments[$_i];
                }
                promise._fulfill(args);
              } else {
                promise._fulfill(value);
              }
              promise = null;
            };
          }
          var PromiseResolver;
          if (!haveGetters) {
            PromiseResolver = function(promise) {
              this.promise = promise;
              this.asCallback = nodebackForPromise(promise);
              this.callback = this.asCallback;
            };
          } else {
            PromiseResolver = function(promise) {
              this.promise = promise;
            };
          }
          if (haveGetters) {
            var prop = {get: function() {
                return nodebackForPromise(this.promise);
              }};
            es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
            es5.defineProperty(PromiseResolver.prototype, "callback", prop);
          }
          PromiseResolver._nodebackForPromise = nodebackForPromise;
          PromiseResolver.prototype.toString = function() {
            return "[object PromiseResolver]";
          };
          PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
            }
            this.promise._resolveCallback(value);
          };
          PromiseResolver.prototype.reject = function(reason) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
            }
            this.promise._rejectCallback(reason);
          };
          PromiseResolver.prototype.progress = function(value) {
            if (!(this instanceof PromiseResolver)) {
              throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
            }
            this.promise._progress(value);
          };
          PromiseResolver.prototype.cancel = function(err) {
            this.promise.cancel(err);
          };
          PromiseResolver.prototype.timeout = function() {
            this.reject(new TimeoutError("timeout"));
          };
          PromiseResolver.prototype.isResolved = function() {
            return this.promise.isResolved();
          };
          PromiseResolver.prototype.toJSON = function() {
            return this.promise.toJSON();
          };
          module.exports = PromiseResolver;
        }, {
          "./errors.js": 13,
          "./es5.js": 14,
          "./util.js": 38
        }],
        26: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var THIS = {};
            var util = _dereq_("./util.js");
            var nodebackForPromise = _dereq_("./promise_resolver.js")._nodebackForPromise;
            var withAppended = util.withAppended;
            var maybeWrapAsError = util.maybeWrapAsError;
            var canEvaluate = util.canEvaluate;
            var TypeError = _dereq_("./errors").TypeError;
            var defaultSuffix = "Async";
            var defaultPromisified = {__isPromisified__: true};
            var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
            var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
            var defaultFilter = function(name) {
              return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
            };
            function propsFilter(key) {
              return !noCopyPropsPattern.test(key);
            }
            function isPromisified(fn) {
              try {
                return fn.__isPromisified__ === true;
              } catch (e) {
                return false;
              }
            }
            function hasPromisified(obj, key, suffix) {
              var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
              return val ? isPromisified(val) : false;
            }
            function checkValid(ret, suffix, suffixRegexp) {
              for (var i = 0; i < ret.length; i += 2) {
                var key = ret[i];
                if (suffixRegexp.test(key)) {
                  var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                  for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                      throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a".replace("%s", suffix));
                    }
                  }
                }
              }
            }
            function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
              var keys = util.inheritedDataKeys(obj);
              var ret = [];
              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                var value = obj[key];
                var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
                if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                  ret.push(key, value);
                }
              }
              checkValid(ret, suffix, suffixRegexp);
              return ret;
            }
            var escapeIdentRegex = function(str) {
              return str.replace(/([$])/, "\\$");
            };
            var makeNodePromisifiedEval;
            if (!true) {
              var switchCaseArgumentOrder = function(likelyArgumentCount) {
                var ret = [likelyArgumentCount];
                var min = Math.max(0, likelyArgumentCount - 1 - 3);
                for (var i = likelyArgumentCount - 1; i >= min; --i) {
                  ret.push(i);
                }
                for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                  ret.push(i);
                }
                return ret;
              };
              var argumentSequence = function(argumentCount) {
                return util.filledRange(argumentCount, "_arg", "");
              };
              var parameterDeclaration = function(parameterCount) {
                return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
              };
              var parameterCount = function(fn) {
                if (typeof fn.length === "number") {
                  return Math.max(Math.min(fn.length, 1023 + 1), 0);
                }
                return 0;
              };
              makeNodePromisifiedEval = function(callback, receiver, originalName, fn) {
                var newParameterCount = Math.max(0, parameterCount(fn) - 1);
                var argumentOrder = switchCaseArgumentOrder(newParameterCount);
                var shouldProxyThis = typeof callback === "string" || receiver === THIS;
                function generateCallForArgumentCount(count) {
                  var args = argumentSequence(count).join(", ");
                  var comma = count > 0 ? ", " : "";
                  var ret;
                  if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                  } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                  }
                  return ret.replace("{{args}}", args).replace(", ", comma);
                }
                function generateArgumentSwitchCase() {
                  var ret = "";
                  for (var i = 0; i < argumentOrder.length; ++i) {
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                  }
                  ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n"));
                  return ret;
                }
                var getFunctionCode = typeof callback === "string" ? ("this != null ? this['" + callback + "'] : fn") : "fn";
                return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", "'use strict';                            \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise);                      \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
        ".replace("Parameters", parameterDeclaration(newParameterCount)).replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode))(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
              };
            }
            function makeNodePromisifiedClosure(callback, receiver, _, fn) {
              var defaultThis = (function() {
                return this;
              })();
              var method = callback;
              if (typeof method === "string") {
                callback = fn;
              }
              function promisified() {
                var _receiver = receiver;
                if (receiver === THIS)
                  _receiver = this;
                var promise = new Promise(INTERNAL);
                promise._captureStackTrace();
                var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
                var fn = nodebackForPromise(promise);
                try {
                  cb.apply(_receiver, withAppended(arguments, fn));
                } catch (e) {
                  promise._rejectCallback(maybeWrapAsError(e), true, true);
                }
                return promise;
              }
              util.notEnumerableProp(promisified, "__isPromisified__", true);
              return promisified;
            }
            var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
            function promisifyAll(obj, suffix, filter, promisifier) {
              var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
              var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
              for (var i = 0,
                  len = methods.length; i < len; i += 2) {
                var key = methods[i];
                var fn = methods[i + 1];
                var promisifiedKey = key + suffix;
                if (promisifier === makeNodePromisified) {
                  obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix);
                } else {
                  var promisified = promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix);
                  });
                  util.notEnumerableProp(promisified, "__isPromisified__", true);
                  obj[promisifiedKey] = promisified;
                }
              }
              util.toFastProperties(obj);
              return obj;
            }
            function promisify(callback, receiver) {
              return makeNodePromisified(callback, receiver, undefined, callback);
            }
            Promise.promisify = function(fn, receiver) {
              if (typeof fn !== "function") {
                throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              }
              if (isPromisified(fn)) {
                return fn;
              }
              var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
              util.copyDescriptors(fn, ret, propsFilter);
              return ret;
            };
            Promise.promisifyAll = function(target, options) {
              if (typeof target !== "function" && typeof target !== "object") {
                throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
              }
              options = Object(options);
              var suffix = options.suffix;
              if (typeof suffix !== "string")
                suffix = defaultSuffix;
              var filter = options.filter;
              if (typeof filter !== "function")
                filter = defaultFilter;
              var promisifier = options.promisifier;
              if (typeof promisifier !== "function")
                promisifier = makeNodePromisified;
              if (!util.isIdentifier(suffix)) {
                throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
              }
              var keys = util.inheritedDataKeys(target);
              for (var i = 0; i < keys.length; ++i) {
                var value = target[keys[i]];
                if (keys[i] !== "constructor" && util.isClass(value)) {
                  promisifyAll(value.prototype, suffix, filter, promisifier);
                  promisifyAll(value, suffix, filter, promisifier);
                }
              }
              return promisifyAll(target, suffix, filter, promisifier);
            };
          };
        }, {
          "./errors": 13,
          "./promise_resolver.js": 25,
          "./util.js": 38
        }],
        27: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util.js");
            var isObject = util.isObject;
            var es5 = _dereq_("./es5.js");
            function PropertiesPromiseArray(obj) {
              var keys = es5.keys(obj);
              var len = keys.length;
              var values = new Array(len * 2);
              for (var i = 0; i < len; ++i) {
                var key = keys[i];
                values[i] = obj[key];
                values[i + len] = key;
              }
              this.constructor$(values);
            }
            util.inherits(PropertiesPromiseArray, PromiseArray);
            PropertiesPromiseArray.prototype._init = function() {
              this._init$(undefined, -3);
            };
            PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                var val = {};
                var keyOffset = this.length();
                for (var i = 0,
                    len = this.length(); i < len; ++i) {
                  val[this._values[i + keyOffset]] = this._values[i];
                }
                this._resolve(val);
              }
            };
            PropertiesPromiseArray.prototype._promiseProgressed = function(value, index) {
              this._promise._progress({
                key: this._values[index + this.length()],
                value: value
              });
            };
            PropertiesPromiseArray.prototype.shouldCopyValues = function() {
              return false;
            };
            PropertiesPromiseArray.prototype.getActualLength = function(len) {
              return len >> 1;
            };
            function props(promises) {
              var ret;
              var castValue = tryConvertToPromise(promises);
              if (!isObject(castValue)) {
                return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
              } else if (castValue instanceof Promise) {
                ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
              } else {
                ret = new PropertiesPromiseArray(castValue).promise();
              }
              if (castValue instanceof Promise) {
                ret._propagateFrom(castValue, 4);
              }
              return ret;
            }
            Promise.prototype.props = function() {
              return props(this);
            };
            Promise.props = function(promises) {
              return props(promises);
            };
          };
        }, {
          "./es5.js": 14,
          "./util.js": 38
        }],
        28: [function(_dereq_, module, exports) {
          "use strict";
          function arrayMove(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) {
              dst[j + dstIndex] = src[j + srcIndex];
              src[j + srcIndex] = void 0;
            }
          }
          function Queue(capacity) {
            this._capacity = capacity;
            this._length = 0;
            this._front = 0;
          }
          Queue.prototype._willBeOverCapacity = function(size) {
            return this._capacity < size;
          };
          Queue.prototype._pushOne = function(arg) {
            var length = this.length();
            this._checkCapacity(length + 1);
            var i = (this._front + length) & (this._capacity - 1);
            this[i] = arg;
            this._length = length + 1;
          };
          Queue.prototype._unshiftOne = function(value) {
            var capacity = this._capacity;
            this._checkCapacity(this.length() + 1);
            var front = this._front;
            var i = ((((front - 1) & (capacity - 1)) ^ capacity) - capacity);
            this[i] = value;
            this._front = i;
            this._length = this.length() + 1;
          };
          Queue.prototype.unshift = function(fn, receiver, arg) {
            this._unshiftOne(arg);
            this._unshiftOne(receiver);
            this._unshiftOne(fn);
          };
          Queue.prototype.push = function(fn, receiver, arg) {
            var length = this.length() + 3;
            if (this._willBeOverCapacity(length)) {
              this._pushOne(fn);
              this._pushOne(receiver);
              this._pushOne(arg);
              return;
            }
            var j = this._front + length - 3;
            this._checkCapacity(length);
            var wrapMask = this._capacity - 1;
            this[(j + 0) & wrapMask] = fn;
            this[(j + 1) & wrapMask] = receiver;
            this[(j + 2) & wrapMask] = arg;
            this._length = length;
          };
          Queue.prototype.shift = function() {
            var front = this._front,
                ret = this[front];
            this[front] = undefined;
            this._front = (front + 1) & (this._capacity - 1);
            this._length--;
            return ret;
          };
          Queue.prototype.length = function() {
            return this._length;
          };
          Queue.prototype._checkCapacity = function(size) {
            if (this._capacity < size) {
              this._resizeTo(this._capacity << 1);
            }
          };
          Queue.prototype._resizeTo = function(capacity) {
            var oldCapacity = this._capacity;
            this._capacity = capacity;
            var front = this._front;
            var length = this._length;
            var moveItemsCount = (front + length) & (oldCapacity - 1);
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
          };
          module.exports = Queue;
        }, {}],
        29: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var isArray = _dereq_("./util.js").isArray;
            var raceLater = function(promise) {
              return promise.then(function(array) {
                return race(array, promise);
              });
            };
            function race(promises, parent) {
              var maybePromise = tryConvertToPromise(promises);
              if (maybePromise instanceof Promise) {
                return raceLater(maybePromise);
              } else if (!isArray(promises)) {
                return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
              }
              var ret = new Promise(INTERNAL);
              if (parent !== undefined) {
                ret._propagateFrom(parent, 4 | 1);
              }
              var fulfill = ret._fulfill;
              var reject = ret._reject;
              for (var i = 0,
                  len = promises.length; i < len; ++i) {
                var val = promises[i];
                if (val === undefined && !(i in promises)) {
                  continue;
                }
                Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
              }
              return ret;
            }
            Promise.race = function(promises) {
              return race(promises, undefined);
            };
            Promise.prototype.race = function() {
              return race(this, undefined);
            };
          };
        }, {"./util.js": 38}],
        30: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {
            var getDomain = Promise._getDomain;
            var async = _dereq_("./async.js");
            var util = _dereq_("./util.js");
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            function ReductionPromiseArray(promises, fn, accum, _each) {
              this.constructor$(promises);
              this._promise._captureStackTrace();
              this._preservedValues = _each === INTERNAL ? [] : null;
              this._zerothIsAccum = (accum === undefined);
              this._gotAccum = false;
              this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
              this._valuesPhase = undefined;
              var maybePromise = tryConvertToPromise(accum, this._promise);
              var rejected = false;
              var isPromise = maybePromise instanceof Promise;
              if (isPromise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                  maybePromise._proxyPromiseArray(this, -1);
                } else if (maybePromise._isFulfilled()) {
                  accum = maybePromise._value();
                  this._gotAccum = true;
                } else {
                  this._reject(maybePromise._reason());
                  rejected = true;
                }
              }
              if (!(isPromise || this._zerothIsAccum))
                this._gotAccum = true;
              var domain = getDomain();
              this._callback = domain === null ? fn : domain.bind(fn);
              this._accum = accum;
              if (!rejected)
                async.invoke(init, this, undefined);
            }
            function init() {
              this._init$(undefined, -5);
            }
            util.inherits(ReductionPromiseArray, PromiseArray);
            ReductionPromiseArray.prototype._init = function() {};
            ReductionPromiseArray.prototype._resolveEmptyArray = function() {
              if (this._gotAccum || this._zerothIsAccum) {
                this._resolve(this._preservedValues !== null ? [] : this._accum);
              }
            };
            ReductionPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var values = this._values;
              values[index] = value;
              var length = this.length();
              var preservedValues = this._preservedValues;
              var isEach = preservedValues !== null;
              var gotAccum = this._gotAccum;
              var valuesPhase = this._valuesPhase;
              var valuesPhaseIndex;
              if (!valuesPhase) {
                valuesPhase = this._valuesPhase = new Array(length);
                for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                  valuesPhase[valuesPhaseIndex] = 0;
                }
              }
              valuesPhaseIndex = valuesPhase[index];
              if (index === 0 && this._zerothIsAccum) {
                this._accum = value;
                this._gotAccum = gotAccum = true;
                valuesPhase[index] = ((valuesPhaseIndex === 0) ? 1 : 2);
              } else if (index === -1) {
                this._accum = value;
                this._gotAccum = gotAccum = true;
              } else {
                if (valuesPhaseIndex === 0) {
                  valuesPhase[index] = 1;
                } else {
                  valuesPhase[index] = 2;
                  this._accum = value;
                }
              }
              if (!gotAccum)
                return;
              var callback = this._callback;
              var receiver = this._promise._boundValue();
              var ret;
              for (var i = this._reducingIndex; i < length; ++i) {
                valuesPhaseIndex = valuesPhase[i];
                if (valuesPhaseIndex === 2) {
                  this._reducingIndex = i + 1;
                  continue;
                }
                if (valuesPhaseIndex !== 1)
                  return;
                value = values[i];
                this._promise._pushContext();
                if (isEach) {
                  preservedValues.push(value);
                  ret = tryCatch(callback).call(receiver, value, i, length);
                } else {
                  ret = tryCatch(callback).call(receiver, this._accum, value, i, length);
                }
                this._promise._popContext();
                if (ret === errorObj)
                  return this._reject(ret.e);
                var maybePromise = tryConvertToPromise(ret, this._promise);
                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  if (maybePromise._isPending()) {
                    valuesPhase[i] = 4;
                    return maybePromise._proxyPromiseArray(this, i);
                  } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                  } else {
                    return this._reject(maybePromise._reason());
                  }
                }
                this._reducingIndex = i + 1;
                this._accum = ret;
              }
              this._resolve(isEach ? preservedValues : this._accum);
            };
            function reduce(promises, fn, initialValue, _each) {
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
              return array.promise();
            }
            Promise.prototype.reduce = function(fn, initialValue) {
              return reduce(this, fn, initialValue, null);
            };
            Promise.reduce = function(promises, fn, initialValue, _each) {
              return reduce(promises, fn, initialValue, _each);
            };
          };
        }, {
          "./async.js": 2,
          "./util.js": 38
        }],
        31: [function(_dereq_, module, exports) {
          "use strict";
          var schedule;
          var util = _dereq_("./util");
          var noAsyncScheduler = function() {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
          };
          if (util.isNode && typeof MutationObserver === "undefined") {
            var GlobalSetImmediate = global.setImmediate;
            var ProcessNextTick = process.nextTick;
            schedule = util.isRecentNode ? function(fn) {
              GlobalSetImmediate.call(global, fn);
            } : function(fn) {
              ProcessNextTick.call(process, fn);
            };
          } else if ((typeof MutationObserver !== "undefined") && !(typeof window !== "undefined" && window.navigator && window.navigator.standalone)) {
            schedule = function(fn) {
              var div = document.createElement("div");
              var observer = new MutationObserver(fn);
              observer.observe(div, {attributes: true});
              return function() {
                div.classList.toggle("foo");
              };
            };
            schedule.isStatic = true;
          } else if (typeof setImmediate !== "undefined") {
            schedule = function(fn) {
              setImmediate(fn);
            };
          } else if (typeof setTimeout !== "undefined") {
            schedule = function(fn) {
              setTimeout(fn, 0);
            };
          } else {
            schedule = noAsyncScheduler;
          }
          module.exports = schedule;
        }, {"./util": 38}],
        32: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray) {
            var PromiseInspection = Promise.PromiseInspection;
            var util = _dereq_("./util.js");
            function SettledPromiseArray(values) {
              this.constructor$(values);
            }
            util.inherits(SettledPromiseArray, PromiseArray);
            SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
              this._values[index] = inspection;
              var totalResolved = ++this._totalResolved;
              if (totalResolved >= this._length) {
                this._resolve(this._values);
              }
            };
            SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
              var ret = new PromiseInspection();
              ret._bitField = 268435456;
              ret._settledValue = value;
              this._promiseResolved(index, ret);
            };
            SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
              var ret = new PromiseInspection();
              ret._bitField = 134217728;
              ret._settledValue = reason;
              this._promiseResolved(index, ret);
            };
            Promise.settle = function(promises) {
              return new SettledPromiseArray(promises).promise();
            };
            Promise.prototype.settle = function() {
              return new SettledPromiseArray(this).promise();
            };
          };
        }, {"./util.js": 38}],
        33: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, PromiseArray, apiRejection) {
            var util = _dereq_("./util.js");
            var RangeError = _dereq_("./errors.js").RangeError;
            var AggregateError = _dereq_("./errors.js").AggregateError;
            var isArray = util.isArray;
            function SomePromiseArray(values) {
              this.constructor$(values);
              this._howMany = 0;
              this._unwrap = false;
              this._initialized = false;
            }
            util.inherits(SomePromiseArray, PromiseArray);
            SomePromiseArray.prototype._init = function() {
              if (!this._initialized) {
                return;
              }
              if (this._howMany === 0) {
                this._resolve([]);
                return;
              }
              this._init$(undefined, -5);
              var isArrayResolved = isArray(this._values);
              if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                this._reject(this._getRangeError(this.length()));
              }
            };
            SomePromiseArray.prototype.init = function() {
              this._initialized = true;
              this._init();
            };
            SomePromiseArray.prototype.setUnwrap = function() {
              this._unwrap = true;
            };
            SomePromiseArray.prototype.howMany = function() {
              return this._howMany;
            };
            SomePromiseArray.prototype.setHowMany = function(count) {
              this._howMany = count;
            };
            SomePromiseArray.prototype._promiseFulfilled = function(value) {
              this._addFulfilled(value);
              if (this._fulfilled() === this.howMany()) {
                this._values.length = this.howMany();
                if (this.howMany() === 1 && this._unwrap) {
                  this._resolve(this._values[0]);
                } else {
                  this._resolve(this._values);
                }
              }
            };
            SomePromiseArray.prototype._promiseRejected = function(reason) {
              this._addRejected(reason);
              if (this.howMany() > this._canPossiblyFulfill()) {
                var e = new AggregateError();
                for (var i = this.length(); i < this._values.length; ++i) {
                  e.push(this._values[i]);
                }
                this._reject(e);
              }
            };
            SomePromiseArray.prototype._fulfilled = function() {
              return this._totalResolved;
            };
            SomePromiseArray.prototype._rejected = function() {
              return this._values.length - this.length();
            };
            SomePromiseArray.prototype._addRejected = function(reason) {
              this._values.push(reason);
            };
            SomePromiseArray.prototype._addFulfilled = function(value) {
              this._values[this._totalResolved++] = value;
            };
            SomePromiseArray.prototype._canPossiblyFulfill = function() {
              return this.length() - this._rejected();
            };
            SomePromiseArray.prototype._getRangeError = function(count) {
              var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
              return new RangeError(message);
            };
            SomePromiseArray.prototype._resolveEmptyArray = function() {
              this._reject(this._getRangeError(0));
            };
            function some(promises, howMany) {
              if ((howMany | 0) !== howMany || howMany < 0) {
                return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
              }
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(howMany);
              ret.init();
              return promise;
            }
            Promise.some = function(promises, howMany) {
              return some(promises, howMany);
            };
            Promise.prototype.some = function(howMany) {
              return some(this, howMany);
            };
            Promise._SomePromiseArray = SomePromiseArray;
          };
        }, {
          "./errors.js": 13,
          "./util.js": 38
        }],
        34: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise) {
            function PromiseInspection(promise) {
              if (promise !== undefined) {
                promise = promise._target();
                this._bitField = promise._bitField;
                this._settledValue = promise._settledValue;
              } else {
                this._bitField = 0;
                this._settledValue = undefined;
              }
            }
            PromiseInspection.prototype.value = function() {
              if (!this.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
              if (!this.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
              }
              return this._settledValue;
            };
            PromiseInspection.prototype.isFulfilled = Promise.prototype._isFulfilled = function() {
              return (this._bitField & 268435456) > 0;
            };
            PromiseInspection.prototype.isRejected = Promise.prototype._isRejected = function() {
              return (this._bitField & 134217728) > 0;
            };
            PromiseInspection.prototype.isPending = Promise.prototype._isPending = function() {
              return (this._bitField & 402653184) === 0;
            };
            PromiseInspection.prototype.isResolved = Promise.prototype._isResolved = function() {
              return (this._bitField & 402653184) > 0;
            };
            Promise.prototype.isPending = function() {
              return this._target()._isPending();
            };
            Promise.prototype.isRejected = function() {
              return this._target()._isRejected();
            };
            Promise.prototype.isFulfilled = function() {
              return this._target()._isFulfilled();
            };
            Promise.prototype.isResolved = function() {
              return this._target()._isResolved();
            };
            Promise.prototype._value = function() {
              return this._settledValue;
            };
            Promise.prototype._reason = function() {
              this._unsetRejectionIsUnhandled();
              return this._settledValue;
            };
            Promise.prototype.value = function() {
              var target = this._target();
              if (!target.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
              }
              return target._settledValue;
            };
            Promise.prototype.reason = function() {
              var target = this._target();
              if (!target.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
              }
              target._unsetRejectionIsUnhandled();
              return target._settledValue;
            };
            Promise.PromiseInspection = PromiseInspection;
          };
        }, {}],
        35: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util.js");
            var errorObj = util.errorObj;
            var isObject = util.isObject;
            function tryConvertToPromise(obj, context) {
              if (isObject(obj)) {
                if (obj instanceof Promise) {
                  return obj;
                } else if (isAnyBluebirdPromise(obj)) {
                  var ret = new Promise(INTERNAL);
                  obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
                  return ret;
                }
                var then = util.tryCatch(getThen)(obj);
                if (then === errorObj) {
                  if (context)
                    context._pushContext();
                  var ret = Promise.reject(then.e);
                  if (context)
                    context._popContext();
                  return ret;
                } else if (typeof then === "function") {
                  return doThenable(obj, then, context);
                }
              }
              return obj;
            }
            function getThen(obj) {
              return obj.then;
            }
            var hasProp = {}.hasOwnProperty;
            function isAnyBluebirdPromise(obj) {
              return hasProp.call(obj, "_promise0");
            }
            function doThenable(x, then, context) {
              var promise = new Promise(INTERNAL);
              var ret = promise;
              if (context)
                context._pushContext();
              promise._captureStackTrace();
              if (context)
                context._popContext();
              var synchronous = true;
              var result = util.tryCatch(then).call(x, resolveFromThenable, rejectFromThenable, progressFromThenable);
              synchronous = false;
              if (promise && result === errorObj) {
                promise._rejectCallback(result.e, true, true);
                promise = null;
              }
              function resolveFromThenable(value) {
                if (!promise)
                  return;
                promise._resolveCallback(value);
                promise = null;
              }
              function rejectFromThenable(reason) {
                if (!promise)
                  return;
                promise._rejectCallback(reason, synchronous, true);
                promise = null;
              }
              function progressFromThenable(value) {
                if (!promise)
                  return;
                if (typeof promise._progress === "function") {
                  promise._progress(value);
                }
              }
              return ret;
            }
            return tryConvertToPromise;
          };
        }, {"./util.js": 38}],
        36: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, INTERNAL) {
            var util = _dereq_("./util.js");
            var TimeoutError = Promise.TimeoutError;
            var afterTimeout = function(promise, message) {
              if (!promise.isPending())
                return;
              var err;
              if (!util.isPrimitive(message) && (message instanceof Error)) {
                err = message;
              } else {
                if (typeof message !== "string") {
                  message = "operation timed out";
                }
                err = new TimeoutError(message);
              }
              util.markAsOriginatingFromRejection(err);
              promise._attachExtraTrace(err);
              promise._cancel(err);
            };
            var afterValue = function(value) {
              return delay(+this).thenReturn(value);
            };
            var delay = Promise.delay = function(value, ms) {
              if (ms === undefined) {
                ms = value;
                value = undefined;
                var ret = new Promise(INTERNAL);
                setTimeout(function() {
                  ret._fulfill();
                }, ms);
                return ret;
              }
              ms = +ms;
              return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
            };
            Promise.prototype.delay = function(ms) {
              return delay(this, ms);
            };
            function successClear(value) {
              var handle = this;
              if (handle instanceof Number)
                handle = +handle;
              clearTimeout(handle);
              return value;
            }
            function failureClear(reason) {
              var handle = this;
              if (handle instanceof Number)
                handle = +handle;
              clearTimeout(handle);
              throw reason;
            }
            Promise.prototype.timeout = function(ms, message) {
              ms = +ms;
              var ret = this.then().cancellable();
              ret._cancellationParent = this;
              var handle = setTimeout(function timeoutTimeout() {
                afterTimeout(ret, message);
              }, ms);
              return ret._then(successClear, failureClear, undefined, handle, undefined);
            };
          };
        }, {"./util.js": 38}],
        37: [function(_dereq_, module, exports) {
          "use strict";
          module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext) {
            var TypeError = _dereq_("./errors.js").TypeError;
            var inherits = _dereq_("./util.js").inherits;
            var PromiseInspection = Promise.PromiseInspection;
            function inspectionMapper(inspections) {
              var len = inspections.length;
              for (var i = 0; i < len; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                  return Promise.reject(inspection.error());
                }
                inspections[i] = inspection._settledValue;
              }
              return inspections;
            }
            function thrower(e) {
              setTimeout(function() {
                throw e;
              }, 0);
            }
            function castPreservingDisposable(thenable) {
              var maybePromise = tryConvertToPromise(thenable);
              if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
              }
              return maybePromise;
            }
            function dispose(resources, inspection) {
              var i = 0;
              var len = resources.length;
              var ret = Promise.defer();
              function iterator() {
                if (i >= len)
                  return ret.resolve();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                  try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                  } catch (e) {
                    return thrower(e);
                  }
                  if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                  }
                }
                iterator();
              }
              iterator();
              return ret.promise;
            }
            function disposerSuccess(value) {
              var inspection = new PromiseInspection();
              inspection._settledValue = value;
              inspection._bitField = 268435456;
              return dispose(this, inspection).thenReturn(value);
            }
            function disposerFail(reason) {
              var inspection = new PromiseInspection();
              inspection._settledValue = reason;
              inspection._bitField = 134217728;
              return dispose(this, inspection).thenThrow(reason);
            }
            function Disposer(data, promise, context) {
              this._data = data;
              this._promise = promise;
              this._context = context;
            }
            Disposer.prototype.data = function() {
              return this._data;
            };
            Disposer.prototype.promise = function() {
              return this._promise;
            };
            Disposer.prototype.resource = function() {
              if (this.promise().isFulfilled()) {
                return this.promise().value();
              }
              return null;
            };
            Disposer.prototype.tryDispose = function(inspection) {
              var resource = this.resource();
              var context = this._context;
              if (context !== undefined)
                context._pushContext();
              var ret = resource !== null ? this.doDispose(resource, inspection) : null;
              if (context !== undefined)
                context._popContext();
              this._promise._unsetDisposable();
              this._data = null;
              return ret;
            };
            Disposer.isDisposer = function(d) {
              return (d != null && typeof d.resource === "function" && typeof d.tryDispose === "function");
            };
            function FunctionDisposer(fn, promise, context) {
              this.constructor$(fn, promise, context);
            }
            inherits(FunctionDisposer, Disposer);
            FunctionDisposer.prototype.doDispose = function(resource, inspection) {
              var fn = this.data();
              return fn.call(resource, resource, inspection);
            };
            function maybeUnwrapDisposer(value) {
              if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
              }
              return value;
            }
            Promise.using = function() {
              var len = arguments.length;
              if (len < 2)
                return apiRejection("you must pass at least 2 arguments to Promise.using");
              var fn = arguments[len - 1];
              if (typeof fn !== "function")
                return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
              var input;
              var spreadArgs = true;
              if (len === 2 && Array.isArray(arguments[0])) {
                input = arguments[0];
                len = input.length;
                spreadArgs = false;
              } else {
                input = arguments;
                len--;
              }
              var resources = new Array(len);
              for (var i = 0; i < len; ++i) {
                var resource = input[i];
                if (Disposer.isDisposer(resource)) {
                  var disposer = resource;
                  resource = resource.promise();
                  resource._setDisposable(disposer);
                } else {
                  var maybePromise = tryConvertToPromise(resource);
                  if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                      resources: resources,
                      index: i
                    }, undefined);
                  }
                }
                resources[i] = resource;
              }
              var promise = Promise.settle(resources).then(inspectionMapper).then(function(vals) {
                promise._pushContext();
                var ret;
                try {
                  ret = spreadArgs ? fn.apply(undefined, vals) : fn.call(undefined, vals);
                } finally {
                  promise._popContext();
                }
                return ret;
              })._then(disposerSuccess, disposerFail, undefined, resources, undefined);
              resources.promise = promise;
              return promise;
            };
            Promise.prototype._setDisposable = function(disposer) {
              this._bitField = this._bitField | 262144;
              this._disposer = disposer;
            };
            Promise.prototype._isDisposable = function() {
              return (this._bitField & 262144) > 0;
            };
            Promise.prototype._getDisposer = function() {
              return this._disposer;
            };
            Promise.prototype._unsetDisposable = function() {
              this._bitField = this._bitField & (~262144);
              this._disposer = undefined;
            };
            Promise.prototype.disposer = function(fn) {
              if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
              }
              throw new TypeError();
            };
          };
        }, {
          "./errors.js": 13,
          "./util.js": 38
        }],
        38: [function(_dereq_, module, exports) {
          "use strict";
          var es5 = _dereq_("./es5.js");
          var canEvaluate = typeof navigator == "undefined";
          var haveGetters = (function() {
            try {
              var o = {};
              es5.defineProperty(o, "f", {get: function() {
                  return 3;
                }});
              return o.f === 3;
            } catch (e) {
              return false;
            }
          })();
          var errorObj = {e: {}};
          var tryCatchTarget;
          function tryCatcher() {
            try {
              var target = tryCatchTarget;
              tryCatchTarget = null;
              return target.apply(this, arguments);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }
          function tryCatch(fn) {
            tryCatchTarget = fn;
            return tryCatcher;
          }
          var inherits = function(Child, Parent) {
            var hasProp = {}.hasOwnProperty;
            function T() {
              this.constructor = Child;
              this.constructor$ = Parent;
              for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                  this[propertyName + "$"] = Parent.prototype[propertyName];
                }
              }
            }
            T.prototype = Parent.prototype;
            Child.prototype = new T();
            return Child.prototype;
          };
          function isPrimitive(val) {
            return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
          }
          function isObject(value) {
            return !isPrimitive(value);
          }
          function maybeWrapAsError(maybeError) {
            if (!isPrimitive(maybeError))
              return maybeError;
            return new Error(safeToString(maybeError));
          }
          function withAppended(target, appendee) {
            var len = target.length;
            var ret = new Array(len + 1);
            var i;
            for (i = 0; i < len; ++i) {
              ret[i] = target[i];
            }
            ret[i] = appendee;
            return ret;
          }
          function getDataPropertyOrDefault(obj, key, defaultValue) {
            if (es5.isES5) {
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null) {
                return desc.get == null && desc.set == null ? desc.value : defaultValue;
              }
            } else {
              return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
            }
          }
          function notEnumerableProp(obj, name, value) {
            if (isPrimitive(obj))
              return obj;
            var descriptor = {
              value: value,
              configurable: true,
              enumerable: false,
              writable: true
            };
            es5.defineProperty(obj, name, descriptor);
            return obj;
          }
          function thrower(r) {
            throw r;
          }
          var inheritedDataKeys = (function() {
            var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];
            var isExcludedProto = function(val) {
              for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                  return true;
                }
              }
              return false;
            };
            if (es5.isES5) {
              var getKeys = Object.getOwnPropertyNames;
              return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && !isExcludedProto(obj)) {
                  var keys;
                  try {
                    keys = getKeys(obj);
                  } catch (e) {
                    return ret;
                  }
                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key])
                      continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                      ret.push(key);
                    }
                  }
                  obj = es5.getPrototypeOf(obj);
                }
                return ret;
              };
            } else {
              var hasProp = {}.hasOwnProperty;
              return function(obj) {
                if (isExcludedProto(obj))
                  return [];
                var ret = [];
                enumeration: for (var key in obj) {
                  if (hasProp.call(obj, key)) {
                    ret.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret.push(key);
                  }
                }
                return ret;
              };
            }
          })();
          var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
          function isClass(fn) {
            try {
              if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
                if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                  return true;
                }
              }
              return false;
            } catch (e) {
              return false;
            }
          }
          function toFastProperties(obj) {
            function f() {}
            f.prototype = obj;
            var l = 8;
            while (l--)
              new f();
            return obj;
            eval(obj);
          }
          var rident = /^[a-z$_][a-z$_0-9]*$/i;
          function isIdentifier(str) {
            return rident.test(str);
          }
          function filledRange(count, prefix, suffix) {
            var ret = new Array(count);
            for (var i = 0; i < count; ++i) {
              ret[i] = prefix + i + suffix;
            }
            return ret;
          }
          function safeToString(obj) {
            try {
              return obj + "";
            } catch (e) {
              return "[no string representation]";
            }
          }
          function markAsOriginatingFromRejection(e) {
            try {
              notEnumerableProp(e, "isOperational", true);
            } catch (ignore) {}
          }
          function originatesFromRejection(e) {
            if (e == null)
              return false;
            return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) || e["isOperational"] === true);
          }
          function canAttachTrace(obj) {
            return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
          }
          var ensureErrorObject = (function() {
            if (!("stack" in new Error())) {
              return function(value) {
                if (canAttachTrace(value))
                  return value;
                try {
                  throw new Error(safeToString(value));
                } catch (err) {
                  return err;
                }
              };
            } else {
              return function(value) {
                if (canAttachTrace(value))
                  return value;
                return new Error(safeToString(value));
              };
            }
          })();
          function classString(obj) {
            return {}.toString.call(obj);
          }
          function copyDescriptors(from, to, filter) {
            var keys = es5.names(from);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (filter(key)) {
                try {
                  es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
              }
            }
          }
          var ret = {
            isClass: isClass,
            isIdentifier: isIdentifier,
            inheritedDataKeys: inheritedDataKeys,
            getDataPropertyOrDefault: getDataPropertyOrDefault,
            thrower: thrower,
            isArray: es5.isArray,
            haveGetters: haveGetters,
            notEnumerableProp: notEnumerableProp,
            isPrimitive: isPrimitive,
            isObject: isObject,
            canEvaluate: canEvaluate,
            errorObj: errorObj,
            tryCatch: tryCatch,
            inherits: inherits,
            withAppended: withAppended,
            maybeWrapAsError: maybeWrapAsError,
            toFastProperties: toFastProperties,
            filledRange: filledRange,
            toString: safeToString,
            canAttachTrace: canAttachTrace,
            ensureErrorObject: ensureErrorObject,
            originatesFromRejection: originatesFromRejection,
            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
            classString: classString,
            copyDescriptors: copyDescriptors,
            hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
            isNode: typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]"
          };
          ret.isRecentNode = ret.isNode && (function() {
            var version = process.versions.node.split(".").map(Number);
            return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
          })();
          if (ret.isNode)
            ret.toFastProperties(process);
          try {
            throw new Error();
          } catch (e) {
            ret.lastLineError = e;
          }
          module.exports = ret;
        }, {"./es5.js": 14}]
      }, {}, [4])(4);
    });
    ;
    if (typeof window !== 'undefined' && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== 'undefined' && self !== null) {
      self.P = self.Promise;
    }
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:bluebird@2.10.2", ["npm:bluebird@2.10.2/js/browser/bluebird"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:bluebird@2.10.2/js/browser/bluebird');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.cof", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iobject", ["npm:core-js@1.2.3/library/modules/$.cof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.3/library/modules/$.cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.to-iobject", ["npm:core-js@1.2.3/library/modules/$.iobject", "npm:core-js@1.2.3/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.2.3/library/modules/$.iobject'),
      defined = $__require('npm:core-js@1.2.3/library/modules/$.defined');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iter-step", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.unscope", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.array.iterator", ["npm:core-js@1.2.3/library/modules/$.unscope", "npm:core-js@1.2.3/library/modules/$.iter-step", "npm:core-js@1.2.3/library/modules/$.iterators", "npm:core-js@1.2.3/library/modules/$.to-iobject", "npm:core-js@1.2.3/library/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var setUnscope = $__require('npm:core-js@1.2.3/library/modules/$.unscope'),
      step = $__require('npm:core-js@1.2.3/library/modules/$.iter-step'),
      Iterators = $__require('npm:core-js@1.2.3/library/modules/$.iterators'),
      toIObject = $__require('npm:core-js@1.2.3/library/modules/$.to-iobject');
  $__require('npm:core-js@1.2.3/library/modules/$.iter-define')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  setUnscope('keys');
  setUnscope('values');
  setUnscope('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/web.dom.iterable", ["npm:core-js@1.2.3/library/modules/es6.array.iterator", "npm:core-js@1.2.3/library/modules/$.iterators"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.array.iterator');
  var Iterators = $__require('npm:core-js@1.2.3/library/modules/$.iterators');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.tag", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.has", "npm:core-js@1.2.3/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('npm:core-js@1.2.3/library/modules/$').setDesc,
      has = $__require('npm:core-js@1.2.3/library/modules/$.has'),
      TAG = $__require('npm:core-js@1.2.3/library/modules/$.wks')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iter-create", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.hide", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.property-desc", "npm:core-js@1.2.3/library/modules/$.tag"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.3/library/modules/$.hide')(IteratorPrototype, $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: $__require('npm:core-js@1.2.3/library/modules/$.property-desc')(1, next)});
    $__require('npm:core-js@1.2.3/library/modules/$.tag')(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iterators", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.uid", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.shared", ["npm:core-js@1.2.3/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/library/modules/$.global'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.wks", ["npm:core-js@1.2.3/library/modules/$.shared", "npm:core-js@1.2.3/library/modules/$.global", "npm:core-js@1.2.3/library/modules/$.uid"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('npm:core-js@1.2.3/library/modules/$.shared')('wks'),
      Symbol = $__require('npm:core-js@1.2.3/library/modules/$.global').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || $__require('npm:core-js@1.2.3/library/modules/$.uid'))('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.has", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.fails", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.support-desc", ["npm:core-js@1.2.3/library/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('npm:core-js@1.2.3/library/modules/$.fails')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.property-desc", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.hide", ["npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.property-desc", "npm:core-js@1.2.3/library/modules/$.support-desc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.3/library/modules/$'),
      createDesc = $__require('npm:core-js@1.2.3/library/modules/$.property-desc');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.support-desc') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.redef", ["npm:core-js@1.2.3/library/modules/$.hide"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.hide');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.core", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.3'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.global", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.def", ["npm:core-js@1.2.3/library/modules/$.global", "npm:core-js@1.2.3/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.3/library/modules/$.global'),
      core = $__require('npm:core-js@1.2.3/library/modules/$.core'),
      PROTOTYPE = 'prototype';
  var ctx = function(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var $def = function(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {})[PROTOTYPE],
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && typeof target[key] != 'function')
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp[PROTOTYPE] = C[PROTOTYPE];
        }(out);
      else
        exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.library", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.iter-define", ["npm:core-js@1.2.3/library/modules/$.library", "npm:core-js@1.2.3/library/modules/$.def", "npm:core-js@1.2.3/library/modules/$.redef", "npm:core-js@1.2.3/library/modules/$.hide", "npm:core-js@1.2.3/library/modules/$.has", "npm:core-js@1.2.3/library/modules/$.wks", "npm:core-js@1.2.3/library/modules/$.iterators", "npm:core-js@1.2.3/library/modules/$.iter-create", "npm:core-js@1.2.3/library/modules/$", "npm:core-js@1.2.3/library/modules/$.tag"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('npm:core-js@1.2.3/library/modules/$.library'),
      $def = $__require('npm:core-js@1.2.3/library/modules/$.def'),
      $redef = $__require('npm:core-js@1.2.3/library/modules/$.redef'),
      hide = $__require('npm:core-js@1.2.3/library/modules/$.hide'),
      has = $__require('npm:core-js@1.2.3/library/modules/$.has'),
      SYMBOL_ITERATOR = $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.3/library/modules/$.iterators'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
    $__require('npm:core-js@1.2.3/library/modules/$.iter-create')(Constructor, NAME, next);
    var createMethod = function(kind) {
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        proto = Base.prototype,
        _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        _default = _native || createMethod(DEFAULT),
        methods,
        key;
    if (_native) {
      var IteratorPrototype = $__require('npm:core-js@1.2.3/library/modules/$').getProto(_default.call(new Base));
      $__require('npm:core-js@1.2.3/library/modules/$.tag')(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
    }
    if (!LIBRARY || FORCE)
      hide(proto, SYMBOL_ITERATOR, _default);
    Iterators[NAME] = _default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEFAULT == VALUES ? _default : createMethod(VALUES),
        keys: IS_SET ? _default : createMethod(KEYS),
        entries: DEFAULT != VALUES ? _default : createMethod('entries')
      };
      if (FORCE)
        for (key in methods) {
          if (!(key in proto))
            $redef(proto, key, methods[key]);
        }
      else
        $def($def.P + $def.F * BUGGY, NAME, methods);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.defined", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.to-integer", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/$.string-at", ["npm:core-js@1.2.3/library/modules/$.to-integer", "npm:core-js@1.2.3/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.3/library/modules/$.to-integer'),
      defined = $__require('npm:core-js@1.2.3/library/modules/$.defined');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/modules/es6.string.iterator", ["npm:core-js@1.2.3/library/modules/$.string-at", "npm:core-js@1.2.3/library/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('npm:core-js@1.2.3/library/modules/$.string-at')(true);
  $__require('npm:core-js@1.2.3/library/modules/$.iter-define')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.3/library/fn/symbol/iterator", ["npm:core-js@1.2.3/library/modules/es6.string.iterator", "npm:core-js@1.2.3/library/modules/web.dom.iterable", "npm:core-js@1.2.3/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.3/library/modules/es6.string.iterator');
  $__require('npm:core-js@1.2.3/library/modules/web.dom.iterable');
  module.exports = $__require('npm:core-js@1.2.3/library/modules/$.wks')('iterator');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.25/core-js/symbol/iterator", ["npm:core-js@1.2.3/library/fn/symbol/iterator"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.3/library/fn/symbol/iterator'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register('app/app.js', ['npm:babel-runtime@5.8.25/core-js/symbol/iterator', 'npm:bluebird@2.10.2', 'github:angular/bower-angular@1.4.7', 'github:angular/bower-angular-messages@1.4.7', 'github:angular/bower-angular-mocks@1.4.7', 'github:angular/bower-angular-sanitize@1.4.7', 'npm:ng-sortable@1.3.1', 'npm:angular-ui-router@0.2.15', 'npm:babel-core@5.8.25/polyfill', 'app/Core/Components/Action/ActionDirective.js', 'app/Core/Components/Checkbox/CheckboxDirective.js', 'app/Core/Components/ConfirmDialog/ConfirmDialogDirective.js', 'app/Core/Components/DragFile/DragFileDirective.js', 'app/Core/Components/DropFile/DropFileDirective.js', 'app/Core/Components/FileTree/FileTreeDirective.js', 'app/Core/Components/GiveFocus/GiveFocusDirective.js', 'app/Core/Components/LiteralInput/LiteralInputDirective.js', 'app/Core/Components/Notifier/NotifierDirective.js', 'app/Core/Components/PanelHandle/PanelHandleDirective.js', 'app/Core/Components/SelectInput/SelectInputDirective.js', 'app/Core/Components/StepInput/StepInputDirective.js', 'app/Core/Components/Submit/SubmitDirective.js', 'app/Core/Components/TextInput/TextInputDirective.js', 'app/Core/Components/VariableInput/VariableInputDirective.js', 'app/Core/Validators/ExampleNameValidator.js', 'app/Core/Validators/FileNameValidator.js', 'app/Core/Validators/VariableNameValidator.js', 'app/Core/Services/FileStructureService.js', 'app/Core/Services/HttpResponseInterceptor.js', 'app/Core/Services/RealTimeService.js', 'app/features/ControlPanel/ControlPanelController.js', 'app/features/ControlPanel/ControlPanel.html', 'app/features/ComponentEditor/ComponentEditorController.js', 'app/features/ComponentEditor/Services/ComponentFileService.js', 'app/features/ComponentEditor/ComponentEditor.html', 'app/features/FeatureEditor/FeatureEditorController.js', 'app/features/FeatureEditor/Services/FeatureFileService.js', 'app/features/FeatureEditor/FeatureEditor.html', 'app/features/MockDataEditor/MockDataEditorController.js', 'app/features/MockDataEditor/Services/MockDataFileService.js', 'app/features/MockDataEditor/MockDataEditor.html', 'app/features/StepDefinitionEditor/StepDefinitionEditorController.js', 'app/features/StepDefinitionEditor/Services/StepDefinitionFileService.js', 'app/features/StepDefinitionEditor/StepDefinitionEditor.html'], function (_export) {
    var _Symbol$iterator, Promise, angular, ActionDirective, CheckboxDirective, ConfirmDialogDirective, DragFileDirective, DropFileDirective, FileTreeDirective, GiveFocusDirective, LiteralInputDirective, NotifierDirective, PanelHandleDirective, SelectInputDirective, StepInputDirective, SubmitDirective, TextInputDirective, VariableInputDirective, ExampleNameValidator, FileNameValidator, VariableNameValidator, FileStructureService, HttpResponseInterceptor, RealTimeService, ControlPanelController, controlPanelTemplate, ComponentEditorController, ComponentFileService, componentEditorTemplate, FeatureEditorController, FeatureFileService, featureEditorTemplate, MockDataEditorController, MockDataFileService, mockDataEditorTemplate, StepDefinitionEditorController, StepDefinitionFileService, stepDefinitionEditorTemplate, tractor, $http;

    return {
        setters: [function (_npmBabelRuntime5825CoreJsSymbolIterator) {
            _Symbol$iterator = _npmBabelRuntime5825CoreJsSymbolIterator['default'];
        }, function (_npmBluebird2102) {
            Promise = _npmBluebird2102['default'];
        }, function (_githubAngularBowerAngular147) {
            angular = _githubAngularBowerAngular147['default'];
        }, function (_githubAngularBowerAngularMessages147) {}, function (_githubAngularBowerAngularMocks147) {}, function (_githubAngularBowerAngularSanitize147) {}, function (_npmNgSortable131) {}, function (_npmAngularUiRouter0215) {}, function (_npmBabelCore5825Polyfill) {}, function (_appCoreComponentsActionActionDirectiveJs) {
            ActionDirective = _appCoreComponentsActionActionDirectiveJs['default'];
        }, function (_appCoreComponentsCheckboxCheckboxDirectiveJs) {
            CheckboxDirective = _appCoreComponentsCheckboxCheckboxDirectiveJs['default'];
        }, function (_appCoreComponentsConfirmDialogConfirmDialogDirectiveJs) {
            ConfirmDialogDirective = _appCoreComponentsConfirmDialogConfirmDialogDirectiveJs['default'];
        }, function (_appCoreComponentsDragFileDragFileDirectiveJs) {
            DragFileDirective = _appCoreComponentsDragFileDragFileDirectiveJs['default'];
        }, function (_appCoreComponentsDropFileDropFileDirectiveJs) {
            DropFileDirective = _appCoreComponentsDropFileDropFileDirectiveJs['default'];
        }, function (_appCoreComponentsFileTreeFileTreeDirectiveJs) {
            FileTreeDirective = _appCoreComponentsFileTreeFileTreeDirectiveJs['default'];
        }, function (_appCoreComponentsGiveFocusGiveFocusDirectiveJs) {
            GiveFocusDirective = _appCoreComponentsGiveFocusGiveFocusDirectiveJs['default'];
        }, function (_appCoreComponentsLiteralInputLiteralInputDirectiveJs) {
            LiteralInputDirective = _appCoreComponentsLiteralInputLiteralInputDirectiveJs['default'];
        }, function (_appCoreComponentsNotifierNotifierDirectiveJs) {
            NotifierDirective = _appCoreComponentsNotifierNotifierDirectiveJs['default'];
        }, function (_appCoreComponentsPanelHandlePanelHandleDirectiveJs) {
            PanelHandleDirective = _appCoreComponentsPanelHandlePanelHandleDirectiveJs['default'];
        }, function (_appCoreComponentsSelectInputSelectInputDirectiveJs) {
            SelectInputDirective = _appCoreComponentsSelectInputSelectInputDirectiveJs['default'];
        }, function (_appCoreComponentsStepInputStepInputDirectiveJs) {
            StepInputDirective = _appCoreComponentsStepInputStepInputDirectiveJs['default'];
        }, function (_appCoreComponentsSubmitSubmitDirectiveJs) {
            SubmitDirective = _appCoreComponentsSubmitSubmitDirectiveJs['default'];
        }, function (_appCoreComponentsTextInputTextInputDirectiveJs) {
            TextInputDirective = _appCoreComponentsTextInputTextInputDirectiveJs['default'];
        }, function (_appCoreComponentsVariableInputVariableInputDirectiveJs) {
            VariableInputDirective = _appCoreComponentsVariableInputVariableInputDirectiveJs['default'];
        }, function (_appCoreValidatorsExampleNameValidatorJs) {
            ExampleNameValidator = _appCoreValidatorsExampleNameValidatorJs['default'];
        }, function (_appCoreValidatorsFileNameValidatorJs) {
            FileNameValidator = _appCoreValidatorsFileNameValidatorJs['default'];
        }, function (_appCoreValidatorsVariableNameValidatorJs) {
            VariableNameValidator = _appCoreValidatorsVariableNameValidatorJs['default'];
        }, function (_appCoreServicesFileStructureServiceJs) {
            FileStructureService = _appCoreServicesFileStructureServiceJs['default'];
        }, function (_appCoreServicesHttpResponseInterceptorJs) {
            HttpResponseInterceptor = _appCoreServicesHttpResponseInterceptorJs['default'];
        }, function (_appCoreServicesRealTimeServiceJs) {
            RealTimeService = _appCoreServicesRealTimeServiceJs['default'];
        }, function (_appFeaturesControlPanelControlPanelControllerJs) {
            ControlPanelController = _appFeaturesControlPanelControlPanelControllerJs['default'];
        }, function (_appFeaturesControlPanelControlPanelHtml) {
            controlPanelTemplate = _appFeaturesControlPanelControlPanelHtml['default'];
        }, function (_appFeaturesComponentEditorComponentEditorControllerJs) {
            ComponentEditorController = _appFeaturesComponentEditorComponentEditorControllerJs['default'];
        }, function (_appFeaturesComponentEditorServicesComponentFileServiceJs) {
            ComponentFileService = _appFeaturesComponentEditorServicesComponentFileServiceJs['default'];
        }, function (_appFeaturesComponentEditorComponentEditorHtml) {
            componentEditorTemplate = _appFeaturesComponentEditorComponentEditorHtml['default'];
        }, function (_appFeaturesFeatureEditorFeatureEditorControllerJs) {
            FeatureEditorController = _appFeaturesFeatureEditorFeatureEditorControllerJs['default'];
        }, function (_appFeaturesFeatureEditorServicesFeatureFileServiceJs) {
            FeatureFileService = _appFeaturesFeatureEditorServicesFeatureFileServiceJs['default'];
        }, function (_appFeaturesFeatureEditorFeatureEditorHtml) {
            featureEditorTemplate = _appFeaturesFeatureEditorFeatureEditorHtml['default'];
        }, function (_appFeaturesMockDataEditorMockDataEditorControllerJs) {
            MockDataEditorController = _appFeaturesMockDataEditorMockDataEditorControllerJs['default'];
        }, function (_appFeaturesMockDataEditorServicesMockDataFileServiceJs) {
            MockDataFileService = _appFeaturesMockDataEditorServicesMockDataFileServiceJs['default'];
        }, function (_appFeaturesMockDataEditorMockDataEditorHtml) {
            mockDataEditorTemplate = _appFeaturesMockDataEditorMockDataEditorHtml['default'];
        }, function (_appFeaturesStepDefinitionEditorStepDefinitionEditorControllerJs) {
            StepDefinitionEditorController = _appFeaturesStepDefinitionEditorStepDefinitionEditorControllerJs['default'];
        }, function (_appFeaturesStepDefinitionEditorServicesStepDefinitionFileServiceJs) {
            StepDefinitionFileService = _appFeaturesStepDefinitionEditorServicesStepDefinitionFileServiceJs['default'];
        }, function (_appFeaturesStepDefinitionEditorStepDefinitionEditorHtml) {
            stepDefinitionEditorTemplate = _appFeaturesStepDefinitionEditorStepDefinitionEditorHtml['default'];
        }],
        execute: function () {

            // Dependencies:
            'use strict';

            // Utilities:

            NodeList.prototype[_Symbol$iterator] = Array.prototype[_Symbol$iterator];
            angular.element.prototype[_Symbol$iterator] = Array.prototype[_Symbol$iterator];

            // Application Init:
            tractor = angular.module('tractor', ['ngMessages', 'ui.router', 'as.sortable', ActionDirective.name, CheckboxDirective.name, ConfirmDialogDirective.name, DragFileDirective.name, DropFileDirective.name, FileTreeDirective.name, GiveFocusDirective.name, LiteralInputDirective.name, NotifierDirective.name, PanelHandleDirective.name, SelectInputDirective.name, StepInputDirective.name, SubmitDirective.name, TextInputDirective.name, VariableInputDirective.name, ExampleNameValidator.name, FileNameValidator.name, VariableNameValidator.name, FileStructureService.name, HttpResponseInterceptor.name, RealTimeService.name, ControlPanelController.name, ComponentEditorController.name, ComponentFileService.name, FeatureEditorController.name, FeatureFileService.name, MockDataEditorController.name, MockDataFileService.name, StepDefinitionEditorController.name, StepDefinitionFileService.name]);

            tractor.config(function ($stateProvider, $locationProvider, $urlMatcherFactoryProvider, $urlRouterProvider) {
                $urlRouterProvider.otherwise('/');
                $locationProvider.html5Mode(true);

                $urlMatcherFactoryProvider.type('TractorFile', {
                    encode: function encode(toEncode) {
                        return toEncode && toEncode.name ? toEncode.name.replace(/\s/g, '+') : '';
                    },
                    decode: function decode(toDecode) {
                        return toDecode && angular.isString(toDecode) ? { name: toDecode.replace(/\+/g, ' ') } : toDecode;
                    },
                    is: function is(tractorFile) {
                        return !tractorFile || tractorFile && tractorFile.name;
                    },
                    equals: function equals(a, b) {
                        return a && a.name && b && b.name && a.name === b.name;
                    }
                });

                $stateProvider.state('tractor', {
                    url: '/',
                    template: controlPanelTemplate,
                    controller: 'ControlPanelController as controlPanel'
                }).state('tractor.components', {
                    url: 'components/{file:TractorFile}',
                    template: componentEditorTemplate,
                    controller: 'ComponentEditorController as componentEditor',
                    resolve: {
                        componentFileStructure: function componentFileStructure(componentFileService) {
                            return componentFileService.getFileStructure();
                        },
                        componentPath: function componentPath($stateParams, componentFileService) {
                            var name = $stateParams.file && $stateParams.file.name;
                            return name ? componentFileService.getPath({ name: name }) : null;
                        }
                    }
                }).state('tractor.features', {
                    url: 'features/{file:TractorFile}',
                    template: featureEditorTemplate,
                    controller: 'FeatureEditorController as featureEditor',
                    resolve: {
                        featureFileStructure: function featureFileStructure(featureFileService) {
                            return featureFileService.getFileStructure();
                        },
                        featurePath: function featurePath($stateParams, featureFileService) {
                            var name = $stateParams.file && $stateParams.file.name;
                            return name ? featureFileService.getPath({ name: name }) : null;
                        }
                    }
                }).state('tractor.mock-data', {
                    url: 'mock-data/{file:TractorFile}',
                    template: mockDataEditorTemplate,
                    controller: 'MockDataEditorController as mockDataEditor',
                    resolve: {
                        mockDataFileStructure: function mockDataFileStructure(mockDataFileService) {
                            return mockDataFileService.getFileStructure();
                        },
                        mockDataPath: function mockDataPath($stateParams, mockDataFileService) {
                            var name = $stateParams.file && $stateParams.file.name;
                            return name ? mockDataFileService.getPath({ name: name }) : null;
                        }
                    }
                }).state('tractor.step-definitions', {
                    url: 'step-definitions/{file:TractorFile}',
                    template: stepDefinitionEditorTemplate,
                    controller: 'StepDefinitionEditorController as stepDefinitionEditor',
                    resolve: {
                        stepDefinitionFileStructure: function stepDefinitionFileStructure(stepDefinitionFileService) {
                            return stepDefinitionFileService.getFileStructure();
                        },
                        stepDefinitionPath: function stepDefinitionPath($stateParams, stepDefinitionFileService) {
                            var name = $stateParams.file && $stateParams.file.name;
                            return name ? stepDefinitionFileService.getPath({ name: name }) : null;
                        }
                    }
                });
            }).run(function ($rootScope) {
                Promise.longStackTraces();
                Promise.setScheduler(function (callback) {
                    $rootScope.$evalAsync(callback);
                });
            });

            $http = angular.injector(['ng']).get('$http');

            $http.get('/config').then(function (response) {
                tractor.constant('config', response.data);
                angular.bootstrap(document.body, ['tractor']);
            });
        }
    };
});
//# sourceMappingURL=bundle.js.map